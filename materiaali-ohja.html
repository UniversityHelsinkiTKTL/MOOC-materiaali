<!DOCTYPE html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<title>Ohjelmoinnin perusteet ja jatkokurssi</title>
<link rel="stylesheet" href="stylesheets/menu.css" type="text/css" media="screen" />


<link rel="stylesheet" href="stylesheets/common-new.css" type="text/css" media="screen, print" />

<script type="text/javascript" src="js/bootstrap.min.js"></script>


<!-- BEGIN MOOC SNIP -->
<script type="text/javascript" src="javascripts/html5shiv.js"></script>
<script type="text/javascript" src="javascripts/jquery-1.7.1.min.js"></script>
<script type="text/javascript" src="javascripts/exercises2.js"></script>
<script type="text/javascript" src="javascripts/common-new.js"></script>
<script type="text/javascript" src="javascripts/shjs/sh_main.min.js"></script>
<script type="text/javascript" src="javascripts/shjs/sh_java.min.js"></script>
<!-- END MOOC SNIP -->

<link rel="stylesheet" href="stylesheets/shjs/sh_style.css" type="text/css" media="screen, print" />
<link rel="stylesheet" href="stylesheets/common-new.css" type="text/css" media="screen, print" />
<script type="text/javascript" src="javascripts/jquery.easing.js"></script>

<script type="text/javascript">
jQuery(document).ready(function() {
    $(".tehtava").hide();
    $("div.toc_viikko").hide();
    $(".heading").click(function()      {
      $(this).next(".tehtava").slideToggle(200);
      });});
</script>
</head>

<body>

<h1>Ohjelmoinnin jatkokurssi</h1>

<p>Arto Vihavainen ja Matti Luukkainen</p>

<div id="toc" class="menu" data-first-chapter-index="1" data-first-exercise-index="1">
  <div id="materiaali_toc"></div>
  <!--div id="tehtavat_toc"></div-->
  <div id="tehtavat_toc2"></div>
</div>
<!-- BEGIN MOOC SNIP -->
<p><strong><big>Huomautus lukijalle</big></strong></p>
<section class="viikkoraja" id="0">
  <div div class="viikkoraja-mooc" id="Huomautus lukijalle" tekija="Arto Vihavainen, Matti Luukkainen">

    <p class="hidden-kesakurssit">Tämä on suoraa jatkoa Ohjelmoinnin perusteet -kurssin <a href="https://www.cs.helsinki.fi/group/java/s13/ohpe/index.html">materiaaliin.</a></p>

    <p class="hidden-kesakurssit">Tämä materiaali on tarkoitettu Helsingin Yliopiston Tietojenkäsittelytieteen laitoksen syksyn 2012 Ohjelmoinnin perusteet- ja jatkokurssille.
    Materiaali pohjautuu keväiden 2012, 2011 ja 2010 kurssimateriaaleihin, joiden sisältöön ovat vaikuttaneet Matti Paksula, Antti Laaksonen, Pekka Mikkola, Juhana Laurinharju, Martin Pärtel, Joel Kaasinen ja Mikael Nousiainen</p>

    <p>Lue materiaalia siten, että teet samalla itse kaikki lukemasi esimerkit. Esimerkkeihin kannattaa tehdä pieniä muutoksia ja tarkkailla, miten muutokset vaikuttavat ohjelman toimintaan. Äkkiseltään voisi luulla, että esimerkkien tekeminen myös itse ja niiden muokkaaminen hidastaa opiskelua. Tämä ei kuitenkaan pidä ollenkaan paikkansa. Ohjelmoimaan ei ole vielä tietääksemme kukaan ihminen oppinut lukemalla (tai esim. luentoa kuuntelemalla). Oppiminen perustuu oleellisesti aktiiviseen tekemiseen ja rutiinin kasvattamiseen. Esimerkkien ja erityisesti erilaisten omien kokeilujen tekeminen on parhaita tapoja "sisäistää" luettua tekstiä. </p>

    <p>Pyri tekemään tai ainakin yrittämään tehtäviä sitä mukaa kuin luet tekstiä. Jos et osaa heti tehdä jotain tehtävää, älä masennu, sillä saat ohjausta tehtävän tekemiseen pajassa.</p>

    <p>Tekstiä ei ole tarkoitettu vain kertaalleen luettavaksi. Joudut varmasti myöhemmin palaamaan jo aiemmin lukemiisi kohtiin tai aiemmin tekemiisi tehtäviin. Tämä teksti ei sisällä kaikkea oleellista ohjelmointiin liittyvää. Itse asiassa ei ole olemassa mitään kirjaa josta löytyisi kaikki oleellinen. Eli joudut joka tapauksessa ohjelmoijan urallasi etsimään tietoa myös omatoimisesti. Kurssin harjoitukset sisältävät jo jonkun verran ohjeita, mistä suunnista ja miten hyödyllistä tietoa on mahdollista löytää.</p>

    <p>Muutamiin kohtiin olemme myös liittäneet screencasteja joita katsomalla voi pelkän valmiin koodin lukemisen sijaan seurata miten ohjelma muodostuu.</p>

    <p></p>

    <p>Kurssi alkaa siitä mihin ohjelmoinnin perusteet loppui ja oikeastaan kaikki ohjelmoinnin perusteet -kurssilla opitut asiat oletetaan nyt osattavan. Kannattaa käydä aina silloin tällöin kertaamassa Ohjelmoinnin perusteet -kurssin  <a class="hidden-kesakurssit" href="https://www.cs.helsinki.fi/group/java/s13/ohpe/index.html">materiaalia.</a></p>


    <p><em>Huom!</em> Käytämme tällä kurssilla <a href="http://netbeans.org/">NetBeans</a>-nimistä ohjelmointiympäristöä. Ohjeet NetBeansin ja kurssilla käytettävän tehtäväautomaatin käyttöön löydät <a class="hidden-in-hy" href=" http://mooc.cs.helsinki.fi/ohjelmointi/ohjeita#netbeans-ohjeita">täältä</a><a  class="hidden-in-mooc" href="http://www.cs.helsinki.fi/group/java/k14/ohpe/nb-asennus.html">täältä</a>.</p>
  </div>
</section>

<!-- END MOOC SNIP -->
<section class="viikkoraja" id="1" >
  <div class="viikkoraja"></div>
  <div class="viikkoraja-mooc" id="Viikko 7" deadline=" " data-first-chapter-index="33" data-first-exercise-index="108" data-first-week-index="7"  data-first-chapter-index-mooc="33" data-first-exercise-index-mooc="108" data-first-week-index-mooc="7" tekija="Arto Vihavainen, Matti Luukkainen">


<div class="panel-group" id="1taustatiedot">
  <div class="panel panel-default">
    <a class="panel-title" data-toggle="collapse" data-parent="#1taustatiedot" href="#1taustatiedot2">
      <div class="panel-heading">
	<h4 id="taustatiedot-form-ohja-legend">Kysely: Taustatiedot</h4>
    </div>
    </a>
    <div class="panel-collapse collapse" id="1taustatiedot2">
      <div class="panel-body">

        <!-- Taustatiedot -->
<form class="form-horizontal" id="taustatiedot-form-ohja">
            <fieldset>
                <legend id="taustatiedot-form-ohja-legend">Kysely: Taustatiedot</legend>
                <p class="help-block">Käytämme tietoja kurssiemme kehittämiseen ja opetuksen tutkimukseen. Vaikka osa kyselyistä on samoja kuin kurssilla ohjelmoinnin perusteet, vastaathan niihin silti.</p>

                <!-- TMC-tunnus-->
                <div class="form-group">
                    <label class="col-md-4 control-label" for="taustatiedot-form-ohja-tmc-tunnus">TMC-tunnus</label>  
                    <div class="col-md-4">
                        <input id="taustatiedot-form-ohja-tmc-tunnus" name="taustatiedot-form-ohja-tmc-tunnus" type="text" class="form-control input-md">
                    </div>
                </div>

                <!-- Syntymävuosi -->
                <div class="form-group">
                    <label class="col-md-4 control-label" for="taustatiedot-form-ohja-syntymavuosi">Syntymävuosi</label>  
                    <div class="col-md-1">
                        <input id="taustatiedot-form-ohja-syntymavuosi" name="taustatiedot-form-ohja-syntymavuosi" type="text" class="form-control" maxlength="4">
                    </div>
                </div>

                <!-- Sukupuoli -->
                <div class="form-group">
                    <label class="col-md-4 control-label" for="sukupuoli">Sukupuoli</label>
                    <div class="col-md-4">
                        <div class="radio">
                            <label for="sukupuoli-nainen">
                                <input type="radio" name="sukupuoli" id="sukupuoli-nainen" value="sukupuoli-nainen">
                                Nainen
                            </label>
                        </div>
                        <div class="radio">
                            <label for="sukupuoli-mies">
                                <input type="radio" name="sukupuoli" id="sukupuoli-mies" value="sukupuoli-mies">
                                Mies
                            </label>
                        </div>

                        <div class="radio">
                            <label for="sukupuoli-muu">
                                <input type="radio" name="sukupuoli" id="sukupuoli-muu" value="sukupuoli-muu">
                                Muu tai en halua kertoa
                            </label>
                        </div>
                    </div>
                </div>


                <!-- Kätisyys -->
                <div class="form-group">
                    <label class="col-md-4 control-label" for="katisyys">Kätisyys</label>
                    <div class="col-md-4">
                        <div class="radio">
                            <label for="katisyys-vasen">
                                <input type="radio" name="katisyys" id="katisyys-vasen" value="katisyys-vasen">
                                Vasen
                            </label>
                        </div>
                        <div class="radio">
                            <label for="katisyys-oikea">
                                <input type="radio" name="katisyys" id="katisyys-oikea" value="katisyys-oikea">
                                Oikea
                            </label>
                        </div>

                        <div class="radio">
                            <label for="katisyys-muu">
                                <input type="radio" name="katisyys" id="katisyys-muu" value="katisyys-muu">
                                Muu tai en halua kertoa
                            </label>
                        </div>
                    </div>
                </div>

                <!-- Koulutusaste -->
                <div class="form-group">
                    <label class="col-md-4 control-label" for="koulutusaste">Koulutusaste</label>
                    <div class="col-md-4">
                        <div class="radio">
                            <label for="koulutusaste-peruskoulu-kansakoulu">
                                <input type="radio" name="koulutusaste" id="koulutusaste-peruskoulu-kansakoulu" value="koulutusaste-peruskoulu-kansakoulu">
                                Peruskoulu tai kansakoulu
                            </label>
                        </div>
                        <div class="radio">
                            <label for="koulutusaste-keskiaste">
                                <input type="radio" name="koulutusaste" id="koulutusaste-keskiaste" value="koulutusaste-keskiaste">
                                Keskiaste (lukio / ammatilliset oppilaitokset)
                            </label>
                        </div>
                        <div class="radio">
                            <label for="koulutusaste-ammattikorkeakoulu">
                                <input type="radio" name="koulutusaste" id="koulutusaste-ammattikorkeakoulu" value="koulutusaste-ammattikorkeakoulu">
                                Ammattikorkeakoulututkinto
                            </label>
                        </div>

                        <div class="radio">
                            <label for="koulutusaste-alempi-korkeakoulu">
                                <input type="radio" name="koulutusaste" id="koulutusaste-alempi-korkeakoulu" value="koulutusaste-alempi-korkeakoulu">
                                Alempi korkeakoulututkinto
                            </label>
                        </div>

                        <div class="radio">
                            <label for="koulutusaste-ylempi-korkeakoulu">
                                <input type="radio" name="koulutusaste" id="koulutusaste-ylempi-korkeakoulu" value="koulutusaste-ylempi-korkeakoulu">
                                Ylempi korkeakoulututkinto
                            </label>
                        </div>

                        <div class="radio">
                            <label for="koulutusaste-lisensiaatti-tai-tohtori">
                                <input type="radio" name="koulutusaste" id="koulutusaste-lisensiaatti-tai-tohtori" value="koulutusaste-lisensiaatti-tai-tohtori">
                                Lisensiaatin- tai tohtorintutkinto
                            </label>
                        </div>
                    </div>
                </div>                

                <!-- Työssäkäynti -->
                <div class="form-group">
                    <label class="col-md-4 control-label" for="tyossakaynti">Olen tällä hetkellä</label>
                    <div class="col-md-4">
                        <div class="radio">
                            <label for="tyossakaynti-opiskelija">
                                <input type="radio" name="tyossakaynti" id="tyossakaynti-opiskelija" value="tyossakaynti-opiskelija">
                                Opiskelija
                            </label>
                        </div>
                        <div class="radio">
                            <label for="tyossakaynti-opiskelija-ja-osaaikainen">
                                <input type="radio" name="tyossakaynti" id="tyossakaynti-opiskelija-ja-osaaikainen" value="tyossakaynti-opiskelija-ja-osaaikainen">
                                Opiskelija ja osa-aikaisesti töissä
                            </label>
                        </div>
                        <div class="radio">
                            <label for="tyossakaynti-opiskelija-ja-taysipaivaisesti-toissa">
                                <input type="radio" name="tyossakaynti" id="tyossakaynti-opiskelija-ja-taysipaivaisesti-toissa" value="tyossakaynti-opiskelija-ja-taysipaivaisesti-toissa">
                                Opiskelija ja täysipäiväisesti töissä
                            </label>
                        </div>
                        <div class="radio">
                            <label for="tyossakaynti-tyoelamassa">
                                <input type="radio" name="tyossakaynti" id="tyossakaynti-tyoelamassa" value="tyossakaynti-tyoelamassa">
                                Työelämässä
                            </label>
                        </div>
                        <div class="radio">
                            <label for="tyossakaynti-tyoton">
                                <input type="radio" name="tyossakaynti" id="tyossakaynti-tyoton" value="tyossakaynti-tyoton">
                                Työtön
                            </label>
                        </div>

                        <div class="radio">
                            <label for="tyossakaynti-vapaalla">
                                <input type="radio" name="tyossakaynti" id="tyossakaynti-vapaalla" value="tyossakaynti-vapaalla">
                                Vanhempainvapaalla tai muulla vastaavalla
                            </label>
                        </div>

                        <div class="radio">
                            <label for="tyossakaynti-elakkeella">
                                <input type="radio" name="tyossakaynti" id="tyossakaynti-elakkeella" value="tyossakaynti-elakkeella">
                                Eläkkeellä
                            </label>
                        </div>
                    </div>
                </div>

                <!-- tarkennus jos toissa -->
                <div class="hidden" id="tyossakaynti-tarkennus">

                    <div class="form-group">
                        <label class="col-md-4 control-label" for="tyossakaynti-tunteja-viikossa">Kuinka monta tuntia teet töitä viikossa?</label>  
                        <div class="col-md-4">
                            <input id="tyossakaynti-tunteja-viikossa" name="tyossakaynti-tunteja-viikossa" type="text" class="form-control input-md">
                        </div>
                    </div>


                    <div class="form-group">
                        <label class="col-md-4 control-label" for="tyossakaynti-tyonkuva">Kuvaile työnkuvaasi lyhyesti</label>  
                        <div class="col-md-4">
                            <input id="tyossakaynti-tyonkuva" name="tyossakaynti-tyonkuva" type="text" class="form-control input-md">
                        </div>
                    </div>
                </div>

                <!-- tarkennus jos aiemmin toissa -->
                <div class="hidden" id="tyossakaynti-aiempi-tarkennus">
                    <div class="form-group">
                        <label class="col-md-4 control-label" for="tyossakaynti-edellinen-tyonkuva">Jos olet ollut aiemmin töissä, kuvaile edellistä työnkuvaasi lyhyesti</label>  
                        <div class="col-md-4">
                            <input id="tyossakaynti-edellinen-tyonkuva" name="tyossakaynti-edellinen-tyonkuva" type="text" class="form-control input-md">
                        </div>
                    </div>
                </div>

                <!-- ohjelmointikokemus -->
                <div class="form-group">
                    <label class="col-md-4 control-label" for="ohjelmointikokemus">Aiempi ohjelmointikokemus</label>
                    <div class="col-md-4">
                        <div class="radio">
                            <label for="ohjelmointikokemus-ei-mitaan">
                                <input type="radio" name="ohjelmointikokemus" id="ohjelmointikokemus-ei-mitaan" value="ohjelmointikokemus-ei-mitaan">
                                En ole ohjelmoinut koskaan
                            </label>
                        </div>
                        <div class="radio">
                            <label for="ohjelmointikokemus-hieman">
                                <input type="radio" name="ohjelmointikokemus" id="ohjelmointikokemus-hieman" value="ohjelmointikokemus-hieman">
                                Olen osallistunut joskus ohjelmointikurssille
                            </label>
                        </div>
                        <div class="radio">
                            <label for="ohjelmointikokemus-itsekseni">
                                <input type="radio" name="ohjelmointikokemus" id="ohjelmointikokemus-itsekseni" value="ohjelmointikokemus-itsekseni">
                                Ohjelmoin silloin tällöin itsekseni
                            </label>
                        </div>
                        <div class="radio">
                            <label for="ohjelmointikokemus-ryhmassa-kurssi">
                                <input type="radio" name="ohjelmointikokemus" id="ohjelmointikokemus-ryhmassa-kurssi" value="ohjelmointikokemus-ryhmassa-kurssi">
                                Olen ohjelmoinut ryhmässä, esimerkiksi osana jotain kurssia
                            </label>
                        </div>
                        <div class="radio">
                            <label for="ohjelmointikokemus-ryhmassa-tyo">
                                <input type="radio" name="ohjelmointikokemus" id="ohjelmointikokemus-ryhmassa-tyo" value="ohjelmointikokemus-ryhmassa-tyo">
                                Olen osallistunut ohjelmistoprojektiin osana työtäni
                            </label>
                        </div>

                        <div class="radio">
                            <label for="ohjelmointikokemus-ryhmassa-tyo-useampi-projekti">
                                <input type="radio" name="ohjelmointikokemus" id="ohjelmointikokemus-ryhmassa-tyo-useampi-projekti" value="ohjelmointikokemus-ryhmassa-tyo-useampi-projekti">
                                Olen osallistunut useampaan ohjelmistoprojektiin osana työtäni
                            </label>
                        </div>


                        <div class="radio">
                            <label for="ohjelmointikokemus-muu">
                                <input type="radio" name="ohjelmointikokemus" id="ohjelmointikokemus-muu" value="ohjelmointikokemus-muu">
                                Muu, mikä?
                            </label>
                            <input id="ohjelmointikokemus-muu-teksti" name="ohjelmointikokemus-muu-teksti" type="text" class="form-control input-md hidden">
                        </div>
                    </div>
                </div>

                <div class="hidden" id="ohjelmointikokemus-tarkennus">

                    <div class="form-group">
                        <label class="col-md-4 control-label" for="ohjelmointikokemus-kaytetyt-ohjelmointikielet">Mitä ohjelmointikieliä olet käyttänyt?</label>  
                        <div class="col-md-4">
                            <input id="ohjelmointikokemus-kaytetyt-ohjelmointikielet" name="ohjelmointikokemus-kaytetyt-ohjelmointikielet" type="text" class="form-control input-md">
                        </div>
                    </div>

                    <div class="form-group">
                        <label class="col-md-4 control-label" for="ohjelmointikokemus-tuntia-ohjelmoinut">Kuinka monta tuntia olet ohjelmoinut (arviolta)?</label>  
                        <div class="col-md-4">
                            <input id="ohjelmointikokemus-tuntia-ohjelmoinut" name="ohjelmointikokemus-tuntia-ohjelmoinut" type="text" class="form-control input-md">
                        </div>
                    </div>

                    <div class="form-group">
                        <label class="col-md-4 control-label" for="ohjelmointikokemus-suurin-rivimaara">Kuinka monta riviä ohjelmakoodia suurimmassa kirjoittamassasi ohjelmassa on ollut (arviolta)?</label>  
                        <div class="col-md-4">
                            <input id="ohjelmointikokemus-suurin-rivimaara" name="ohjelmointikokemus-suurin-rivimaara" type="text" class="form-control input-md">
                        </div>
                    </div>
                </div>

                <!-- Osallistuminen -->
                <div class="form-group">
                    <label class="col-md-4 control-label" for="osallistuminen">Osallistun kurssille (valitse sopivat)</label>
                    <div class="form-inline col-md-8">
                        <div class="checkbox col-md-4">
                            <label for="osallistuminen-tutustuakseni-ohjelmointiin">
                                <input type="checkbox" name="osallistuminen" id="osallistuminen-tutustuakseni-ohjelmointiin" value="osallistuminen-tutustuakseni-ohjelmointiin">
                                Tutustuakseni ohjelmointiin
                            </label>
                        </div>

                        <div class="checkbox col-md-4">
                            <label for="osallistuminen-tutustuakseni-kurssin-toteutukseen">
                                <input type="checkbox" name="osallistuminen" id="osallistuminen-tutustuakseni-kurssin-toteutukseen" value="osallistuminen-tutustuakseni-kurssin-toteutukseen">
                                Tutustuakseni kurssin toteutustapaan
                            </label>
                        </div>

                        <div class="checkbox col-md-4">
                            <label for="osallistuminen-saadakseni-opintopisteita-tai-kurssisuorituksen">
                                <input type="checkbox" name="osallistuminen" id="osallistuminen-saadakseni-opintopisteita-tai-kurssisuorituksen" value="osallistuminen-saadakseni-opintopisteita-tai-kurssisuorituksen">
                                Saadakseni opintopisteitä tai kurssisuorituksen
                            </label>
                        </div>

                        <div class="checkbox col-md-4">
                            <label for="osallistuminen-oppiakseni-ohjelmointia-huvin-vuoksi">
                                <input type="checkbox" name="osallistuminen" id="osallistuminen-oppiakseni-ohjelmointia-huvin-vuoksi" value="osallistuminen-oppiakseni-ohjelmointia-huvin-vuoksi">
                                Oppiakseni ohjelmointia, huvin vuoksi
                            </label>
                        </div>


                        <div class="checkbox col-md-4">
                            <label for="osallistuminen-oppiakseni-ohjelmointia-opintoja-varten">
                                <input type="checkbox" name="osallistuminen" id="osallistuminen-oppiakseni-ohjelmointia-opintoja-varten" value="osallistuminen-oppiakseni-ohjelmointia-opintoja-varten">
                                Oppiakseni ohjelmointia, opintoja varten
                            </label>
                        </div>

                        <div class="checkbox col-md-4">
                            <label for="osallistuminen-oppiakseni-ohjelmointia-toita-varten">
                                <input type="checkbox" name="osallistuminen" id="osallistuminen-oppiakseni-ohjelmointia-toita-varten" value="osallistuminen-oppiakseni-ohjelmointia-toita-varten">
                                Oppiakseni ohjelmointia, töitä varten
                            </label>
                        </div>

                        <div class="checkbox col-md-4">
                            <label for="osallistuminen-paivittaakseni-ohjelmointitaitojani">
                                <input type="checkbox" name="osallistuminen" id="osallistuminen-paivittaakseni-ohjelmointitaitojani" value="osallistuminen-paivittaakseni-ohjelmointitaitojani">
                                Päivittääkseni ohjelmointitaitojani
                            </label>
                        </div>

                        <div class="checkbox col-md-4">
                            <label for="osallistuminen-koska-ilmainen">
                                <input type="checkbox" name="osallistuminen" id="osallistuminen-koska-ilmainen" value="osallistuminen-koska-ilmainen">
                                Koska se on ilmainen
                            </label>
                        </div>

                        <div class="checkbox col-md-4">
                            <label for="osallistuminen-koska-kurssia-suositeltiin-minulle">
                                <input type="checkbox" name="osallistuminen" id="osallistuminen-koska-kurssia-suositeltiin-minulle" value="osallistuminen-koska-kurssia-suositeltiin-minulle">
                                Koska sitä suositeltiin minulle
                            </label>
                        </div>


                        <div class="checkbox col-md-8">
                            <label for="osallistuminen-muu">
                                <input type="checkbox" name="osallistuminen" id="osallistuminen-muu" value="osallistuminen-muu">
                                Muu, mikä?
                            </label>
                            <input id="osallistuminen-muu-teksti" name="osallistuminen-muu-teksti" type="text" class="form-control input-md hidden">
                        </div>
                    </div>
                </div>

                <div class="form-group">
                    <label class="col-md-4 control-label" for="suoritus">Aion läpäistä tämän kurssin kunnialla</label>
                    <div class="form-inline col-md-8">
                        <div class="checkbox col-md-4">
                            <label for="aion-lapaista-kurssin-kunnialla">
                                <input type="checkbox" name="suoritus" id="aion-lapaista-kurssin-kunnialla" value="aion-lapaista-kurssin-kunnialla">
                                Kyllä!
                            </label>
                        </div>
                    </div>
                </div>

                <div class="form-group">
                    <label class="col-md-4 control-label" for="ohpe">Suoritin juuri kurssin ohjelmoinnin perusteet</label>
                    <div class="form-inline col-md-8">
                        <div class="checkbox col-md-4">
                            <label for="just-ohpe">
                                <input type="checkbox" name="ohpe" id="just-ohpe" value="aion-lapaista-kurssin-kunnialla">
                                Kyllä!
                            </label>
                        </div>
                    </div>
                </div>


                <input type="hidden" id="taustatiedot-form-ohja-started-entering" name="taustatiedot-form-ohja-started-entering" value="">

                <div class="form-group">
                    <label class="col-md-4 control-label">&nbsp;</label>
                    <div class="form-inline col-md-8">
                        <strong><label id="taustatiedot-form-ohja-validation-feedback" class="label label-danger hidden">Tarkistathan että vastasit kaikkiin kenttiin!</label></strong>
                    </div>
                </div>

                <div class="form-group">
                    <label class="col-md-4 control-label">&nbsp;</label>
                    <div class="form-inline col-md-8">
                        <button type="button" id="taustatiedot-form-ohja-submit" class="btn btn-primary">Lähetä lomake</button>
                    </div>
                </div>

            </fieldset>
        </form>
      </div>
    </div>
  </div>
</div>

<!-- msql-motivaatio-form -->
<div class="panel-group" id="2mslqmotivaatio">
  <div class="panel panel-default">
    <a class="panel-title" data-toggle="collapse" data-parent="#2mslqmotivaatio" href="#2mslqmotivaatio2">
      <div class="panel-heading">
	<h4 id="msql-motivaatio-form-legend">Kysely: Oppimiskokemukset ja motivaatio</h4>
    </div>
    </a>
    <div class="panel-collapse collapse" id="2mslqmotivaatio2">
      <div class="panel-body">

        <!-- Taustatiedot -->
	<form class="form-horizontal" id="msql-motivaatio-form">
            <fieldset>
                <legend id="msql-motivaatio-form-legend">Tutkimus: Oppimiskokemukset ja motivaatio</legend>
                <p class="help-block">Käytämme tietoja kurssiemme kehittämiseen ja opetuksen tutkimukseen.</p>

                <!-- TMC-tunnus-->
                <div class="form-group">
                    <label class="col-md-4 control-label" for="msql-motivaatio-form-tmc-tunnus">TMC-tunnus</label>  
                    <div class="col-md-4">
                        <input id="msql-motivaatio-form-tmc-tunnus" name="msql-motivaatio-form-tmc-tunnus" type="text" class="form-control input-md">
                    </div>
                </div>

                <p class="help-block">Seuraavilla kysymyksillä kartoitetaan opiskelukokemuksiasi ja motivaatiotasi tällä kurssilla. Tässä kyselyssä ei ole oikeita tai vääriä vastauksia, vastaa niin tarkasti kuin pystyt. Käytä seuraavaa skaalaa vastausten antamiseen. Jos olet sitä mieltä, että väite pätee sinuun erittäin hyvin, valitse 7; jos olet sitä mieltä, että väite ei päde sinuun lainkaan, valitse 1. Jos väite on enemmän tai vähemmän totta kohdallasi, valitse sinua parhaiten kuvaava arvo lukujen 1 ja 7 väliltä.</p>

		<p>&nbsp;</p>

                <div class="row" id="msql-motivaatio-skaala">
                    <div class="col-md-3">Väite ei päde minuun lainkaan.</div>
                    <div class="col-md-1">1</div>
                    <div class="col-md-1">2</div>
                    <div class="col-md-1">3</div>
                    <div class="col-md-1">4</div>
                    <div class="col-md-1">5</div>
                    <div class="col-md-1">6</div>
                    <div class="col-md-1">7</div>
                    <div class="col-md-2">Väite pätee minuun erittäin hyvin.</div>
                </div>
		<p>&nbsp;</p>

                <div id="msql-motivaatio">


                </div>

                <input type="hidden" id="msql-motivaatio-form-started-entering" name="msql-motivaatio-form-started-entering" value="">

                <div class="form-group">
                    <label class="col-md-4 control-label">&nbsp;</label>
                    <div class="form-inline col-md-8">
                        <strong><label id="msql-motivaatio-form-validation-feedback" class="label label-danger hidden">Tarkistathan että vastasit kaikkiin kenttiin!</label></strong>
                    </div>
                </div>

                <div class="form-group">
                    <label class="col-md-4 control-label">&nbsp;</label>
                    <div class="form-inline col-md-8">
                        <button type="button" id="msql-motivaatio-form-submit" class="btn btn-primary">Lähetä lomake</button>
                    </div>
                </div>

            </fieldset>
        </form>
      </div>
    </div>
  </div>
</div>


    <h2>Ohjelmoinnin perusteiden kertausta</h2>
    
    <p>Tässä luvussa kerrataan pikaisesti muutamia aiempina viikkoina tutuksi tulleita asioita. Ruostunutta ohjelmointitaitoa voi verestää myös <a href="http://www.cs.helsinki.fi/group/java/s12/ohpe/materiaali-ohpekertaus.html">täältä</a> löytyvän tehtäväsarjan avulla.</p>

    <h3>Ohjelma, käskyt ja muuttujat</h3>

    <p>Tietokoneohjelma koostuu joukosta käskyjä, joita tietokone suorittaa yksi kerrallaan, ylhäältä alaspäin. Käskyillä on aina määrätty rakenne ja semantiikka. Javassa, eli kurssilla käyttämässämme ohjelmointikielessä, käskyjä luetaan ylhäältä alas vasemmalta oikealle. Ohjelmointikurssit aloitetaan usein esittelemällä ohjelma, joka tulostaa merkkijonon <code>Hei maailma!</code>. Alla on Java-kielellä kirjoitettu käsky <code>Hei maailma!</code> -merkkijonon tulostamiseksi.</p>

    <pre class="sh_java">
        System.out.println("Hei maailma!");
    </pre>

    <p>Käskyssä kutsutaan <code>System</code>-luokkaan liittyvän muuttujan <code>println</code>-metodia, joka tulostaa ensin parametrina annetun merkkijonon ja sen jälkeen rivinvaihdon. Metodille annetaan parametrina merkkijono <code>Hei maailma!</code>, jolloin tulostus on <code>Hei maailma!</code> jota seuraa rivinvaihto.</p>

    <p>Ohjelmaan voi liittyä muuttujia joita voi käyttää osana ohjelman toimintaa. Alla on ohjelma, joka ensin esittelee kokonaislukutyyppisen muuttujan <code>pituus</code> johon asetetaan seuraavalla rivillä arvo 179. Tämän jälkeen tulostetaan muuttujan <code>pituus</code> arvo eli <code>179</code>.</p>

    <pre class="sh_java">
        int pituus;
        pituus = 179;
        System.out.println(pituus);
    </pre>

    <p>Yllä ohjelman suoritus tapahtuisi rivi kerrallaan. Ensin suoritetaan rivi <code>int pituus;</code>, jossa esitellään muuttuja nimeltä <code>pituus</code>. Seuraavaksi suoritetaan rivi <code>pituus = 179;</code>, jossa asetetaan edellisellä rivillä esiteltyyn muuttujaan arvo <code>179</code>. Tämän jälkeen suoritetaan rivi <code>System.out.println(pituus);</code>, jossa kutsutaan aiemmin näkemäämme tulostusmetodia, jolle annetaan parametrina muuttuja pituus. Metodi tulostaa muuttujan <code>pituus</code> sisällön eli arvon <code>179</code>.</p>

    <p>Yllä olevassa ohjelmassa ei oikeastaan ole tarvetta esitellä muuttujaa <code>pituus</code> ja asettaa siihen arvoa erillisillä riveillä. Muuttujan esittelyn ja siihen liittyvän arvon asetuksen voi tehdä myös samalla rivillä.</p>

    <pre class="sh_java">
        int pituus = 179;
    </pre>

    <p>Yllä olevaa riviä suoritettaessa esitellään ensin muuttuja <code>pituus</code>, johon asetetaan esittelyn yhteydessä arvo <code>179</code>.</p>

    <p>Kaikki tieto esiintyy oikeasti tietokoneen sisällä jonona bittejä, eli lukuja nolla ja yksi. Muuttujat ovat ohjelmointikielten tarjoama abstraktio, jolla voidaan käsitellä erilaisia arvoja helpommin. Muuttujia käytetään arvojen säilyttämiseen ja ohjelman tilan ylläpitoon. Javassa käytössämme on muun muassa alkeisarvoiset muuttujatyypit <code>int</code> (kokonaisluku), <code>double</code> (liukuluku), <code>boolean</code> (totuusarvo), <code>char</code> (merkki) sekä viitetyyppiset muuttujatyypit  <code>String</code> (merkkijono), <code>ArrayList</code> (taulukko) ja kaikki luokat. Palaamme alkeistyyppisiin ja viitetyyppisiin muuttujiin ja niiden eroihin tarkemmin myöhemmin.</p>


    <h3>Muuttujien vertaileminen ja syötteen lukeminen</h3>

    <p>Ohjelmien toiminnallisuus rakennetaan kontrollirakenteiden avulla. Kontrollirakenteet mahdollistavat erilaiset toiminnot ohjelman muuttujien arvoista riippuen. Alla esimerkki <code>if-else if-else</code> -kontrollirakenteesta, jossa tehdään erilainen toiminto vertailun tuloksesta riippuen. Esimerkissä tulostetaan merkkijono <code>Kaasua</code> jos muuttujan <code>nopeus</code> arvo on pienempi kuin 110, merkkijono <code>Jarrua</code> jos muuttujan <code>nopeus</code> arvo on suurempi kuin 120 ja merkkijono <code>Kruisaillaan</code> muissa tapauksissa.</p>

    <pre class="sh_java">
        int nopeus = 105;

        if(nopeus &lt; 110) {
            System.out.println("Kaasua");
        } else if (nopeus &gt; 120) {
            System.out.println("Jarrua");
        } else {
            System.out.println("Kruisaillaan");
        }
    </pre>

    <p>Koska yllä olevassa esimerkissä muuttujan <code>nopeus</code> arvo on 105, tulostaa ohjelma aina merkkijonon <code>Kaasua</code>. Muistathan että merkkijonojen yhtäsuuruusvertailu tapahtuu merkkijonoon liittyvällä <code>equals</code>-metodilla. Alla on esimerkki jossa käytetään Javan <a href="http://docs.oracle.com/javase/6/docs/api/java/util/Scanner.html" target="_blank">Scanner</a>-luokasta luotua olioita käyttäjän kirjoittaman syötteen lukemiseen. Ohjelma tarkistaa ovatko käyttäjän syöttämät merkkijonot samat.</p>

    <pre class="sh_java">
        Scanner lukija = new Scanner(System.in);

        System.out.print("Syötä ensimmäinen merkkijono: ");
        String ensimmainen = lukija.nextLine();

        System.out.print("Syötä toinen merkkijono: ");
        String toinen = lukija.nextLine();

        System.out.println();

        if (ensimmainen.equals(toinen)) {
            System.out.println("Kirjoittamasi merkkijonot ovat samat!");
        } else {
            System.out.println("Kirjoittamasi merkkijonot eivät olleet samat!");
        }
    </pre>

    <p>Ohjelman toiminta riippuu käyttäjän syötteestä. Alla esimerkki, punaisella värillä tarkoitetaan käyttäjän kirjoittamaa syötettä.</p>

    <pre>
Syötä ensimmäinen merkkijono: <font color="red">porkkana</font>
Syötä toinen merkkijono: <font color="red">salaatti</font>

Kirjoittamasi merkkijonot eivät olleet samat!
    </pre>

    <h3>Toistolausekkeet</h3>

    <p>Ohjelmissa tarvitaan usein toistoa. Tehdään ensin ns. while-true-break -toistolause, jota jatketaan niin pitkään kunnes käyttäjä syöttää merkkijonon <code>salasana</code>. Lause <code>while(true)</code> aloittaa toistolauseen, jota jatketaan kunnes kohdataan avainsana <code>break</code>.</p>

    <pre class="sh_java">
        Scanner lukija = new Scanner(System.in);

        while(true) {
            System.out.print("Syötä salasana: ");
            String salasana = lukija.nextLine();

            if(salasana.equals("salasana")) {
                break;
            }
        }

        System.out.println("Kiitos!");
    </pre>


    <pre>
Syötä salasana: <font color="red">porkkana</font>
Syötä salasana: <font color="red">salasana</font>
Kiitos
    </pre>


    <p>While-toistolausekkeeseen voi asettaa totuusarvon <code>true</code> sijaan myös vertailun. Alla tulostetaan käyttäjän syöttämä merkkijono siten, että sillä on ylä- ja alapuolella tähtiä.</p>

    <pre class="sh_java">
        Scanner lukija = new Scanner(System.in);

        System.out.print("Syötä merkkijono: ");
        String merkkijono = lukija.nextLine();

        int tahdenNumero = 0;
        while(tahdenNumero &lt; merkkijono.length()) {
            System.out.print("*");
            tahdenNumero = tahdenNumero + 1;
        }
        System.out.println();

        System.out.println(merkkijono);

        tahdenNumero = 0;
        while(tahdenNumero &lt; merkkijono.length()) {
            System.out.print("*");
            tahdenNumero = tahdenNumero + 1;
        }
        System.out.println();
    </pre>


    <pre>
Syötä merkkijono: <font color="red">porkkana</font>
********
porkkana
********
    </pre>

    <p>Yllä olevan esimerkin pitäisi nostattaa kylmiä väreitä selkäpiissäsi. Kylmät väreet toivottavasti johtuvat siitä, että huomaat esimerkin rikkovan ohjelmoinnin perusteissa opittuja käytänteitä. Esimerkissä on turhaa toistoa joka tulee poistaa metodien avulla.</p>

    <p>While-toistolauseen lisäksi käytössämme on myös for-toistolauseen kaksi versiota. Uudempaa for-lauseketta käytetään listojen läpikäyntiin.</p>

    <pre class="sh_java">
        ArrayList&lt;String&gt; tervehdykset = new ArrayList&lt;String&gt;();
        tervehdykset.add("Hei");
        tervehdykset.add("Hallo");
        tervehdykset.add("Hi");

        for(String tervehdys: tervehdykset) {
            System.out.println(tervehdys);
        }
    </pre>

    <pre>
Hei
Hallo
Hi
    </pre>

    <p>Perinteisempää for-lausetta käytetään samankaltaisissa tilanteissa kuin <code>while</code>-toistolausetta. Sitä voidaan käyttää esimerkiksi taulukoiden läpikäyntiin. Seuraavassa esimerkissä kerrotaan jokaisen taulukon <code>luvut</code> alkion sisältö kahdella ja lopuksi tulostetaan luvut uudempaa for-lausetta käyttäen.</p>

    <pre class="sh_java">
        int[] luvut = new int[] {1, 2, 3, 4, 5, 6};

        for (int i = 0; i &lt; luvut.length; i++) {
            luvut[i] = luvut[i] * 2;
        }

        for (int luku : luvut) {
            System.out.println(luku);
        }
    </pre>

    <pre>
2
4
6
8
10
12
    </pre>

    <p>Perinteinen for-lauseke on erittäin hyödyllinen tapauksissa joissa käymme indeksejä yksitellen läpi. Alla oleva toistolauseke käy merkkijonon merkit yksitellen läpi, ja tulostaa merkkijono <code>Hip!</code> aina kun törmäämme merkkiin <code>a</code>.</p>

    <pre class="sh_java">
        String merkkijono = "saippuakauppias";
        for (int i = 0; i &lt; merkkijono.length(); i++) {
            if (merkkijono.charAt(i) == 'a') {
                System.out.println("Hip!");
            }
        }
    </pre>

    <pre>
Hip!
Hip!
Hip!
Hip!
    </pre>

    <h3>Metodit</h3>

    <p>Metodit ovat tapa pilkkoa ohjelman toiminnallisuutta pienempiin osakokonaisuuksiin. Kaikkien Java-ohjelmien suoritus alkaa pääohjelmametodista, joka määritellään lauseella <code>public static void main(String[] args)</code>. Lause määrittelee staattisen, eli luokkaan liittyvän metodin, joka saa parametrina merkkijonotaulukon. </p>

    <p>Ohjelmoija määrittelee metodeja ohjelman sisältävien toiminnallisuuksien abstrahoimiseksi. Ohjelmoidessa tulee tavoitella tilannetta, jossa ohjelmaa voidaan katsoa <em>korkeammalta tasolta</em>, jolloin pääohjelma koostuu joukosta itse määriteltyjen, hyvin nimettyjen metodien kutsuja. Metodit taas tarkentavat ohjelman toiminnallisuutta ja ehkä toteuttavat oman toiminnallisuutensa kutsumalla joitain muita metodeja.</p>

    <p>Metodit joiden määrittelyssä on sana <code>static</code>, liittyvät metodin sisältävään <em>luokkaan</em> ja toimivat ns. apumetodeina. Metodit joiden määrittelyssä ei ole sanaa <code>static</code> liittyvät luokasta tehtyihin ilmentymiin, eli <em>olioihin</em>, ja voivat muokata yksittäisten olioiden sisäistä tilaa.</p>

    <p>Metodilla on aina näkyvyysmääre (public, näkyy kaikille, private, näkyy vain luokan sisällä), paluutyyppi (void, ei palauta arvoa) sekä metodin nimi. Seuraavassa luodaan luokkaan liittyvä metodi <code>public static void tulosta(String merkkijono, int kertaa)</code>, joka tulostaa merkkijonon halutun määrän kertoja. Käytetään tällä kertaa metodia <code>System.out.print</code>, joka toimii muuten samoin kuin <code>System.out.println</code>, mutta ei tulosta rivinvaihtoa.</p>

    <pre class="sh_java">
    public static void tulosta(String merkkijono, int kertaa) {
        for (int i = 0; i &lt; kertaa; i++) {
            System.out.print(merkkijono);
        }
    }
    </pre>

    <p>Yllä oleva metodi tulostaa parametrina annetun merkkijonon niin monta kertaa kuin parametrina annettu kokonaisluku kertoo.</p>

    <p>Toistolausekkeisiin liittyvässä luvussa huomasimme että koodi sisälsi tähtien tulostamisen osalta ikävästi "copypastea". Metodien avulla voimme siirtää tähtien tulostamisen erillisen metodiin. Luodaan metodi <code>public static void tulostaTahtia(int kertaa)</code>, joka tulostaa parametrina annetun määrän tähtiä. Metodi käyttää <code>for</code>-toistolausetta <code>while</code>:n sijaan.</p>

    <pre class="sh_java">
    public static void tulostaTahtia(int kertaa) {
        for(int i = 0; i &lt; kertaa; i++) {
            System.out.print("*");
        }
        System.out.println();
    }
    </pre>

    <p>Metodia hyödyntäessä aiemmin kauhistusta aihettanut esimerkkimme näyttää seuraavalta.</p>

    <pre class="sh_java">
        Scanner lukija = new Scanner(System.in);

        System.out.print("Syötä merkkijono: ");
        String merkkijono = lukija.nextLine();

        tulostaTahtia(merkkijono.length());
        System.out.println(merkkijono);
        tulostaTahtia(merkkijono.length());
    </pre>


    <h3>Luokka</h3>

    <p>Metodit toimivat ohjelman abstrahoimisessa tiettyyn pisteeseen asti, mutta ohjelmien kasvaessa suuremmiksi, ohjelmia halutaan pilkkoa vielä pienempiin ja loogisempiin kokonaisuuksiin. Luokkien avulla voimme määritellä ohjelmaan korkeamman tason käsitteitä ja käsitteisiin liittyviä toiminnallisuuksia. Jokainen Java-ohjelma vaatii toimiakseen luokan, eli yllä rakennettu <code>Hei maailma!</code> -esimerkki ei toimisi ilman luokkamäärittelyä. Luokka määritellään avainsanoilla <code>public class LuokanNimi</code>.</p>

    <pre class="sh_java">
public class HeiMaailma {
    public static void main(String[] args) {
        System.out.println("Hei maailma!");
    }
}
    </pre>

    <p>Luokkia siis käytetään ohjelmassa esiintyvien käsitteiden ja niihin liittyvien toiminnallisuuksien määrittelyyn. Luokista voidaan luoda olioita, jotka ovat luokan ilmentymiä. Jokaisella tiettyyn luokkaan liittyvällä oliolla on sama rakenne, mutta oliohin liittyvien muuttujien arvot voivat olla erilaiset. Olioiden metodit käsittelevät olioiden tilaa, eli sisäisiä muuttujia.</p>

    <p>Tutkitaan alla olevaa luokkaa <code>Kirja</code>, jolla on oliomuuttujat nimi (merkkijono) ja julkaisuvuosi (kokonaisluku).</p>

    <pre class="sh_java">
public class Kirja {
    private String nimi;
    private int julkaisuvuosi;

    public Kirja(String nimi, int julkaisuvuosi) {
        this.nimi = nimi;
        this.julkaisuvuosi = julkaisuvuosi;
    }

    public String getNimi() {
        return this.nimi;
    }

    public int getJulkaisuvuosi() {
        return this.julkaisuvuosi;
    }
}
    </pre>

    <p>Alussa oleva määritelmä <code>public class Kirja</code> kertoo luokan nimen. Tätä seuraa oliomuuttujien määrittely. Oliomuuttujat ovat muuttujia, joista jokaisella luokan oliolla on oma toisista riippumaton kopionsa. On yleensä tarkoituksenmukaista piilottaa oliomuuttujat luokan käyttäjiltä, eli määritellä niille näkyvyysmääre <em>private</em>. Jos näkyvyysmääreeksi asetetaan <em>public</em> pääsee olion käyttäjä suoraan käsiksi oliomuuttujiin.</p>

    <p>Luokasta luodaan olioita <em>konstruktorilla</em>. Konstruktori on metodi, joka alustaa olion (eli luo oliolle siihen liittyvät muuttujat) ja suorittaa konstruktorin sisällä olevat käskyt. Konstruktori on aina samanniminen kuin konstruktorin sisältävä luokka. Konstruktorissa <code>public Kirja(String nimi, int julkaisuvuosi)</code> luodaan uusi olio luokasta <code>Kirja</code> ja asetetaan siihen liittyviin muuttujiin parametrina annetut arvot.</p>

    <p>Ylläolevalle luokalle on määritelty myös kaksi olioiden tietoja käsittelevää metodia. Metodi <code>public String getNimi()</code> palauttaa käsiteltävän olion nimen. Metodi <code>public int getJulkaisuvuosi()</code> palauttaa käsiteltävän olion julkaisuvuoden.</p>

    <h3>Olio</h3>

    <p>Olioita luodaan luokkaan määritellyn konstruktorin avulla. Ohjelmakoodissa konstruktoria kutsutaan <code>new</code>-käskyllä, joka palauttaa viitteen uuteen olioon. Oliot ovat luokista tehtyjä ilmentymiä. Tutkitaan ohjelmaa, joka luo kaksi eri kirjaa, jonka jälkeen tulostetaan olioihin liittyvien metodien <code>getNimi</code> palauttamat arvot.</p>

    <pre class="sh_java">
        Kirja jarkiJaTunteet = new Kirja("Järki ja tunteet", 1811);
        Kirja ylpeysJaEnnakkoluulo = new Kirja("Ylpeys ja ennakkoluulo", 1813);

        System.out.println(jarkiJaTunteet.getNimi());
        System.out.println(ylpeysJaEnnakkoluulo.getNimi());
    </pre>

    <pre>
Järki ja tunteet
Ylpeys ja ennakkoluulo
    </pre>

    <p>Jokaisella oliolla on siis oma sisäinen tila. Tila muodostuu olioon liittyvistä oliomuuttujista. Oliomuuttujat voivat olla sekä alkeistyyppisiä muuttujia että viitetyyppisiä muuttujia. Jos olioon liittyy viitetyyppisiä muuttujia, voi olla että muutkin oliot viittaavat samoihin olioihin! Visualisoidaan tämä pankkiesimerkillä, jossa on tilejä ja henkilöitä.</p>

    <pre class="sh_java">
public class Tili {
    private String tilitunnus;
    private int saldoSentteina;

    public Tili(String tilitunnus) {
        this.tilitunnus = tilitunnus;
        this.saldoSentteina = 0;
    }

    public void pane(int summa) {
        this.saldoSentteina += summa;
    }

    public int getSaldoSentteina() {
        return this.saldoSentteina;
    }

    // .. muita tiliin liittyviä metodeja
}
    </pre>

    <pre class="sh_java">
import java.util.ArrayList;

public class Henkilo {
    private String nimi;
    private ArrayList&lt;Tili&gt; tilit;

    public Henkilo(String nimi) {
        this.nimi = nimi;
        this.tilit = new ArrayList&lt;Tili&gt;();
    }

    public void lisaaTili(Tili tili) {
        this.tilit.add(tili);
    }

    public int rahaaYhteensa() {
        int yhteensa = 0;
        for (Tili tili: this.tilit) {
            yhteensa += tili.getSaldoSentteina();
        }

        return yhteensa;
    }

    // ... muita henkilöön liittyviä metodeja
}
    </pre>

    <p>Jokaisella <code>Henkilo</code>-luokasta tehdyllä oliolla on oma nimi sekä oma lista tileistä. Luodaan seuraavaksi kaksi henkilöä ja kaksi tiliä. Toinen tileistä on vain yhden henkilön oma, toinen yhteinen.</p>

    <pre class="sh_java">
        Henkilo matti = new Henkilo("Matti");
        Henkilo maija = new Henkilo("Maija");

        Tili palkkatili = new Tili("NORD-LOL");
        Tili kotitaloustili = new Tili("SAM-LOL");

        matti.lisaaTili(palkkatili);
        matti.lisaaTili(kotitaloustili);
        maija.lisaaTili(kotitaloustili);

        System.out.println("Matin tileillä rahaa: " + matti.rahaaYhteensa());
        System.out.println("Maijan tileillä rahaa: " + maija.rahaaYhteensa());
        System.out.println();

        palkkatili.pane(150000);

        System.out.println("Matin tileillä rahaa: " + matti.rahaaYhteensa());
        System.out.println("Maijan tileillä rahaa: " + maija.rahaaYhteensa());
        System.out.println();

        kotitaloustili.pane(10000);

        System.out.println("Matin tileillä rahaa: " + matti.rahaaYhteensa());
        System.out.println("Maijan tileillä rahaa: " + maija.rahaaYhteensa());
        System.out.println();
    </pre>

    <pre>
Matin tileillä rahaa: 0
Maijan tileillä rahaa: 0

Matin tileillä rahaa: 150000
Maijan tileillä rahaa: 0

Matin tileillä rahaa: 160000
Maijan tileillä rahaa: 10000
    </pre>

    <p>Ensin kummankin henkilön tilit ovat tyhjiä. Kun palkkatilille, johon oliolla <code>matti</code> on viite, lisätään rahaa, kasvaa Matin tileillä oleva rahamäärä. Kun kotitaloustilille lisätään rahaa, <em>kasvaa kummankin henkilön rahamäärä</em>. Tämä johtuu siitä että sekä Matilla että Maijalla on "oikeus" kotitaloustilille, eli kummakin omassa oliomuuttujassa <code>tilit</code> on viite kotitaloustiliin. Palaamme alkeis- ja viitetyyppisten muuttujien eroon tarkemmin myöhemmin.</p>


    <h3>Ohjelmien rakenteesta</h3>

    <p>Ohjelmista tulee olla selkeitä niin ohjelmoijalle kuin muille ohjelmaa tarkasteleville. Selkeys saadaan aikaan sopivalla luokkarakenteella ja hyvien nimeämiskäytänteiden seuraamisella. Jokaisella luokalla tulee olla selkeä vastuu, johon liittyviä tehtäviä luokka hoitaa. Metodeja käytetään toiston vähentämiseen ja luokkien sisäisten toimintojen jäsentämiseen. Myös metodilla tulee olla selkeä vastuu eli metodien ei tule olla liian pitkiä ja liian montaa asiaa tekeviä. Liian montaa asiaa tekevät monimutkaiset metodit tuleekin pilkkoa useiksi pienemmiksi apumetodeiksi joita alkuperäinen metodi kutsuu. Hyvät ohjelmoijat ohjelmoivat koodia, jota he ja heidän työkaverinsa ymmärtävät myös viikkoja koodin kirjoittamisen jälkeenkin.</p>

    <p>Ymmärrettävään koodiin liittyy niin kuvaava muuttujien, metodien ja luokkien nimeäminen kuin ohjelmakoodin ilmavuus ja johdonmukainen sisentäminen. Tutkitaan seuraavaa esimerkkiä käyttöliittymästä, jossa käyttäjä voi ostaa ja myydä esineitä. Vaikka esimerkissä ainoat ostettavat ja myytävät asiat ovat porkkanoita, eikä niistä pidetä kirjaa, voisi käyttöliittymää laajentaa esimerkiksi siten että sille annettaisiin myytävien tavaroiden varasto konstruktorin parametrina.</p>

    <pre class="sh_java">
public class Kayttoliittyma {
    private Scanner lukija;

    public Kayttoliittyma(Scanner lukija) {
        this.lukija = lukija;
    }

    public void kaynnista() {
        while (true) {
            String komento = lukija.nextLine();

            if (komento.equals("lopeta")) {
                break;
            } else if (komento.equals("osta")) {
                String luettu = null;
                while(true) {
                    System.out.print("Mitä ostetaan: ");
                    luettu = lukija.nextLine();
                    if(luettu.equals("porkkana") {
                        break;
                    } else {
                        System.out.println("Ei löydy!");
                    }
                }

                System.out.println("Ostettu!");
            } else if (komento.equals("myy")) {
                String luettu = null;
                while(true) {
                    System.out.print("Mitä myydään: ");
                    luettu = lukija.nextLine();
                    if(luettu.equals("porkkana") {
                        break;
                    } else {
                        System.out.println("Ei löydy!");
                    }
                }

                System.out.println("Myyty!");
            }
        }
    }
}
    </pre>

    <p>Huomaamme esimerkissä heti monta ongelmakohtaa. Ensimmäinen pulma liittyy <code>kaynnista</code>-metodin sisällön suuruuteen. Huomaamme että metodia voi pienentää siirtämällä muiden komentojen kuin <code>lopeta</code>-komennon käsittelyn erilliseen metodiin.</p>

    <pre class="sh_java">
public class Kayttoliittyma {
    private Scanner lukija;

    public Kayttoliittyma(Scanner lukija) {
        this.lukija = lukija;
    }

    public void kaynnista() {
        while (true) {
            String komento = lukija.nextLine();

            if (komento.equals("lopeta")) {
                break;
            } else {
                hoidaKomento(komento);
            }
        }
    }

    public void hoidaKomento(String komento) {
        if (komento.equals("osta")) {
            String luettu = null;
            while(true) {
                System.out.print("Mitä ostetaan: ");
                luettu = lukija.nextLine();
                if(luettu.equals("porkkana") {
                    break;
                } else {
                    System.out.println("Ei löydy!");
                }
            }

            System.out.println("Ostettu!");
        } else if (komento.equals("myy")) {
            String luettu = null;
            while(true) {
                System.out.print("Mitä myydään: ");
                luettu = lukija.nextLine();
                if(luettu.equals("porkkana") {
                    break;
                } else {
                    System.out.println("Ei löydy!");
                }
            }

            System.out.println("Myyty!");
        }
    }
}
    </pre>

    <p>Metodissa <code>hoidaKomento</code> on vielä toisteisuutta syötteen lukemiseen liittyen. Huomaamme että lukemisessa toistuu aina muutama merkkijono. Kun ostetaan kysytään "Mitä ostetaan: ", kun myydään kysytään "Mitä myydään: ". Molemmat lukemiskohdat odottavat merkkijonoa "porkkana" ja tulostavat "Ei löydy!" jos käyttäjä ei syötä merkkijonoa "Porkkana". Luodaan tätä varten erillinen metodi <code>public String lueKayttajalta(String kysymys)</code>, joka kysyy käyttäjältä haluttua merkkijonoa. Huomaa että jos käyttöliittymässämme olisi käytössä jonkinlainen varastonhallintaolio, vertaisimme sen sisältämiä esineitä käyttäjän syötteeseen porkkanan sijasta. </p>


    <pre class="sh_java">
public class Kayttoliittyma {
    private Scanner lukija;

    public Kayttoliittyma(Scanner lukija) {
        this.lukija = lukija;
    }

    public void kaynnista() {
        while (true) {
            String komento = lukija.nextLine();

            if (komento.equals("lopeta")) {
                break;
            } else {
                hoidaKomento(komento);
            }
        }
    }

    public void hoidaKomento(String komento) {
        if (komento.equals("osta")) {
            String luettu = lueKayttajalta("Mitä ostetaan: ");
            System.out.println("Ostettu!");
        } else if (komento.equals("myy")) {
            String luettu = lueKayttajalta("Mitä myydään: ");
            System.out.println("Myyty!");
        }
    }

    public String lueKayttajalta(String kysymys) {
        while(true) {
            System.out.print(kysymys);
            String luettu = lukija.nextLine();

            if(luettu.equals("porkkana") {
                return luettu;
            } else {
                System.out.println("Ei löydy!");
            }
        }
    }
}
    </pre>

    <p>Ohjelma on nyt pilkottu sopiviksi osiksi. Huomaamme kuitenkin että <code>kaynnista</code>-metodin yhteydessä on turha <code>else</code>-haara. Jos ohjelman suoritus päätyy <code>if</code>-haaraan, suoritetaan komento <code>break</code> ja poistutaan toistolauseesta. Voimme siis poistaa <code>else</code>-haaran jolloin <code>hoidaKomento</code>-metodin suorittaminen on omalla rivillään. Samanlainen tilanne on myös metodissa <code>lueKayttajalta</code>. Siistitään se myös samalla.</p>

    <pre class="sh_java">
public class Kayttoliittyma {
    private Scanner lukija;

    public Kayttoliittyma(Scanner lukija) {
        this.lukija = lukija;
    }

    public void kaynnista() {
        while (true) {
            String komento = lukija.nextLine();

            if (komento.equals("lopeta")) {
                break;
            }

            hoidaKomento(komento);
        }
    }

    public void hoidaKomento(String komento) {
        if (komento.equals("osta")) {
            String luettu = lueKayttajalta("Mitä ostetaan: ");
            System.out.println("Ostettu!");
        } else if (komento.equals("myy")) {
            String luettu = lueKayttajalta("Mitä myydään: ");
            System.out.println("Myyty!");
        }
    }

    public String lueKayttajalta(String kysymys) {
        while(true) {
            System.out.print(kysymys);
            String luettu = lukija.nextLine();

            if(luettu.equals("porkkana") {
                return luettu;
            }

            System.out.println("Ei löydy!");
        }
    }
}
    </pre>


    <p>Yllä kuvaavaamme ohjelman pilkkomista pienempiin osiin kutsutaan <em>refaktoroinniksi</em>. Refaktoroinnissa ohjelman toiminta pysyy samana, mutta sisäinen rakenne muuttuu selkeämmäksi ja ylläpidettävämmäksi. Nykyinen versiomme on huomattavasti selkeämpi alkuperäiseen ohjelmaan verrattuna. Ohjelmassa on toki vieläkin parannettavaa. Esimerkiksi metodin <code>hoidaKomento</code> voi pilkkoa ostamis- ja myymistoiminnallisuutta hoitaviin metodeihin.</p>

    <pre class="sh_java">
public class Kayttoliittyma {
    private Scanner lukija;

    public Kayttoliittyma(Scanner lukija) {
        this.lukija = lukija;
    }

    public void kaynnista() {
        while (true) {
            String komento = lukija.nextLine();

            if (komento.equals("lopeta")) {
                break;
            }

            hoidaKomento(komento);
        }
    }

    public void hoidaKomento(String komento) {
        if (komento.equals("osta")) {
            komentoOsta();
        } else if (komento.equals("myy")) {
            komentoMyy();
        }
    }

    public void komentoOsta() {
        String luettu = lueKayttajalta("Mitä ostetaan: ");
        System.out.println("Ostettu!");
    }

    public void komentoMyy() {
        String luettu = lueKayttajalta("Mitä myydään: ");
        System.out.println("Myyty!");
    }

    public String lueKayttajalta(String kysymys) {
        while(true) {
            System.out.print(kysymys);
            String luettu = lukija.nextLine();

            if(luettu.equals("porkkana") {
                return luettu;
            }

            System.out.println("Ei löydy!");
        }
    }
}
    </pre>

    <p> Nyt ohjelma on rakenteeltaan riittävän selkeä, metodit ovat kuvaavasti nimettyjä ja jokaisella metodilla on oma pieni tehtävä, josta metodi huolehtii. Huomaa että emme lisänneet refaktoroidessa ohjelmaan uutta toiminnallisuutta, muokkasimme vain rakennetta selkeämmäksi.</p>

    <h3>Ohjelmoinnista ja ennenkaikkea harjoittelun tärkeydestä</h3>

    <p>Tietääksemme kukaan ei ole oppinut ohjelmoimaan luentoja kuuntelemalla. Ohjelmointitaidon kehittymisen kannalta harjoittelu ja kertaaminen on tärkeää. Ohjelmointitaitoa on verrattu niin kielten puhumiseen kuin instrumentin soittamiseen, kummassakin kehittyy vain harjoittelemalla. Oikeastaan, esimerkiksi hyvät viulistit eivät ole hyviä <em>vain</em> sen takia, että he ovat harjoitelleet paljon. Harjoittelua motivoi myös se, että se on hauskaa. Samaa voi sanoa ohjelmoijista.</p>

    <p>Linus Torvaldsin sanoin <em>"Most good programmers do programming not because they expect to get paid or get adulation by the public, but because it is fun to program."</em>.</p>

    <p>Tohtori Luukkainen on kirjoittanut listan jota kannattaa seurata ohjelmoidessa ja siinä kehittyessä. Seuraa listan neuvoja kunnes osaat ne unissasikin.</p>

    <ul>
      <li> Etene pieni askel kerrallaan
      <ul>
        <li> Yritä pilkkoa ongelma osaongelmiin ja <strong>ratkaise vain yksi osaongelma kerrallaan</strong> </li>
        <li> Testaa aina että ohjelma on etenemässä oikeaan suuntaan eli että osaongelman ratkaisu meni oikein</li>
      </ul></li>
      <li> Kirjoita mahdollisimman "siistiä" koodia
      <ul>
        <li> sisennä koodi </li>
        <li> käytä kuvaavia muuttujien ja metodien nimiä</li>
        <li> älä tee liian pitkiä metodeja, edes mainia</li>
        <li> tee yhdessä metodissa vaan yksi asia</li>
        <li> <strong>poista koodistasi kaikki copy-paste</strong></li>
        <li> korvaa koodisi "huonot" ja epäsiistit osat siistillä koodilla</li>
      </ul></li>
    </ul>



    <h3>Näkyvyysmääreet</h3>

    <p>Olemme tähän mennessä käyttäneet kahta erilaista <em>näkyvyyteen</em> liittyvää avainsanaa metodien ja oliomuuttujien määrittelyssä. Avainsana <code>public</code> asettaa metodit ja muuttujat kaikille näkyviksi. Esimerkiksi luokan metodit ja konstruktorit merkitään usein määreellä public, jolloin niitä voi kutsua luokan ulkopuolelta.</p>

    <p>Avainsana <code>private</code> taas piilottaa metodit ja muuttujat luokan sisälle. Metodia, jolla on määre <code>private</code>, ei pysty kutsumaan luokan ulkopuolelta.</p>

    <pre class="sh_java">
public class Kirja {
    private String nimi;
    private String sisalto;

    public Kirja(String nimi, String sisalto) {
        this.nimi = nimi;
        this.sisalto = sisalto;
    }

    public String getNimi() {
        return this.nimi;
    }

    public String getSisalto() {
        return this.sisalto;
    }

    // ...
}
    </pre>

    <p>Yllä olevasta Kirja-luokasta luotujen olioiden tietoihin pääsee käsiksi vain kirjan julkisten metodien kautta. Private-määreellä merkityt oliomuuttujat ovat näkyvillä ja käsiteltävissä vain luokan sisäisessä koodissa. Jos kirjalla olisi private-määreellinen metodi, ei sitäkään voisi käyttää muualta kuin Kirja-luokan sisältä.</p>

    <p>Sitten itse asiaan, eli harjoitteluun!</p>

    <div class="tehtavat" id="viikko7">

      <div class="tehtava">
        <h3>Hymiöt</h3>

        <p>Laadi tehtavapohjan mukana tulevalle luokalle <code>Hymiot</code> apumetodi <code>private static void tulostaHymioityna(String merkkijono)</code>. Metodin tulee tulostaa annettu merkkijono hymiöillä ympyröitynä. Käytä hymiönä merkkijonoa <code>:)</code>.</p>

        <pre class="sh_java">
tulostaHymioityna("\\:D/");
        </pre>

        <pre>
:):):):):)
:) \:D/ :)
:):):):):)
        </pre>

        <p>Huomaa, että merkkijonoon on kirjoitettava \\ jotta saadaan tulostumaan merkki \.</p>

        <p><em>Huom!</em> Jos merkkijonon pituus on pariton, tulee ylimääräinen välilyönti lisätä annetun merkkijonon oikealle puolelle.</p>

        <pre class="sh_java">
tulostaHymioityna("\\:D/");
tulostaHymioityna("87.");
        </pre>

        <pre>
:):):):):)
:) \:D/ :)
:):):):):)
:):):):):)
:) 87.  :)
:):):):):)
        </pre>

        <p>Kannattaa ensin miettiä montako hymiötä minkäkin pituiselle merkkijonolle tulee tulostaa. Merkkijonon pituuden saa selville siihen liittyvällä <code>length</code>-metodilla. Ala- ja ylärivin hymiöiden tulostamiseen auttaa toistolause, keskimmäisellä rivillä selviät normaalilla tulostuskomennolla. Pituuden parittomuuden voit tarkistaa jakojäännöksen avulla <code>merkkijono.length() % 2 == 1</code>.</p>

      </div>
      <div class="tehtava">
        <h3>Merkkijonomuuntaja</h3>

        <p>Tässä tehtävässä luodaan merkkijonomuuntaja, joka koostuu kahdesta luokasta. Luokka Muunnos muuttaa yksittäiset merkit toiseksi, Muuntaja sisältää joukon Muunnoksia ja muuttaa merkkijonoja sisältämiensä Muunnos-olioiden avulla.</p>

        <h4>Muunnos-luokka</h4>

        <p>Luo luokka <code>Muunnos</code>, jolla on seuraavat toiminnot:</p>

        <ul>
          <li> konstruktori <code>public Muunnos(char muunnettava, char muunnettu)</code> luo olion joka tekee muunnoksia merkiltä <code>muunnettava</code> merkille <code>muunnettu</code></li>
          <li> metodi <code>public String muunna(String merkkijono)</code> palauttaa muunnetun version annetusta merkkijonosta</li>
        </ul>

        <p>Luokkaa käytetään seuraavalla tavalla:</p>

        <pre class="sh_java">
  String sana = "porkkana";
  Muunnos muunnos1 = new Muunnos('a', 'b');
  sana = muunnos1.muunna(sana);

  System.out.println(sana);

  Muunnos muunnos2 = new Muunnos('k', 'x');
  sana = muunnos2.muunna(sana);

  System.out.println(sana);
        </pre>

        <p>Yllä oleva esimerkki tulostaisi:</p>

        <pre>
  porkkbnb
  porxxbnb
        </pre>

        <p><strong>Vihje:</strong> voit tehdä merkkien korvaamisen kahdella tavalla, joko suoraan hyödyntäen luokan <code>String</code> metodia (etsi metodi itse!) tai käymällä merkkijonon läpi merkki merkiltä ja samalla muodostaen muunnetun merkkijonon.</p>

        <p>Jos et käytä Stringin valmista metodia, niin kannattaa muistaa, että vaikka merkkijonoja vertaillaankin komennolla <code>equals</code> yksittäisiä merkkejä vertaillaan operaattorin == avulla:
        </p>

        <pre class="sh_java">
  String sana = "porkkana";

  String korvattuAat = "";
  for ( int i=0; i &lt; sana.length(); i++) {
     char merkki = sana.charAt(i);
     if ( merkki == 'a' ) {
        korvattuAat += '*'
     }  else {
        korvattuAat += merkki;
     }
  }

  System.out.println(korvattuAat);  // tulostu porkk*n*
        </pre>

        <h4>Muuntaja-luokka</h4>

        <p>Luo luokka <code>Muuntaja</code>, jolla on seuraavat toiminnot:</p>

        <ul>
          <li> konstruktori <code>public Muuntaja()</code> luo uuden muuntajan</li>
          <li> metodi <code>public void lisaaMuunnos(Muunnos muunnos)</code> lisää uuden muunnoksen muuntajaan</li>
          <li> metodi <code>public String muunna(String merkkijono)</code> suorittaa merkkijonolle kaikki lisätyt muunnokset niiden lisäysjärjestyksessä ja palauttaa muunnetun merkkijonon</li>
        </ul>

        <p>Luokkaa käytetään seuraavalla tavalla:</p>

        <pre class="sh_java">
  Muuntaja skanditPois = new Muuntaja();
  skanditPois.lisaaMuunnos(new Muunnos('ä', 'a'));
  skanditPois.lisaaMuunnos(new Muunnos('ö', 'o'));
  System.out.println(skanditPois.muunna("ääliö älä lyö, ööliä läikkyy"));
        </pre>

        <p>Yllä oleva esimerkki tulostaisi:</p>

        <pre>
  aalio ala lyo, oolia laikkyy
        </pre>

        <p><strong>Vihje:</strong> Muunnokset kannattaa tallettaa Muuntajan oliomuuttujana olevalle listalle (samaan tyyliin kuin peruskurssilla talletettiin esim. pelaajat joukkueeseen, puhelinnumerot puhelinluetteloon tai kirjat kirjastoon). Muunnos suoritetaan siten, että muunnettavalle merkkijonolle suoritetaan muunnokset yksi kerrallaan seuraavan esimerkin tapaan:</p>

        <pre class="sh_java">
    ArrayList&lt;Muunnos&gt; muunnokset = new ArrayList&lt;Muunnos&gt;();

    muunnokset.add( new Muunnos('a', 'b') );
    muunnokset.add( new Muunnos('k', 'x') );
    muunnokset.add( new Muunnos('o', 'å') );

    String sana = "porkkana";

    for (Muunnos muunnos : muunnokset) {
        sana = muunnos.muunna(sana);
    }

    System.out.println(sana);  // tulostuu pårxxbnb
        </pre>

        <p><strong>MUISTUTUS</strong> kun lisäät ohjelmaasi ArrayList:in, Scanner:in tai Random:in ei Java tunnista luokkaa ellet "importoi" sitä lisäämällä ohjelmatiedoston alkuun:</p>

        <pre class="sh_java">
import java.util.ArrayList;    // importoi ArrayListin
import java.util.*;            // importoi kaikki java.util:sissa olevat työkalut, mm. ArrayListin, Scannerin ja Randomin
        </pre>
      </div>
      <div class="tehtava">
        <h3>Laskin</h3>

        <p>Teemme tässä tehtävässä samantyylisen yksinkertaisen laskimen, joka oli jo ohjelmoinnin perusteiden viikon 1 materiaalissa. Tällä kertaa kiinnitämme kuitenkin huomiota ohjelman rakenteeseen. Erityisesti teemme <em>main</em>-metodista eli pääohjelmasta hyvin kevyen. Pääohjelmametodi ei tee oikeastaan mitään muuta kun käynistää ohjelman:</p>

        <pre class="sh_java">
public class Paaohjelma {
    public static void main(String[] args) {
        Laskin laskin = new Laskin();
        laskin.kaynnista();
    }
}
        </pre>

        <p>Pääohjelma siis ainoastaan luo varsinaisen sovelluslogiikan toteuttavan olion ja käynnistää sen. Tämä on oikea tyyli tehdä ohjelmia ja tulemme jatkossa usein pyrkimään tähän rakenteeseen.</p>

        <h4>Lukija</h4>

        <p>Kommunikoidakseen käyttäjän kanssa laskin tarvitsee Scanner-olion. Kuten olemme huomanneet, on kokonaislukujen lukeminen scannerilla hieman työlästä. Teemme nyt erillisen luokan <code>Lukija</code> joka kapseloi sisälleen Scanner-olion. </p>

        <p>Toteuta luokka <code>Lukija</code> ja lisää sille metodit</p>

        <ul>
          <li><code>public String lueMerkkijono()</code></li>
          <li><code>public int lueKokonaisluku()</code></li>
        </ul>

        <p>Lukijan sisällä tulee olla oliomuuttujana Scanner-olio jota metodit käyttävät ohjelmoinnin perusteista tuttuun tyyliin. Muistathan että kokonaislukujen lukemisessa kannattaa ensin lukea koko rivi, jonka jälkeen rivi tulee muuttaa kokonaisluvuksi. Tässä on hyödyksi <code>Integer</code>-luokan metodi <code>parseInt</code>.</p>

        <h4>Sovellusrunko</h4>

        <p>Laskin toimii seuraavan esimerkin mukaan:</p>

        <pre>
komento: <font color="red">summa</font>
luku1: <font color="red">4</font>
luku2: <font color="red">6</font>
lukujen summa 10

komento: <font color="red">tulo</font>
luku1: <font color="red">3</font>
luku2: <font color="red">2</font>
lukujen tulo 6

komento: <font color="red">lopetus</font>
        </pre>

        <p>Tee ohjelmaasi sovelluslogiikasta huolehtiva luokka <code>Laskin</code> ja sille metodi <code>public void kaynnista()</code> jonka sisältö on <strong>täsmälleen</strong> seuraava:</p>

        <pre class="sh_java">
    public void kaynnista() {
        while (true) {
            System.out.print("komento: ");
            String komento = lukija.lueMerkkijono();
            if (komento.equals("lopetus")) {
                break;
            }

            if (komento.equals("summa")) {
                summa();
            } else if (komento.equals("erotus")) {
                erotus();
            } else if (komento.equals("tulo")) {
                tulo();
            }
        }

        statistiikka();
    }
        </pre>

        <p>Laskimellamme on operaatiot <code>summa, erotus, tulo</code>.</p>

        <p>Tee valmiiksi rungot metodeille <code>summa</code>, <code>erotus</code>, <code>tulo</code> ja <code>statistiikka</code>. Kaikkien tulee olla tyyppiä <code>private void</code>, eli metodit ovat vain laskimen sisäisessä käytössä.</p>

        <p>Lisää laskimelle oliomuuttuja jonka tyyppi on <code>Lukija</code>, ja luo lukija konstruktorissa. <em>Laskimessa ei saa olla erikseen Scanner-tyyppistä muuttujaa!</em></p>

        <h4>Sovelluslogiikan toteutus</h4>

        <p>Toteuta nyt metodit <code>summa</code>, <code>erotus</code> ja <code>tulo</code> siten, että ne toimivat yllä olevan esimerkin mukaan. Esimerkissä kysytään aina ensin komento, jonka jälkeen kysytään 2 lukua käyttäjältä, suoritetaan haluttu operaatio, ja tulostetaan operaation arvo. Huomaa, että lukujen kysyminen tapahtuu metodien<code>summa</code>, <code>erotus</code> ja <code>tulo</code> sisällä! Metodit käyttävät lukujen kysymiseen lukija-olioa. Metodien runko on siis seuraavanlainen:</p>

        <pre class="sh_java">
    private void summa() {
       System.out.print("luku1: ");
       int luku1 = // luetaan luku käyttäen lukija-olioa
       System.out.print("luku2: ");
       int luku2 = // luetaan luku käyttäen lukija-olioa
       // tulostetaan tulos ylläolevan esimerkin tapaan
    }
        </pre>

        <h4>Statistiikka</h4>

        <p>Metodissa <code>kaynnista</code> olevan <code>while</code>-silmukan jälkeen kutsutaan metodia <code>statistiikka</code>. Metodin on tarkoitus tulostaa kuinka montaa kertaa laskin-oliolla suoritettiin joku laskutoimenpide. Esim:</p>

        <pre>
komento: <font color="red">summa</font>
luku1: <font color="red">4</font>
luku2: <font color="red">6</font>
lukujen summa 10

komento: <font color="red">tulo</font>
luku1: <font color="red">3</font>
luku2: <font color="red">2</font>
lukujen tulo 6

komento: <font color="red">lopetus</font>
Laskuja laskettiin 2
        </pre>

        <p>Toteuta metodi <code>private void statistiikka()</code>, ja tee statistiikan keräämiseen tarvittavat muutokset muualle Laskin-luokan koodiin. </p>

        <p>Huom: jos ohjelmalle annetaan virheellinen komento (eli joku muu kuin summa, erotus, tulo, tai lopetus), ei laskin reagoi komentoon millään tavalla vaan jatkaa kysymällä seuraavaa komentoa. Statistiikka ei saa laskea virheellistä komentoa laskutoimenpiteeksi.</p>

        <pre>
komento: <font color="red">integraali</font>
komento: <font color="red">erotus</font>
luku1: <font color="red">3</font>
luku2: <font color="red">2</font>
lukujen erotus 1

komento: <font color="red">lopetus</font>
Laskuja laskettiin 1
        </pre>

        <p><strong>Bonustehtävä (ei testata):</strong> Syötteen lukeminen toistuu samanlaisena kaikissa kolmessa laskuoperaation suorittavassa metodissa. Posta koodistasi toisteisuus sopivan apumetodin avulla. Metodi voi palauttaa käyttäjältä luetut 2 lukua esim. taulukossa. </p>

      </div>
    </div>


    <h2>Alkeis- ja viitetyyppiset muuttujat</h2>

    <p>Java on vahvasti tyypitetty kieli, eli kaikilla sen muuttujilla on <em>tyyppi</em>. Muuttujien tyypit voidaan jakaa kahteen kategoriaan: <strong>alkeis- ja viitetyyppisiin muuttujiin</strong>. Kummankin kategorian tyypisillä muuttujilla on oma "lokero", joka sisältää niihin liittyvän tiedon. Alkeistyyppisillä muuttujilla lokeroon talletetaan muuttujien konkreettinen <em>arvo</em>, kun taas viitetyyppisten muuttujien lokero sisältää <em>viitteen</em> muuttujaan liittyvään konkreettiseen <em>olioon</em>.</p>

    <h3>Alkeistyyppiset muuttujat</h3>

    <p>Alkeistyyppisen muuttujan arvo tallennetaan muuttujaa varten luotuun lokeroon. Jokaisella alkeistyyppisellä muuttujalla on oma lokero ja oma arvo. Muuttujalle luodaan uusi lokero silloin kun se esitellään (esim. <code>int numero;</code>). Lokeroon asetetaan arvo sijoitusoperaatiolla <code>=</code>. Alla on esimerkki alkeistyyppisen int (kokonaisluku) -muuttujan esittelemisestä ja arvon asettamisesta samassa lausekkeessa.</p>

    <pre class="sh_java">
int numero = 42;
    </pre>

    <p>Alkeistyyppisiä muuttujia ovat muun muassa <code>int</code>, <code>double</code>, <code>char</code>, <code>boolean</code> sekä harvemmin käyttämämme <code>short</code>, <code>float</code>, <code>byte</code> ja <code>long</code>. Myös <code>void</code> on alkeistyyppi, mutta sillä ei ole omaa lokeroa tai arvoa. Void-tyyppiä käytetään silloin kun halutaan ilmaista että metodi ei palauta mitään arvoa.</p>

    <p>Esitellään seuraavaksi kaksi alkeistyyppistä muuttujaa ja asetetaan niihin arvot.</p>

    <pre class="sh_java">
int vitonen = 5;
int kutonen = 6;
    </pre>

    <p>Yllä esiteltyjen alkeistyyppisten muuttujien nimet ovat <code>vitonen</code> ja <code>kutonen</code>. Muuttujaa <code>vitonen</code> luodessa sitä varten luotuun <em>lokeroon</em> asetetaan arvo 5 (<code>int vitonen = 5;</code>). Muuttujaa <code>kutonen</code> luodessa sitä varten luotuun lokeroon asetetaan arvo 6 (<code>int kutonen = 6;</code>). Muuttujat <code>vitonen</code> ja <code>kutonen</code> ovat kumpikin <code>int</code>-tyyppisiä, eli kokonaislukuja.</p>

    <p>Alkeistyyppiset muuttujat voi visualisoida laatikkoina joiden sisälle kuhunkin muuttujaan liittyvä arvo on tallennettu:</p>

    <p><img src="https://www.cs.helsinki.fi/group/java/k13/ohja/img-ohja/vis/alkeis-vs-viittaus-vitonen-ja-kutonen.png" /></p>

    <p>Tarkastellaan seuraavaksi alkeistyyppisten muuttujien arvojen kopioitumista.</p>

    <pre class="sh_java">
int vitonen = 5;
int kutonen = 6;

vitonen = kutonen; // muuttuja vitonen sisältää nyt arvon 6, eli arvon joka oli muuttujassa kutonen
kutonen = 64; // muuttuja kutonen sisältää nyt arvon 64

// muuttuja vitonen sisältää vieläkin arvon 6
    </pre>

    <p>Yllä esitellään muuttujat <code>vitonen</code> ja <code>kutonen</code> ja asetetaan niihin arvot. Tämän jälkeen muuttujan <code>vitonen</code> lokeroon kopioidaan muuttujan <code>kutonen</code> lokeron sisältämä arvo (<code>vitonen = kutonen;</code>). Tässä vaiheessa muuttujan <code>vitonen</code> lokeroon kopioituu muuttujan <code>kutonen</code> sisältämä arvo. Jos muuttujan <code>kutonen</code> arvoa muutetaan tämän jälkeen, ei muuttujan <code>vitonen</code> sisältämä arvo muutu: muuttujan <code>vitonen</code> arvo on sen omassa lokerossa eikä liity muuttujan <code>kutonen</code> lokerossa olevaan arvoon millään tavalla. Lopputilanne kuvana.</p>

    <p><img src="https://www.cs.helsinki.fi/group/java/k13/ohja/img-ohja/vis/alkeis-vs-viittaus-vitonen-ja-kutonen-64.png" /></p>

    <h4>Alkeistyyppinen muuttuja metodin parametrina ja paluuarvona</h4>

    <p>Kun alkeistyyppinen muuttuja annetaan metodille parametrina, asetetaan metodin parametrille kopio annetun muuttujan lokerossa olevasta. Käytännössä myös metodin parametreillä on omat lokerot, joihin arvo kopioidaan kuten asetuslauseessa. Katsotaan seuraavaa metodia <code>lisaaLukuun(int luku, int paljonko)</code>.</p>

    <pre class="sh_java">
public int lisaaLukuun(int luku, int paljonko) {
    return luku + paljonko;
}
    </pre>

    <p>Metodi <code>lisaaLukuun</code> saa kaksi parametria, kokonaisluvut <code>luku</code> ja <code>paljonko</code>. Metodi palauttaa uuden luvun, joka on annettujen parametrien summa. Tutkitaan vielä metodin kutsumista.</p>

    <pre class="sh_java">
int omaLuku = 10;
omaLuku = lisaaLukuun(omaLuku, 15);
// muuttuja omaLuku sisältää nyt arvon 25
    </pre>

    <p>Esimerkissä kutsutaan <code>lisaaLukuun</code>-metodia muuttujalla <code>omaLuku</code> ja arvolla <code>15</code>. Metodin muuttujiin <code>luku</code> ja <code>paljonko</code> kopioituvat arvot 10, eli muuttujan <code>omaLuku</code> sisältö, ja 15. Metodi palauttaa muuttujien <code>luku</code> ja <code>paljonko</code> summan, eli <code>10 + 15 = 25</code>.</p>

    <p>Huom! Edellisessä esimerkissä muuttujan <code>omaLuku</code> arvo muuttuu ainoastaan koska metodin <code>lisaaLukuun</code> palauttama arvo asetetaan siihen sijoituslausekkeella (<code>omaLuku = lisaaLukuun(omaLuku, 15);</code>). Jos metodin <code>lisaaLukuun</code> kutsu olisi seuraavanlainen, ei muuttujan <code>omaLuku</code> arvo muutu.</p>

    <pre class="sh_java">
int omaLuku = 10;
lisaaLukuun(omaLuku, 15);
// muuttuja omaLuku sisältää vieläkin arvon 10
    </pre>

    <h4>Minimi- ja maksimiarvot</h4>

    <p>Eri tietotyypeillä on omat minimi- ja maksimiarvonsa, eli arvot joita pienempiä tai suurempia ne eivät voi olla. Tämä johtuu Javan (ja useimpien ohjelmointikielten) sisäisestä tiedon esitysmuodosta, jossa tietotyyppien koot on ennalta määrätty.</p>

    <p>Alla muutama Javan alkeistyyppi ja niiden minimi- ja maksimiarvot</p>

    <p>
    <table cellspacing="5" >
      <tr><th>Muuttujatyyppi</th><th>Selitys</th><th>Minimiarvo</th><th>Maksimiarvo</th></tr>
      <tr><td>int</td><td>Kokonaisluku</td><td>-2 147 483 648 (<code>Integer.MIN_VALUE</code>)</td><td>2 147 483 647 (<code>Integer.MAX_VALUE</code>)</td></tr>
      <tr><td>long</td><td>Iso kokonaisluku</td><td>-9 223 372 036 854 775 808 (<code>Long.MIN_VALUE</code>)</td><td>9 223 372 036 854 775 807 (<code>Long.MAX_VALUE</code>)</td></tr>
      <tr><td>boolean</td><td>Totuusarvo</td><td colspan=2><code>true</code> tai <code>false</code></td></tr>
      <tr><td>double</td><td>Liukuluku</td><td><code>Double.MIN_VALUE</code></td><td><code>Double.MAX_VALUE</code></td></tr>
    </table>
    </p>

    <p><strong>Pyöristysvirheet</strong></p>

    <p>Liukulukuja käyttäessä kannattaa muistaa että liukuluvun arvo on aina <em>arvio</em> oikeasta arvosta. Koska liukuluvun, kuten kaikkien muidenkin alkeistyyppien sisältämä tietomäärä on rajoitettu, voidaan huomata yllättäviäkin pyöristysvirheitä. Esimerkiksi seuraava tilanne.</p>

    <pre class="sh_java">
double eka = 0.39;
double toka = 0.35;
System.out.println(eka - toka);
    </pre>

    <p>Esimerkki tulostaa arvon <code>0.040000000000000036</code>. Ohjelmointikielet tarjoavat usein työkalut liukulukujen tarkempaa käsittelyä varten. Esimerkiksi Javassa on luokka <em>BigDecimal</em>, johon voi asettaa äärettömän pitkiä liukulukuja.</p>

    <p>Liukulukuja vertaillessa pyöristysvirheisiin varaudutaan usein vertaamalla arvojen etäisyyttä toisistaan. Esimerkiksi edellisen esimerkin muuttujia käytettäessä vertailu <code>eka - toka == 0.04</code> ei tuota toivottua tulosta pyöristysvirheen takia.</p>

    <pre class="sh_java">
double eka = 0.39;
double toka = 0.35;

if((eka - toka) == 0.04) {
    System.out.println("Vertailu onnistui!");
} else {
    System.out.println("Vertailu epäonnistui!");
}
    </pre>

    <pre>
Vertailu epäonnistui!
    </pre>

    <p>Arvon etäisyyttä jostain luvusta voi tarkastella esimerkiksi seuraavasti. Apufunktio <code>Math.abs</code> palauttaa sille annetun luvun itseisarvon.</p>

    <pre class="sh_java">
double eka = 0.39;
double toka = 0.35;

double etaisyys = 0.04 - (eka - toka);

if(Math.abs(etaisyys) &lt; 0.0001) {
    System.out.println("Vertailu onnistui!");
} else {
    System.out.println("Vertailu epäonnistui!");
}
    </pre>

    <h3>Viitetyyppi</h3>

    <p>Viitetyyppiset muuttujat tallentavat niihin liittyvän tiedon viitteen taakse eli "langan päähän". Viitetyyppisten muuttujien lokerossa on viite tiedon sisältävään paikkaan. Toisin kuin alkeistyyppisillä muuttujilla, viitetyyppisillä muuttujilla ei ole rajoitettua arvoaluetta, koska niiden oikea arvo tai <em>tieto</em> on viitteen takana. Oleellinen ero alkeistyyppisiin muuttujiin on se, että usea viitetyyppinen muuttuja voi viitata samaan olioon.</p>

<!--
        <p>Viitetyyppisistä muuttujista puhutaan olioina, joita luodaan <code>new</code>-kutsulla. Muuttujan arvo asetetaan vieläkin sijoitusoperaattorilla <code>=</code>, mutta komento <code>new</code> luo olion ja palauttaa viitteen olioon. Viite asetetaan muuttujaan liittyvään lokeroon eli sen arvoksi.</p>
-->

    <p>Tutkitaan kahden viitetyyppisen muuttujan luontia. Esimerkeissä käytetään seuraavaa luokkaa <em>Laskuri</em>:</p>

    <pre class="sh_java">
public class Laskuri {
    private int arvo;

    public Laskuri(int alkuarvo) {  // Konstruktori
        this.arvo = alkuarvo;
    }

    public void kasvataArvoa() {
        this.arvo = this.arvo + 1;
    }

    public int annaArvo() {
        return arvo;
   }
}
    </pre>

    <p>Pääohjelma:</p>

    <pre class="sh_java">
Laskuri bonusLaskuri = new Laskuri(5);
Laskuri axeLaskuri = new Laskuri(6);
    </pre>

    <p>Esimerkissä luodaan ensin viitetyyppinen muuttuja <code>bonusLaskuri</code>. Komentoa <code>new</code> kutsuessa varataan tila muuttujan tietoa varten, suoritetaan <code>new</code>-kutsua seuraavan konstruktorin koodi, ja palautetaan viite juuri luotuun olioon. . Palautettu viite asetetaan sijoitusoperaattorilla <code>=</code> muuttujaan <code>bonusLaskuri</code>. Sama tapahtuu muuttujalle nimeltä <code>axeLaskuri</code>. Kuvana viitetyyppi kannattaa ajatella siten, että muuttuja sisältää "langan" tai "nuolen", jonka päässä on olio itse. Muuttuja ei siis sisällä oliota, vaan viitteen olioon liittyviin tietoihin.</p>

    <p><img src="https://www.cs.helsinki.fi/group/java/k13/ohja/img-ohja/vis/viittaustyyppiset-muuttujat-laskurit.png" /></p>

    <p>Tutkitaan seuraavaksi viitetyyppisen muuttujan kopioitumista.</p>

    <pre class="sh_java">
Laskuri bonusLaskuri = new Laskuri(5);
Laskuri axeLaskuri = new Laskuri(6);

bonusLaskuri = axeLaskuri; // muuttujaan bonusLaskuri kopioidaan muuttujan axeLaskuri sisältämä viite,
                           // eli viite Laskuri-tyyppiseen olioon joka on saanut konstruktorissaan arvon 6
    </pre>

    <p>Viitetyyppistä muuttujaa kopioitaessa (yllä <code>bonusLaskuri = axeLaskuri;</code>) muuttujan viite kopioituu. Yllä muuttujan <code>bonusLaskuri</code> lokeroon kopioituu muuttujan <code>axeLaskuri</code> lokerossa oleva viite. Nyt kummatkin oliot viittaavat samaan paikkaan!</p>

    <p><img src="https://www.cs.helsinki.fi/group/java/k13/ohja/img-ohja/vis/viittaustyyppiset-muuttujat-laskurit-3.png" /></p>

    <p>Jatketaan yllä olevaa esimerkkiä ja asetetaan muuttujaan <code>axeLaskuri</code> uusi viite, joka osoittaa kutsulla <code>new Laskuri(10)</code> luotuun olioon.</p>

    <pre class="sh_java">
Laskuri bonusLaskuri = new Laskuri(5);
Laskuri axeLaskuri = new Laskuri(6);

bonusLaskuri = axeLaskuri; // muuttujaan bonusLaskuri kopioidaan muuttujan axeLaskuri sisältämä viite,
                           // eli viite Laskuri-tyyppiseen olioon joka on saanut konstruktorissaan arvon 6

axeLaskuri = new Laskuri(10); // muuttujaan axeLaskuri asetetaan uusi viite, joka osoittaa
                              // new Laskuri(10) - kutsulla luotuun Laskuri-olioon

// muuttuja bonusLaskuri sisältää vieläkin viitteen Laskuri-olioon, joka sai konstruktorissaan arvon 6
    </pre>

    <p>Esimerkissä tehdään käytännössä samat operaatiot kuin alkeistyyppi-kappaleessa olevassa asetusesimerkissä. Äskeisessä esimerkissä kopioimme viitetyyppisten muuttujien viitteitä, kun taas alkeistyyppisiin muuttujiin liittyvässä esimerkissä kopioimme alkeistyyppien arvoja. Kummassakin tapauksessa siis lokeron sisältö kopioidaan, alkeistyyppisten muuttujien lokero sisältää arvon, viitetyyppisten muuttujien lokero sisältää viitteen.</p>

    <p>Edellisen esimerkin lopussa kukaan ei viittaa Laskuriolioon, joka sai arvokseen 5 sen konstruktorissa. Javassa oleva roskienkeruumekanismi käy ajallaan poistamassa tällaiset turhat oliot. Lopputilanne kuvana:</p>


    <p><img src="https://www.cs.helsinki.fi/group/java/k13/ohja/img-ohja/vis/viittaustyyppiset-muuttujat-laskurit-2.png" /></p>

    <p>Tarkastellaan vielä kolmatta esimerkkiä, joka näyttää viite- ja alkeistyyppisten muuttujien oleellisen eron.</p>

    <pre class="sh_java">
Laskuri bonusLaskuri = new Laskuri(5);
Laskuri axeLaskuri = new Laskuri(6);

bonusLaskuri = axeLaskuri; // muuttujaan bonusLaskuri kopioidaan muuttujan axeLaskuri sisältämä viite,
                           // eli viite Laskuri-tyyppiseen olioon joka on saanut konstruktorissaan arvon 6

axeLaskuri.kasvataArvoa(); // kasvatetaan axeLaskuri-viitteen takana olevan olion arvoa yhdellä

System.out.println(bonusLaskuri.annaArvo());
System.out.println(axeLaskuri.annaArvo());
    </pre>

    <pre>
7
7
    </pre>

    <p>Koska asetuksen <code>bonusLaskuri = axeLaskuri;</code> jälkeen <code>bonusLaskuri</code>-muuttuja viittaa samaan olioon kuin <code>axeLaskuri</code>-muuttuja, on kummankin laskurin arvo 7 vaikka kasvatuksia on tehty vain yksi. Tämä johtuu siitä että kummatkin laskurit viittaavat samaan olioon.</p>

    <p>Kuvana tilanne on ehkä selkeämpi. Kutsu <code>axeLaskuri.kasvataArvoa()</code> kasvattaa muuttujan <code>axeLaskuri</code> viittaaman olion sisältämää muuttujan <code>arvo</code> arvoa yhdellä. Koska muuttuja <code>bonusLaskuri</code> viittaa samaan olioon, palauttaa kutsu <code>bonusLaskuri.annaArvo()</code> saman muuttujan arvon, jota aiempi kutsu <code>axeLaskuri.kasvataArvoa()</code> kasvatti.</p>

    <p><img src="https://www.cs.helsinki.fi/group/java/k13/ohja/img-ohja/vis/viittaustyyppiset-muuttujat-laskurit-4.png" /></p>

    <p> Seuraavassa esimerkissä on kolme viitetyyppistä muuttujaa, jotka kaikki osoittavat samaan <code>Laskuri</code>-olioon.</p>

    <pre class="sh_java">
Laskuri bonus = new Laskuri(5);
Laskuri ihq = bonus;
Laskuri lennon = bonus;
    </pre>

    <p>Esimerkissä luodaan vain yksi <code>Laskuri</code>-olio, mutta kaikki kolme <code>Laskuri</code>-tyyppistä muuttujaa osoittavat lopussa siihen. Tällöin kaikki metodikutsut viitteille <code>bonus</code>, <code>ihq</code> ja <code>lennon</code> muokkaavat samaa oliota. Vielä kerran: viitetyyppisiä muuttujia kopioitaessa viitteet kopioituvat. Kuvana:</p>


    <p><img src="https://www.cs.helsinki.fi/group/java/k13/ohja/img-ohja/vis/viittaustyyppiset-muuttujat-laskurit-5.png" /></p>

    <p>Katsotaan kopioitumista vielä esimerkillä.</p>

    <pre class="sh_java">
Laskuri bonus = new Laskuri(5);
Laskuri ihq = bonus;
Laskuri lennon = bonus;

lennon = new Laskuri(3);
    </pre>

    <p>Kun muuttujan <code>lennon</code> sisältö, eli viite muuttuu, se ei vaikuta muuttujien <code>bonus</code> tai <code>ihq</code> sisältämiin viitteisiin. Muuttujan arvoa asetettaessa muutetaan aina vain muuttujan oman lokeron sisältöä. Kuvana:</p>

    <p><img src="https://www.cs.helsinki.fi/group/java/k13/ohja/img-ohja/vis/viittaustyyppiset-muuttujat-laskurit-6.png" /></p>

    <h4>Viitetyyppinen muuttuja metodin parametrina</h4>

    <p>Kun viitetyyppinen muuttuja annetaan parametrina metodille, luodaan metodin parametrille kopio annetusta muuttujan viitteestä. Parametrilla on siis oma lokero, johon viite kopioidaan. Alkeistyyppisistä muuttujista poiketen kopioimme viitteen, emmekä arvoa, eli voimme muokata viitteen takana olevaa oliota myös metodin sisällä. Oletetaan että metodimme on alla esitelty <code>public void lisaaLaskuriin(Laskuri laskuri, int paljonko)</code>.</p>

    <pre class="sh_java">
public void lisaaLaskuriin(Laskuri laskuri, int paljonko) {
    for (int i = 0; i &lt; paljonko; i++) {
        laskuri.kasvataArvoa();
    }
}
    </pre>

    <p>Metodille <code>lisaaLaskuriin</code> annetaan kaksi parametria, viitetyyppinen muuttuja ja alkeistyyppinen muuttuja. Kumpaankin muuttujaan liittyvän lokeron sisältö kopioidaan metodin parametrien omiin lokeroihin. Viitetyyppiselle parametrille <code>laskuri</code> kopioituu viite ja alkeistyyppiselle parametrille <code>paljonko</code> kopioituu arvo. Metodi kutsuu <code>Laskuri</code>-tyyppisen parametrin metodia <code>kasvataArvoa()</code> <code>paljonko</code>-muuttujan sisältämän arvon määrän. Tutkitaan vielä metodin kutsumista.</p>

    <pre class="sh_java">
int kertoja = 10;

Laskuri bonus = new Laskuri(10);
lisaaLaskuriin(bonus, kertoja);
// muuttujan bonus sisäinen arvo on nyt 20
    </pre>

    <p>Esimerkissä kutsutaan <code>lisaaLaskuriin()</code>-metodia muuttujilla <code>bonus</code> ja <code>kertoja</code>. Metodin parametriin <code>laskuri</code> ja <code>paljonko</code> kopioituvat siis viitetyyppisen muuttujan <code>bonus</code> viite, ja alkeistyyppisen muuttujan <code>kertoja</code> arvo <code>10</code>. Metodi suorittaa metodissa olevalle muuttujalle <code>laskuri</code> <code>paljonko</code> muuttujan määrittelemän määrän <code>kasvataArvoa()</code>-metodikutsuja. Tämä kuvana:</p>


    <p><img src="https://www.cs.helsinki.fi/group/java/k13/ohja/img-ohja/vis/viittaustyyppiset-muuttujat-laskurit-7.png" /></p>

    <p><em>Metodissa on siis pääohjelmasta täysin erilliset muuttujat!</em></p>

    <p>Viitetyyppisestä muuttujasta kopioituu metodin sisäiseen muuttujaan viite, eli metodin sisäinen muuttuja viittaa vieläkin samaan olioon. Alkeistyyppisestä muuttujasta kopioituu arvo, eli metodin sisäisellä muuttujalla on täysin oma arvonsa.</p>

    <p>Metodi näkee saman laskurin johon muuttuja <code>bonus</code> viittaa, eli metodin tekemä muutos vaikuttaa suoraan olioon. Alkeistyyppien suhteen tilanne on toinen, eli metodille tulee ainoastaan kopio muuttujan <code>kertoja</code> arvosta. Metodista käsin ei siis voi muuttaa alkeistyyppisten muuttujien arvoja.</p>

    <h4>Viitetyyppinen muuttuja metodin paluuarvona</h4>

    <p>Kun metodi palauttaa viitetyyppisen muuttujan, palauttaa se viitteen muualla sijaitsevaan olioon. Metodin palauttaman viitetyyppisen muuttujan voi asettaa muuttujalle samalla tavalla kuin normaalikin asetus tapahtuu, eli yhtäsuuruusmerkin avulla. Katsotaan metodia <code>public Laskuri luoLaskuri(int alkuarvo)</code>, joka luo uuden viitetyyppisen muuttujan.</p>

    <pre class="sh_java">
public Laskuri luoLaskuri(int alkuarvo) {
    return new Laskuri(alkuarvo);
}
    </pre>

    <p>Metodi luoLaskuri palauttaa metodissa luotuun olioon viittaavan viitteen <code>uusiLaskuri</code>. Uusi olio luodaan aina metodia kutsuttaessa, seuraavassa esimerkissä luomme kaksi erillistä <code>Laskuri</code>-tyyppistä oliota.</p>

    <pre class="sh_java">
Laskuri bonus  = luoLaskuri(10);
Laskuri lennon = luoLaskuri(10);
    </pre>

    <p>Metodi <code>luoLaskuri</code> luo aina uuden <code>Laskuri</code>-tyyppisen olion. Ensimmäisessä kutsussa, eli kutsussa <code>Laskuri bonus = luoLaskuri(10);</code> asetetaan metodin palauttama viite viitetyyppiseen muuttujaan <code>bonus</code>. Toisessa metodikutsussa luodaan uusi viite, joka asetetaan muuttujaan <code>lennon</code>. Muuttujat <code>bonus</code> ja <code>lennon</code> eivät sisällä samaa viitettä, sillä metodi luo aina uuden olion ja palauttaa viitteen luotuun olioon.</p>


    <h2 id="stat_ja_ei">Static ja ei-static</h2>


    <p>Kerrataan ja täsmennetään Ohjelmoinnin perusteiden luvussa 30 käsiteltyä asiaa. Staattisuudella ja ei-staattisisuudella erotetaan se, mihin muuttuja tai metodi liittyy. Staattiset metodit liittyvät aina luokkaan, kun taas ei-staattiset metodit voivat muokata olion omia muuttujia.</p>

    <h3>Static, luokkakirjastot ja final</h3>

    <p>Static-määreen saavat metodit eivät liity olioihin vaan luokkiin. On mahdollista määritellä myös luokkakohtaisia muuttujia lisäämällä muuttujan eteen määre <code>static</code>. Esimerkiksi <code>Integer.MAX_VALUE</code>, <code>Long.MIN_VALUE</code> ja <code>Double.MAX_VALUE</code> ovat kaikki staattisia muuttujia. Staattisia muuttujia ja metodeja käytetään luokan nimen kautta, esimerkiksi <code>LuokanNimi.muuttuja</code> tai <code>LuokanNimi.metodi()</code>.</p>

    <p>Luokkakirjastoksi kutsutaan luokkaa, jossa on yleiskäyttöisiä metodeja ja muuttujia. Esimerkiksi Javan <code>Math</code>-luokka on luokkakirjasto. Se tarjoaa muun muassa <code>Math.PI</code>-muuttujan. Omien luokkakirjastojen toteuttaminen on usein hyödyllistä. Esimerkiksi Helsingin Seudun Liikenne (HSL) voisi pitää lippujensa hintoja luokkakirjastossa, josta ne löytyisi tarvittaessa.</p>

    <pre class="sh_java">
public class HslHinnasto {
    public static final double KERTALIPPU_AIKUINEN = 2.50;
    public static final double RAITIOVAUNULIPPU_AIKUINEN = 2.50;
}
    </pre>

    <p>Avainsana <code>final</code> muuttujan määrittelyssä kertoo ettei muuttujaan voi asettaa uutta arvoa kun se on kerran asetettu. Final-tyyppiset muuttujat ovat vakioita, ja niiden tulee sisältää aina arvo. Esimerkiksi suurimman kokonaisluvun kertova luokkamuuttuja <code>Integer.MAX_VALUE</code> on vakiotyyppinen luokkamuuttuja.</p>

    <p>Jos käytössämme on yllä esitelty luokka <code>HslHinnasto</code>, voivat kaikki ohjelmat, jotka tarvitsevat kerta- tai raitiovaunulipun hintaa, päästä niihin käsiksi <code>HslHinnasto</code>-luokan kautta. Seuraavassa esimerkissä esitellään luokka <code>Ihminen</code>, jolla on metodi <code>onkoRahaaKertalippuun()</code>, joka käyttää <code>HslHinnasto</code>-luokasta löytyvää lipun hintaa.</p>

    <pre class="sh_java">
public class Ihminen {
    private String nimi;
    private double rahat;
    // muut oliomuuttujat

    // konstruktori

    public boolean onkoRahaaKertalippuun() {
        if(this.rahat >= HslHinnasto.KERTALIPPU_AIKUINEN) {
            return true;
        }

        return false;
    }

    // muut luokkaan Ihminen liittyvät metodit
}
    </pre>

    <p>Metodi <code>public boolean onkoRahaaKertalippuun()</code> vertaa luokan <code>Ihminen</code> oliomuuttujaa <code>rahat</code> <code>HslHinnasto</code>-luokan staattiseen muuttujaan <code>KERTALIPPU_AIKUINEN</code>. Metodia <code>onkoRahaaKertalippuun()</code> voi kutsua vain olioviitteen kautta. Esimerkiksi:</p>

    <pre class="sh_java">
Ihminen matti = new Ihminen();

if (matti.onkoRahaaKertalippuun()) {
    System.out.println("Ostetaan kertalippu.");
} else {
    System.out.println("Mennään pummilla.");
}
    </pre>

    <p>Huomaa nimeämiskäytäntö! Kaikki <em>vakiot</em> eli final-määreellä varustetut muuttujat kirjoitetaan ISOLLA_JA_ALAVIIVOILLA.</p>

    <p>Staattiset metodit toimivat vastaavasti. Esimerkiksi Luokka <code>HslHinnasto</code> saattaisi <em>kapseloida</em> muuttujat ja antaa vain <em>aksessorit</em> niihin. Aksessoriksi kutsutaan metodia, jolla voi joko lukea muuttujan arvon tai sijoittaa muuttujalle uuden arvon.</p>

    <pre class="sh_java">
public class HslHinnasto {
  private static final double KERTALIPPU_AIKUINEN = 2.50;
  private static final double RAITIOVAUNULIPPU_AIKUINEN = 2.50;

  public static double annaKertalipunHinta() {   // Aksessori
    return KERTALIPPU_AIKUINEN;
  }

  public static double annaRaitiovaunulipunHinta() {   // Aksessori
    return RAITIOVAUNULIPPU_AIKUINEN;
  }
}
    </pre>

    <p>Tällöin <code>Ihminen</code>-luokan toteutuksessa tulee kutsua metodia <code>annaKertalipunHinta()</code> sen sijaan että kutsuttaisiin muuttujaa suoraan.</p>

    <pre class="sh_java">
public class Ihminen {
    private String nimi;
    private double rahat;
    // muut oliomuuttujat

    // konstruktori

    public boolean onkoRahaaKertalippuun() {
        if(this.rahat >= HslHinnasto.annaKertalipunHinta()) {
            return true;
        }

        return false;
    }

    // muut luokkaan Ihminen liittyvät metodit
}
    </pre>


    <p>Vaikka Java periaatteessa mahdollistaa staattisten muuttujien käytön, ei niille useinkaan ole tarvetta. Usein staattisten muuttujien käyttö aiheuttaa ongelmia ohjelman rakenteelle, sillä staattiset muuttujat toimivat pahamaineisten <a href="http://c2.com/cgi/wiki?GlobalVariablesAreBad">globaalien muuttujien</a> tapaan. <b>Tällä kurssilla käytämme ainoastaan vakioarvoisia eli final määreen omaavia staattisia muuttujia!</b></p>

    <h3>Ei-static</h3>

    <p>Ei-staattiset metodit ja muuttujat liittyvät olioihin. Oliomuuttujat, eli attribuutit määritellään luokan alussa. Kun olio luodaan <code>new</code>-kutsulla, kaikille oliomuuttujille varataan tila olioon liittyvän viitteen päähän. Muuttujien arvot ovat oliokohtaisia, eli jokaisella oliolla on omat muuttujien arvot. Tutkitaan taas luokkaa <code>Ihminen</code>, jolla on oliomuuttujat <code>nimi</code> ja <code>rahat</code>.</p>

    <pre class="sh_java">
public class Ihminen {
  private String nimi;
  private double rahat;

  // muut tiedot
}
    </pre>

    <p>Kun luokasta <em>Ihminen</em> luodaan uusi ilmentymä, alustetaan myös siihen liittyvät muuttujat. Jos viitetyyppistä muuttujaa <code>nimi</code> ei alusteta, saa se arvokseen <em>null</em>-viitteen. Lisätään luokan <em>Ihminen</em> toteutukseen vielä <em>konstruktori</em> ja muutama metodi.</p>

    <pre class="sh_java">
public class Ihminen {
    private String nimi;
    private double rahat;

    // konstruktori
    public Ihminen(String nimi, double rahat) {
        this.nimi = nimi;
        this.rahat = rahat;
    }

    public String getNimi() {
        return this.nimi;
    }

    public double getRahat() {
        return this.rahat;
    }

    public void lisaaRahaa(double summa) {
        if(summa &gt; 0) {
          this.rahat += summa;
        }
    }

    public boolean onkoRahaaKertalippuun() {
        if(this.rahat >= HslHinnasto.annaKertalipunHinta()) {
            return true;
        }

        return false;
    }
}
    </pre>

    <p>Konstruktori <code>Ihminen(String nimi, double rahat)</code> luo uuden ihmisolion ja palauttaa viitteen siihen. Metodi <code>getNimi()</code> palauttaa viitteen <code>nimi</code>-olioon, ja <code>getRahat()</code>-metodi palauttaa alkeistyyppisen muuttujan <code>rahat</code>. Metodi <code>lisaaRahaa(double summa)</code> lisää oliomuuttujaan <code>rahat</code> parametrina annetun summan jos parametrin arvo on suurempi kuin 0.</p>

    <p>Oliometodeja kutsutaan olion viitteen kautta. Seuraava koodiesimerkki luo uuden Ihmis-olion, lisää sille rahaa, ja lopuksi tulostaa sen nimen. Huomaa että metodikutsut ovat muotoa <code>olionNimi.metodinNimi()</code></p>

    <pre class="sh_java">
Ihminen matti = new Ihminen("Matti", 5.0);
matti.lisaaRahaa(5);

if (matti.onkoRahaaKertalippuun()) {
    System.out.println("Ostetaan kertalippu.");
} else {
    System.out.println("Mennään pummilla.");
}
    </pre>

    <p>Esimerkki tulostaa "<code>Ostetaan kertalippu</code>".</p>

    <h4>Metodit luokan sisällä</h4>

    <p>Luokan sisäisiä ei-staattisia metodeja voi kutsua myös ilman olio-etuliitettä metodiin liittyvissä luokissa. Esimerkiksi seuraava <code>toString()</code>-metodi <code>Ihminen</code> luokalle, joka kutsuu olioon liittyvää metodia <code>getNimi()</code>.</p>

    <pre class="sh_java">
public class Ihminen {
    // aiemmin toteutetun luokan sisältö

    public String toString() {
        return this.getNimi();
    }
}
    </pre>

    <p>Metodi <code>toString()</code> kutsuu siis luokan sisäistä juuri käsiteltävään olioon liittyvää <code>getNimi()</code>-metodia. Etuliite <code>this</code> korostaa kutsun liittyvän juuri tähän olioon.</p>

    <p>Ei-staattiset metodit voivat kutsua myös staattisia, eli luokkakohtaisia metodeja. Toisaalta, luokkakohtaiset metodit eivät voi kutsua oliokohtaisia metodeja ilman viitettä itse olioon, sillä ilman viitettä ei päästä käsiksi olioon liittyviin tietoihin.</p>


    <h4>Muuttujat metodien sisällä</h4>

    <p>Metodien sisällä määriteltävät muuttujat ovat metodien suorituksessa käytettäviä apumuuttujia, eikä niitä tule sekoittaa oliomuuttujiin. Alla esimerkki metodista, jossa luodaan metodiin paikallinen muuttuja. Muuttuja <code>indeksi</code> on olemassa ja käytössä vain metodin suorituksen ajan.</p>

    <pre class="sh_java">
public class ... {
    ...

    public static void tulostaTaulukko(String[] taulukko) {
        int indeksi = 0;

        while(indeksi &lt; taulukko.length) {
            System.out.println(taulukko[indeksi]);
            indeksi++;
        }
    }
}
    </pre>

    <p>Metodissa <code>tulostaTaulukko()</code> luodaan apumuuttuja <code>indeksi</code> jota käytetään taulukon läpikäynnissä. Muuttuja <code>indeksi</code> on olemassa vain metodin suorituksen ajan.</p>


    <div class="tehtavat">
      <div class="tehtava">
        <h3>Tavara, Matkalaukku ja Lastiruuma</h3>

        <p>Tässä tehtäväsarjassa tehdään luokat <code>Tavara</code>, <code>Matkalaukku</code> ja <code>Lastiruuma</code>, joiden avulla harjoitellaan olioita, jotka sisältävät toisia olioita.</p>

        <h4  >Tavara-luokka</h4>

        <p>Tee luokka <code>Tavara</code>, josta muodostetut oliot vastaavat erilaisia tavaroita. Tallennettavat tiedot ovat tavaran nimi ja paino (kg).</p>

        <p>Lisää luokkaan seuraavat metodit:</p>

        <ul>
          <li>Konstruktori, jolle annetaan parametrina tavaran nimi ja paino</li>
          <li>Metodi <code>public String getNimi()</code>, joka palauttaa tavaran nimen</li>
          <li>Metodi <code>public int getPaino()</code>, joka palauttaa tavaran painon</li>
          <li>Metodi <code>public String toString()</code>, joka palauttaa merkkijonon muotoa "nimi (paino kg)"</li>
        </ul>

        <p>Seuraavassa on luokan käyttöesimerkki:</p>

        <pre class="sh_java">
public class Main {
    public static void main(String[] args) {
        Tavara kirja = new Tavara("Aapiskukko", 2);
        Tavara puhelin = new Tavara("Nokia 3210", 1);

        System.out.println("Kirjan nimi: " + kirja.getNimi());
        System.out.println("Kirjan paino: " + kirja.getPaino());

        System.out.println("Kirja: " + kirja);
        System.out.println("Puhelin: " + puhelin);
    }
}
        </pre>

        <p>Ohjelman tulostuksen tulisi olla seuraava:</p>

        <pre>
Kirjan nimi: Aapiskukko
Kirjan paino: 2
Kirja: Aapiskukko (2 kg)
Puhelin: Nokia 3210 (1 kg)
        </pre>

        <h4  >Matkalaukku-luokka</h4>

        <p>Tee luokka <code>Matkalaukku</code>. Matkalaukkuun liittyy tavaroita ja maksimipaino, joka määrittelee tavaroiden suurimman mahdollisen yhteispainon.</p>

        <p>Lisää luokkaan seuraavat metodit:</p>

        <ul>
          <li> Konstruktori, jolle annetaan maksimipaino</li>
          <li> Metodi <code>public void lisaaTavara(Tavara tavara)</code>, joka lisää parametrina annettavan tavaran matkalaukkuun. Metodi ei palauta mitään arvoa.</li>
          <li> Metodi <code>public String toString()</code>, joka palauttaa merkkijonon muotoa "x tavaraa (y kg)"</li>
        </ul>

        <p>Tavarat kannattaa tallentaa <code>ArrayList</code>-olioon:</p>

        <pre class="sh_java">
ArrayList&lt;Tavara&gt; tavarat = new ArrayList&lt;Tavara&gt;();
        </pre>

        <p>Luokan <code>Matkalaukku</code> tulee valvoa, että sen sisältämien tavaroiden yhteispaino ei ylitä maksimipainoa. Jos maksimipaino ylittyisi lisättävän tavaran vuoksi, metodi <code>lisaaTavara</code> ei saa lisätä uutta tavaraa laukkuun.</p>

        <p>Seuraavassa on luokan käyttöesimerkki:</p>

        <pre class="sh_java">
public class Main {
    public static void main(String[] args) {
        Tavara kirja = new Tavara("Aapiskukko", 2);
        Tavara puhelin = new Tavara("Nokia 3210", 1);
        Tavara tiiliskivi = new Tavara("tiiliskivi", 4);

        Matkalaukku matkalaukku = new Matkalaukku(5);
        System.out.println(matkalaukku);

        matkalaukku.lisaaTavara(kirja);
        System.out.println(matkalaukku);

        matkalaukku.lisaaTavara(puhelin);
        System.out.println(matkalaukku);

        matkalaukku.lisaaTavara(tiiliskivi);
        System.out.println(matkalaukku);
    }
}
        </pre>

        <p>Ohjelman tulostuksen tulisi olla seuraava:</p>

        <pre>
0 tavaraa (0 kg)
1 tavaraa (2 kg)
2 tavaraa (3 kg)
2 tavaraa (3 kg)
        </pre>

        <h4>Kielenhuoltoa</h4>

        <p>Ilmoitukset "0 tavaraa" ja "1 tavaraa" eivät ole kovin hyvää suomea &ndash; paremmat muodot olisivat "ei tavaroita" ja "1 tavara". Tee tämä muutos luokkaan <code>Matkalaukku</code>.</p>

        <p>Nyt edellisen ohjelman tulostuksen tulisi olla seuraava:</p>

        <pre>
ei tavaroita (0 kg)
1 tavara (2 kg)
2 tavaraa (3 kg)
2 tavaraa (3 kg)
        </pre>

        <h4>Kaikki tavarat</h4>

        <p>Lisää luokkaan <code>Matkalaukku</code> seuraavat metodit:</p>

        <ul>
          <li> metodi <code>tulostaTavarat</code>, joka tulostaa kaikki matkalaukussa olevat tavarat</li>
          <li> metodi <code>yhteispaino</code>, joka palauttaa tavaroiden yhteispainon</li>
        </ul>

        <p>Seuraavassa on luokan käyttöesimerkki:</p>

        <pre class="sh_java">
public class Main {
    public static void main(String[] args) {
        Tavara kirja = new Tavara("Aapiskukko", 2);
        Tavara puhelin = new Tavara("Nokia 3210", 1);
        Tavara tiiliskivi = new Tavara("tiiliskivi", 4);

        Matkalaukku matkalaukku = new Matkalaukku(10);
        matkalaukku.lisaaTavara(kirja);
        matkalaukku.lisaaTavara(puhelin);
        matkalaukku.lisaaTavara(tiiliskivi);

        System.out.println("Matkalaukussa on seuraavat tavarat:");
        matkalaukku.tulostaTavarat();
        System.out.println("Yhteispaino: " + matkalaukku.yhteispaino() + " kg");
    }
}
        </pre>

        <p>Ohjelman tulostuksen tulisi olla seuraava:</p>

        <pre>
Matkalaukussa on seuraavat tavarat:
Aapiskukko (2 kg)
Nokia 3210 (1 kg)
Tiiliskivi (4 kg)
Yhteispaino: 7 kg
        </pre>


        <p>Muokkaa myös luokkaasi siten, että käytät vain kahta oliomuuttujaa. Toinen sisältää maksimipainon, toinen on lista laukussa olevista tavaroista.</p>

        <h4>Raskain tavara</h4>

        <p>Lisää vielä luokkaan <code>Matkalaukku</code> metodi <code>raskainTavara</code>, joka palauttaa painoltaan suurimman tavaran. Jos yhtä raskaita tavaroita on useita, metodi voi palauttaa minkä tahansa niistä. Metodin tulee palauttaa olioviite. Jos laukku on tyhjä, palauta arvo <em>null</em>.</p>

        <p>Seuraavassa on luokan käyttöesimerkki:</p>

        <pre class="sh_java">
public class Main {
    public static void main(String[] args) {
        Tavara kirja = new Tavara("Aapiskukko", 2);
        Tavara puhelin = new Tavara("Nokia 3210", 1);
        Tavara tiiliskivi = new Tavara("Tiiliskivi", 4);

        Matkalaukku matkalaukku = new Matkalaukku(10);
        matkalaukku.lisaaTavara(kirja);
        matkalaukku.lisaaTavara(puhelin);
        matkalaukku.lisaaTavara(tiiliskivi);

        Tavara raskain = matkalaukku.raskainTavara();
        System.out.println("Raskain tavara: " + raskain);
    }
}
        </pre>

        <p>Ohjelman tulostuksen tulisi olla seuraava:</p>

        <pre>
Raskain tavara: Tiiliskivi (4 kg)
        </pre>

        <h4>Lastiruuma-luokka</h4>

        <p>Tee luokka <code>Lastiruuma</code>, johon liittyvät seuraavat metodit:</p>

        <ul>
          <li> konstruktori, jolle annetaan maksimipaino</li>
          <li> metodi <code>public void lisaaMatkalaukku(Matkalaukku laukku)</code>, joka lisää parametrina annetun matkalaukun lastiruumaan</li>
          <li> metodi <code>public String toString()</code>, joka palauttaa merkkijonon muotoa "x matkalaukkua (y kg)"</li>
        </ul>

        <p>Tallenna matkalaukut sopivaan <code>ArrayList</code>-rakenteeseen.</p>

        <p>Luokan <code>Lastiruuma</code> tulee valvoa, että sen sisältämien matkalaukkujen yhteispaino ei ylitä maksimipainoa. Jos maksimipaino ylittyisi uuden matkalaukun vuoksi, metodi <code>lisaaMatkalaukku</code> ei saa lisätä uutta matkalaukkua.</p>

        <p>Seuraavassa on luokan käyttöesimerkki:</p>

        <pre class="sh_java">
public class Main {
    public static void main(String[] args) {
        Tavara kirja = new Tavara("Aapiskukko", 2);
        Tavara puhelin = new Tavara("Nokia 3210", 1);
        Tavara tiiliskivi = new Tavara("tiiliskivi", 4);

        Matkalaukku matinLaukku = new Matkalaukku(10);
        matinLaukku.lisaaTavara(kirja);
        matinLaukku.lisaaTavara(puhelin);

        Matkalaukku pekanLaukku = new Matkalaukku(10);
        pekanLaukku.lisaaTavara(tiiliskivi);

        Lastiruuma lastiruuma = new Lastiruuma(1000);
        lastiruuma.lisaaMatkalaukku(matinLaukku);
        lastiruuma.lisaaMatkalaukku(pekanLaukku);

        System.out.println(lastiruuma);
    }
}
        </pre>

        <p>Ohjelman tulostuksen tulisi olla seuraava:</p>

        <pre>
2 matkalaukkua (7 kg)
        </pre>

        <h4  >Lastiruuman sisältö</h4>

        <p>Lisää luokkaan <code>Lastiruuma</code> metodi <code>public void tulostaTavarat()</code>, joka tulostaa kaikki lastiruuman matkalaukuissa olevat tavarat.</p>

        <p>Seuraavassa on luokan käyttöesimerkki:</p>

        <pre class="sh_java">
public class Main {
    public static void main(String[] args) {
        Tavara kirja = new Tavara("Aapiskukko", 2);
        Tavara puhelin = new Tavara("Nokia 3210", 1);
        Tavara tiiliskivi = new Tavara("tiiliskivi", 4);

        Matkalaukku matinLaukku = new Matkalaukku(10);
        matinLaukku.lisaaTavara(kirja);
        matinLaukku.lisaaTavara(puhelin);

        Matkalaukku pekanLaukku = new Matkalaukku(10);
        pekanLaukku.lisaaTavara(tiiliskivi);

        Lastiruuma lastiruuma = new Lastiruuma(1000);
        lastiruuma.lisaaMatkalaukku(matinLaukku);
        lastiruuma.lisaaMatkalaukku(pekanLaukku);

        System.out.println("Ruuman matkalaukuissa on seuraavat tavarat:");
        lastiruuma.tulostaTavarat();
    }
}
        </pre>

        <p>Ohjelman tulostuksen tulisi olla seuraava:</p>

        <pre>
Ruuman matkalaukuissa on seuraavat tavarat:
Aapiskukko (2 kg)
Nokia 3210 (1 kg)
tiiliskivi (4 kg)
        </pre>

        <h4>Paljon tiiliskiviä</h4>

        <p>Testataan vielä, että lastiruuman toiminta on oikea eikä maksimipaino pääse ylittymään. Tee Main-luokkaan metodi <code>public static void lisaaMatkalaukutTiiliskivilla(Lastiruuma lastiruuma)</code>, joka lisää parametrina annettuun lastiruumaan 100 matkalaukkua, joissa jokaisessa on yksi tiiliskivi. Tiiliskivien painot ovat 1, 2, 3, ..., 100 kg.</p>

        <p>Ohjelman runko on seuraava:</p>

        <pre class="sh_java">
public class Main {
    public static void main(String[] args) {
        Lastiruuma lastiruuma = new Lastiruuma(1000);
        lisaaMatkalaukutTiiliskivilla(lastiruuma);
        System.out.println(lastiruuma);
    }

    public static void lisaaMatkalaukutTiiliskivilla(Lastiruuma lastiruuma) {
        // 100 matkalaukun lisääminen, jokaiseen tulee tiiliskivi
    }
}
        </pre>

        <p>Ohjelman tulostus on seuraava:</p>

        <pre>
44 matkalaukkua (990 kg)
        </pre>

      </div>
    </div>

    <h2 id="hashmap">Hajautustaulu (HashMap)</h2>

    <p><a href="http://docs.oracle.com/javase/6/docs/api/java/util/HashMap.html">Hajautustaulu</a> on yksi Javan yleishyödyllisistä tietorakenteista. Hajautustaulun ideana on laskea olioon liittyvälle <em>avaimelle</em>, eli yksilöivälle arvolle (esimerkiksi henkilötunnus, opiskelijanumero, puhelinnumero), indeksi hajautustaulun sisältämästä taulukosta. Indeksin avulla Avaimen muuttamista indeksiksi kutsutaan <em>hajautukseksi</em>, joka tarkoittaa indeksin laskemista. Hajautus tapahtuu aina tietyn hajautusfunktion avulla, joka takaa että tietyllä avaimella saadaan aina sama indeksi.</p>

    <p>Avaimen perusteella lisääminen ja hakeminen mahdollistaa erittäin nopean hakemisen. Sen sijaan että tutkisimme taulukon alkiot järjestyksessä (pahimmassa tapauksessa joudumme käymään kaikki alkiot läpi), tai etsisimme arvoa binäärihaulla (pahimmassa tapauksessa käymme taulukon kokoon liittyvän logaritmisen määrän alkoita läpi), voimme periaatteessa katsoa tasan yhtä taulukon indeksiä ja tarkistaa onko indeksiin tallennettu arvoa vai ei.</p>

    <p>Hajautustaulu käyttää avaimen arvon laskemiseen <code>Object</code>-luokassa määriteltyä <code>hashCode()</code>-metodia, jonka jokainen toteutettu luokka <em>perii</em>. Emme kuitenkaan tutustu hajautustaulun toteutukseen tarkemmin tällä kurssilla. Perintään tutustumme muutaman viikon kuluttua.</p>


    <p>Javan luokka <code>HashMap</code> kapseloi eli piilottaa hajautustaulun toteutuksen, ja tarjoaa valmiit metodit sen käyttöön.</p>

    <p>Hajautustaulua luodessa tarvitaan kaksi <em>tyyppiparametria</em>, avainmuuttujan tyyppi ja tallennettavan olion tyyppi. Seuraava esimerkki käyttää avaimena <code>String</code>-tyyppistä oliota, ja tallennettavana oliona <code>String</code>-tyyppistä oliota. </p>


    <pre class="sh_java">
HashMap&lt;String, String&gt; numerot = new HashMap&lt;String, String&gt;();
numerot.put("Yksi", "Uno");
numerot.put("Kaksi", "Dos");

String kaannos = numerot.get("Yksi");
System.out.println(kaannos);

System.out.println(numerot.get("Kaksi"));
System.out.println(numerot.get("Kolme"));
System.out.println(numerot.get("Uno"));
    </pre>

    <pre>
Uno
Dos
null
null
    </pre>


    <p>Esimerkissä luodaan hajatustaulu, jonka avaimena ja tallennettavana oliona merkkijono. Hajautustauluun lisätään tietoa <code>put()</code>-metodilla, joka saa parametreikseen viitteet avaimeen ja tallennettavaan olioon. Metodi <code>get()</code>-palauttaa parametrina annettuun avaimeen liittyvän viitteen tai arvon <code>null</code> jos avaimella ei löydy viitettä.</p>

    <p>Hajautustaulussa tiettyä avainta vastaa aina yksi arvo. Jos jo olemassaolevalla avaimella tallennetaan uusi arvo, katoaa vanha arvo hajautustaulusta.</p>

    <pre class="sh_java">
HashMap&lt;String, String&gt; numerot = new HashMap&lt;String, String&gt;();
numerot.put("Yksi", "Uno");
numerot.put("Kaksi", "Dos");
numerot.put("Yksi", "Ein");

String kaannos = numerot.get("Yksi");
System.out.println(kaannos);

System.out.println(numerot.get("Kaksi"));
System.out.println(numerot.get("Kolme"));
System.out.println(numerot.get("Uno"));
    </pre>

    <p>Koska avain "<code>Yksi</code>" asetetaan uudestaan, on esimerkin tulostus nyt seuraavanlainen.</p>

    <pre>
Ein
Dos
null
null
    </pre>

    <div class="tehtavat">
      <div class="tehtava">
        <h3>Lempinimet</h3>

        <p>Luo <code>main</code>-metodissa
        uusi <code>HashMap&lt;String,String&gt;</code>-olio. Tallenna tähän
        HashMappiin seuraavien henkilöiden nimet ja lempinimet niin, että
        nimi on avain ja lempinimi on arvo. Käytä pelkkiä pieniä kirjaimia.</p>

        <ul>
          <li>matin lempinimi on mage</li>
          <li>mikaelin lempinimi on mixu</li>
          <li>arton lempinimi on arppa</li>
        </ul>

        <p>Tämän jälkeen hae HashMapistä mikaelin lempinimi ja tulosta se.</p>

        <p>Testit edellyttävät että kirjoitat nimet pienellä alkukirjaimella.</p>

      </div>
    </div>
    <h3 id="kirjastotietokanta">Kirjojen haku hajautustaulun avulla</h3>

    <p>Tutkitaan hajautustaulun toimintaa seuraavaksi kirjastoesimerkin avulla. Kirjastosta voi hakea kirjoja kirjan nimen perusteella, nimi toimii siis kirjan avaimena. Jos annetulle nimelle löytyy kirja, saadaan siihen liittyvä viite ja samalla kirjan tiedot. Luodaan ensin esimerkkiluokka <code>Kirja</code>, jolla on oliomuuttujina nimi ja kirjaan liittyvä sisältö.</p>

    <pre class="sh_java">
public class Kirja {
    private String nimi;
    private String sisalto;
    private int julkaisuvuosi;

    public Kirja(String nimi, int julkaisuvuosi, String sisalto) {
        this.nimi = nimi;
        this.julkaisuvuosi = julkaisuvuosi;
        this.sisalto = sisalto;
    }

    public String getNimi() {
        return this.nimi;
    }

    public void setNimi(String nimi) {
        this.nimi = nimi;
    }

    public int getJulkaisuvuosi() {
        return this.julkaisuvuosi;
    }

    public void setJulkaisuvuosi(int julkaisuvuosi) {
        this.julkaisuvuosi = julkaisuvuosi;
    }

    public String getSisalto() {
        return this.sisalto;
    }

    public void setSisalto(String sisalto) {
        this.sisalto = sisalto;
    }

    public String toString() {
        return "Nimi: " + this.nimi + " (" + this.julkaisuvuosi + ")\n"
                + "Sisältö: " + this.sisalto;
    }
}
    </pre>

    <p>Luodaan seuraavaksi hajautustaulu, joka käyttää avaimena kirjan nimeä eli String-tyyppistä oliota, ja tallentaa viitteitä <code>Kirja</code>-olioihin.</p>

    <pre class="sh_java">
HashMap&lt;String, Kirja&gt; kirjahakemisto = new HashMap&lt;String, Kirja&gt;();
    </pre>

    <p>Yllä oleva hajautustaulu käyttää avaimena <code>String</code>-oliota. Laajennetaan esimerkkiä siten, että kirjahakemistoon lisätään kaksi kirjaa, <code>"Järki ja tunteet"</code> ja <code>"Ylpeys ja ennakkoluulo"</code>.</p>

    <pre class="sh_java">
Kirja jarkiJaTunteet = new Kirja("Järki ja tunteet", 1811, "...");
Kirja ylpeysJaEnnakkoluulo = new Kirja("Ylpeys ja ennakkoluulo", 1813, "....");

HashMap&lt;String, Kirja&gt; kirjahakemisto = new HashMap&lt;String, Kirja&gt;();
kirjahakemisto.put(jarkiJaTunteet.getNimi(), jarkiJaTunteet);
kirjahakemisto.put(ylpeysJaEnnakkoluulo.getNimi(), ylpeysJaEnnakkoluulo);
    </pre>

    <p>Kirjahakemistosta voi hakea kirjoja kirjan nimellä. Haku kirjalla <code>"Viisasteleva sydän"</code> ei tuota osumaa, jolloin hajautustaulu palauttaa <code>null</code>-viitteen. Kirja "Ylpeys ja ennakkoluulo" kuitenkin löytyy.</p>

    <pre class="sh_java">
Kirja kirja = kirjahakemisto.get("Viisasteleva sydän");
System.out.println(kirja);
System.out.println();
kirja = kirjahakemisto.get("Ylpeys ja ennakkoluulo");
System.out.println(kirja);
    </pre>

    <pre>
null

Nimi: Ylpeys ja ennakkoluulo (1813)
Sisältö: ...
    </pre>

    <p>Hajautustaulu on hyödyllinen silloin kun tiedetään avain minkä perusteella halutaan hakea. Avaimet ovat aina yksilöllisiä, joten saman avaimen taakse ei voi tallettaa montaa eri oliota. Tallennettava olio voi toki olla lista tai toinen hajautustaulukko!</p>

    <h3 id="kapseloitu_kirjasto">Kirjasto</h3>

    <p>
    Yllä olevan kirjahakemiston ongelmana on se, että kirjoja haettaessa täytyy muistaa kirjan nimi merkki merkiltä oikein. Javan valmis <code>String</code>-luokka tarjoaa meille välineet tähänkin. Metodi <code>toLowerCase()</code> muuttaa merkkijonon kirjaimet pieniksi, ja metodi <code>trim()</code> poistaa merkkijonon alusta ja lopusta tyhjät merkit (esimerkiksi välilyönnit). Tietokoneen käyttäjät usein kirjoittavat tekstin alkuun tai loppuun vahingossa välilyöntejä.
    </p>

    <pre class="sh_java">
String teksti = "Ylpeys ja ennakkoluulo ";
teksti = teksti.toLowerCase(); // teksti nyt "ylpeys ja ennakkoluulo "
teksti = teksti.trim() // teksti nyt "ylpeys ja ennakkoluulo"
    </pre>

    <p>Luodaan luokka <code>Kirjasto</code>, joka kapseloi kirjat sisältävän hajautustaulun ja mahdollistaa kirjoitusasusta riippumattoman kirjojen haun. Lisätään <code>Kirjasto</code>-luokalle metodit <code>lisaaKirja(Kirja kirja)</code> ja <code>poistaKirja(String kirjanNimi)</code>. Huomaamme jo nyt että merkkijonon siistimistä tarvitsisi useammassa metodissa, joten tehdään siitä erillinen metodi <code>private String siistiMerkkijono(String merkkijono)</code>.</p>

    <pre class="sh_java">
public class Kirjasto {
    private HashMap&lt;String, Kirja&gt; hakemisto;

    public Kirjasto() {
        this.hakemisto = new HashMap&lt;String, Kirja&gt;();
    }

    public void lisaaKirja(Kirja kirja) {
        String nimi = siistiMerkkijono(kirja.getNimi());

        if(this.hakemisto.containsKey(nimi)) {
            System.out.println("Kirja on jo kirjastossa!");
        } else {
            hakemisto.put(nimi, kirja);
        }
    }

    public void poistaKirja(String kirjanNimi) {
        kirjanNimi = siistiMerkkijono(kirjanNimi);

        if(this.hakemisto.containsKey(kirjanNimi)) {
            this.hakemisto.remove(kirjanNimi);
        } else {
            System.out.println("Kirjaa ei löydy, ei voida poistaa!");
        }
    }

    private String siistiMerkkijono(String merkkijono) {
        if (merkkijono == null) {
            return "";
        }

        merkkijono = merkkijono.toLowerCase();
        return merkkijono.trim();
    }
}
    </pre>
    <p>Toteutetaan kirjan hakutoiminnallisuus siten, että kirjaa haetaan hajautusrakenteesta sen nimellä.</p>

    <pre class="sh_java">
    public Kirja haeKirja(String kirjanNimi) {
        kirjanNimi = siistiMerkkijono(kirjanNimi);
        return this.hakemisto.get(kirjanNimi);
    }
    </pre>

    <p>Yllä oleva metodi palauttaa haetun kirjan jos sellainen löytyy, muulloin <code>null</code>-arvon. Voimme myös käydä kaikki hakemiston avaimet läpi  yksitellen, etsien esimerkiksi alkuosaa kirjan nimestä. Tällä tavalla etsiessä menetämme kuitenkin hajautustaulun nopeusedun, sillä huonoimmassa tapauksessa joudumme käymään kaikkien kirjojen nimet läpi. Hakeminen alkuosan perusteella onnistuisi hajautustaulun <code>keySet()</code>-metodin avulla. Metodi <code>keySet()</code> palauttaa avaimet joukossa, jonka voi käydä läpi <code>for-each</code> -toistolauseella.</p>

    <pre class="sh_java">
    public Kirja haeKirjaNimenAlkuosalla(String kirjanAlkuosa) {
        kirjanAlkuosa = siistiMerkkijono(kirjanAlkuosa);

        for (String avain: this.hakemisto.keySet()) {
            if (avain.startsWith(kirjanAlkuosa)) {
                return this.hakemisto.get(avain);
            }
        }

        return null;
    }
    </pre>

    <p>Jätämme yllä olevan metodin kuitenkin pois kirjastostamme. Kirjastosta puuttuu oleellisista toiminnoista vielä kirjojen listaaminen. Luodaan metodi <code>public ArrayList&lt;Kirja&gt; kirjalista()</code>, joka palauttaa listan kirjaston kirjoista. Metodi <code>kirjalista</code> hyödyntää hajautustaulun tarjoamaa <code>values()</code>-metodia. Metodi <code>values()</code> palauttaa kokoelman kirjaston kirjoista, jonka voi antaa parametrina <code>ArrayList</code>-luokan konstruktorille.</p>

    <pre class="sh_java">
public class Kirjasto {
    private HashMap&lt;String, Kirja&gt; hakemisto;

    public Kirjasto() {
        this.hakemisto = new HashMap&lt;String, Kirja&gt;();
    }

    public Kirja haeKirja(String kirjanNimi) {
        kirjanNimi = siistiMerkkijono(kirjanNimi);
        return this.hakemisto.get(kirjanNimi);
    }

    public void lisaaKirja(Kirja kirja) {
        String nimi = siistiMerkkijono(kirja.getNimi());

        if(this.hakemisto.containsKey(nimi)) {
            System.out.println("Kirja on jo kirjastossa!");
        } else {
            this.hakemisto.put(nimi, kirja);
        }
    }

    public void poistaKirja(String kirjanNimi) {
        kirjanNimi = siistiMerkkijono(kirjanNimi);

        if(this.hakemisto.containsKey(kirjanNimi)) {
            this.hakemisto.remove(kirjanNimi);
        } else {
            System.out.println("Kirjaa ei löydy, ei voida poistaa!");
        }
    }

    public ArrayList&lt;Kirja&gt; kirjalista() {
        return new ArrayList&lt;Kirja&gt;(this.hakemisto.values());
    }

    private String siistiMerkkijono(String merkkijono) {
        if (merkkijono == null) {
            return "";
        }

        merkkijono = merkkijono.toLowerCase();
        return merkkijono.trim();
    }
}
    </pre>

    <p>Yksi ohjelmoinnin periaatteista on ns. <em>DRY</em>-periaate (Don't Repeat Yourself), jolla pyritään välttämään saman koodin olemista useassa paikassa. Merkkijonon pieneksi muuttaminen ja <em>trimmaus</em>, eli tyhjien merkkien poisto alusta ja lopusta, olisi toistunut useasti kirjastoluokassamme ilman metodia <code>siistiMerkkijono</code>. Toistuvaa koodia ei usein huomaa ennen kuin sitä on jo kirjoittanut, jolloin sitä päätyy koodiin lähes pakosti. Tässä ei kuitenkaan ole mitään pahaa. Tärkeintä on että siistit koodiasi sitä mukaa kun huomaat siistimistä vaativia tilanteita.</p>


    <h3>Alkeistyyppiset muuttujat hajautustaulussa</h3>

    <p>Huomaa että hajautustaulun avain ja tallennettava olio ovat aina viitetyyppisiä. Jos haluat käyttää alkeistyyppisiä muuttujia avaimena tai tallennettavana arvona, on niille olemassa myös viitetyyppiset vastineet. Alla on esitelty muutama.</p>

    <p>
    <table>
      <tr><th>Alkeistyyppi</th><th>Viitetyyppinen vastine</th></tr>
      <tr><td>int</td><td><a href="http://docs.oracle.com/javase/6/docs/api/java/lang/Integer.html" target="_blank">Integer</a></td></tr>
      <tr><td>double</td><td><a href="docs.oracle.com/javase/6/docs/api/java/lang/Double.html" target="_blank">Double</a></td></tr>
      <tr><td>char</td><td><a href="docs.oracle.com/javase/6/docs/api/java/lang/Character.html" target="_blank">Character</a></td></tr>
    </table>
    </p>

    <p>Java oikeastaan kapseloi alkeistyyppiset muuttujat automaattisesti viitetyyppisiksi muuttujiksi tarvittaessa. Vaikka numero <code>1</code> on alkeistyyppinen muuttuja, voit käyttää sitä suoraan <code>Integer</code>-tyyppisenä avaimena seuraavasti.</p>

    <pre class="sh_java">
HashMap&lt;Integer, String&gt; taulu = new HashMap&lt;Integer, String&gt;();
taulu.put(1, "Ole!");
    </pre>

    <p>Alkeistyyppisten muuttujien automaattista muunnosta viitetyyppisiksi kutsutaan Javassa <em>auto-boxingiksi</em>, eli automaattiseksi "laatikkoon" asettamiseksi. Vastaava onnistuu myös toisinpäin. Voimme luoda metodin, joka palauttaa hajautustaulun sisältämän kokonaisluvun. Seuraavassa esimerkissä olevassa metodissa <code>lisaaBongaus</code> tapahtuu automaattinen tyyppimuunnos.</p>


    <pre class="sh_java">
public class Rekisteribongaus {
    private HashMap&lt;String, Integer&gt; bongatut;

    public Rekisteribongaus() {
        this.bongatut = new HashMap&lt;String, Integer&gt;();
    }

    public void lisaaBongaus(String nimi, int numero) {
        this.bongatut.put(nimi, numero);
    }

    public int viimeisinBongaus(String nimi) {
        this.bongatut.get(nimi);
    }
}
    </pre>

    <p>Vaikka hajautustaulu sisältää Integer-tyyppisiä olioita, osaa Java myös muuntaa tietyt viitetyyppiset muuttujat myös niiden alkeistyyppisiksi vastineiksi. Esimerkiksi <code>Integer</code>-oliot muuttuvat tarpeen vaatiessa <code>int</code>-tyyppisiksi muuttujiksi. Tässä piilee kuitenkin vaara!  Jos yritämme muuttaa null-viitettä numeroksi, näemme virheen <em>java.lang.reflect.InvocationTargetException</em>. Kun teemme automaattista muunnosta, tulee varmistaa että muunnettava arvo ei ole null. Yllä olevassa ohjelmassa oleva <code>viimeisinBongaus</code>-metodi tulee korjata esimerkiksi seuraavasti.</p>

    <pre class="sh_java">
    public int viimeisinBongaus(String nimi) {
        if(this.bongatut.containsKey(nimi) {
            return this.bongatut.get(nimi);
        }

        return 0;
    }
    </pre>



    <div class="tehtavat">
      <div class="tehtava">
        <h3>Velkakirja</h3>

        <p>Luo luokka <code>Velkakirja</code>, jolla on seuraavat toiminnot:</p>

        <ul>
          <li> konstruktori <code>public Velkakirja()</code> luo uuden velkakirjan</li>
          <li> metodi <code>public void asetaLaina(String kenelle, double maara)</code> tallettaa velkakirjaan merkinnän lainasta tietylle henkilölle.</li>
          <li> metodi <code>public double paljonkoVelkaa(String kuka)</code> palauttaa velan määrän annetun henkilön nimen perusteella</li>
        </ul>

        <p>Luokkaa käytetään seuraavalla tavalla:</p>

        <pre class="sh_java">
  Velkakirja matinVelkakirja = new Velkakirja();
  matinVelkakirja.asetaLaina("Arto", 51.5);
  matinVelkakirja.asetaLaina("Mikael", 30);

  System.out.println(matinVelkakirja.paljonkoVelkaa("Arto"));
  System.out.println(matinVelkakirja.paljonkoVelkaa("Joel"));
        </pre>

        <p>Yllä oleva esimerkki tulostaisi:</p>

        <pre>
51.5
0
        </pre>

        <p>Ole tarkkana tilanteessa, jossa kysytään velattoman ihmisen velkaa. Kertaa luvun 4.3 lopun esimerkki!</p>

        <p>Huom! Velkakirjan ei tarvitse huomioida vanhoja lainoja. Kun asetat uuden velan henkilölle jolla on vanha velka, vanha velka unohtuu.</p>

        <pre class="sh_java">
  Velkakirja matinVelkakirja = new Velkakirja();
  matinVelkakirja.asetaLaina("Arto", 51.5);
  matinVelkakirja.asetaLaina("Arto", 10.5);

  System.out.println(matinVelkakirja.paljonkoVelkaa("Arto"));
        </pre>

        <pre>
10.5
        </pre>
      </div>
      <div class="tehtava">
        <h3>Sanakirja</h3>

        <p>Tässä tehtäväsarjassa toteutetaan sanakirja, josta voi hakea suomen kielen sanoille englanninkielisiä käännöksiä. Sanakirjan tekemisessä käytetään <code>HashMap</code>-tietorakennetta.</p>

        <h4  >Luokka Sanakirja</h4>

        <p>Toteuta luokka nimeltä <code>Sanakirja</code>. Luokalla on aluksi seuraavat metodit:</p>

        <ul>
          <li> <code>public String kaanna(String sana)</code> metodi palauttaa parametrinsa käännöksen. Jos sanaa ei tunneta, palautetaan <em>null</em>.</li>
          <li> <code>public void lisaa(String sana, String kaannos)</code> metodi lisää sanakirjaan uuden käännöksen</li>
        </ul>

        <p>Toteuta luokka Sanakirja siten, että sen ainoa oliomuuttuja on <code>HashMap</code>-tietorakenne.</p>

        <p>Testaa sanakirjasi toimintaa:</p>

        <pre class="sh_java">
    Sanakirja sanakirja = new Sanakirja();
    sanakirja.lisaa("apina", "monkey");
    sanakirja.lisaa("banaani", "banana");
    sanakirja.lisaa("cembalo", "harpsichord");

    System.out.println(sanakirja.kaanna("apina"));
    System.out.println(sanakirja.kaanna("porkkana"));
        </pre>

        <pre>
monkey
null
        </pre>

        <h4>Sanojen lukumäärä</h4>

        <p>Lisää sanakirjaan metodi <code>public int sanojenLukumaara()</code>, joka palauttaa sanakirjassa olevien sanojen lukumäärän.</p>

        <pre class="sh_java">
    Sanakirja sanakirja = new Sanakirja();
    sanakirja.lisaa("apina", "monkey");
    sanakirja.lisaa("banaani", "banana");
    System.out.println(sanakirja.sanojenLukumaara());

    sanakirja.lisaa("cembalo", "harpsichord");
    System.out.println(sanakirja.sanojenLukumaara());
        </pre>


        <pre>
2
3
        </pre>

        <h4>Kaikkien sanojen listaaminen</h4>

        <p>Lisää sanakirjaan metodi <code>public ArrayList&lt;String&gt; kaannoksetListana()</code> joka palauttaa sanakirjan sisällön listana <i>avain = arvo</i> muotoisia merkkijonoja.</p>

        <pre class="sh_java">
    Sanakirja sanakirja = new Sanakirja();
    sanakirja.lisaa("apina", "monkey");
    sanakirja.lisaa("banaani", "banana");
    sanakirja.lisaa("cembalo", "harpsichord");

    ArrayList&lt;String&gt; kaannokset = sanakirja.kaannoksetListana();
    for(String kaannos: kaannokset) {
        System.out.println(kaannos);
    }
        </pre>

        <pre>
banaani = banana
apina = monkey
cembalo = harpsichord
        </pre>

        <p><strong>Vihje:</strong> saat käytyä kaikki HashMapissa olevat avaimet läpi metodin <code>keySet</code> avulla seuraavasti:</p>

        <pre class="sh_java">
    HashMap&lt;String, String&gt; sanaparit = new HashMap&lt;String, String&gt;();

    sanaparit.put("apina", "eläin");
    sanaparit.put("etelä", "ilmansuunta");
    sanaparit.put("sauerkraut", "ruoka");

    for ( String avain : sanaparit.keySet() ) {
        System.out.print( avain + " " );
    }

    // tulostuu apina etelä sauerkraut
        </pre>



        <h4  >Tekstikäyttöliittymän alku</h4>

        <p>Harjoitellaan tässäkin tehtävässä erillisen tekstikäyttöliittymän tekemistä. Luo luokka <code>Tekstikayttoliittyma</code>, jolla on seuraavat metodit
        <ul>
          <li> konstruktori <code>public Tekstikayttoliittyma(Scanner lukija, Sanakirja sanakirja)</code></li>
          <li> metodi <code>public void kaynnista()</code>, joka käynnistää tekstikäyttöliittymän.</li>
        </ul>
        </p>

        <p>Tekstikäyttöliittymä tallettaa konstruktorin parametrina saamansa lukijan ja sanakirjan oliomuuttujiin. Muita oliomuuttujia ei tarvita.
        <strong>
          Käyttäjän syötteen lukeminen tulee hoitaa konstruktorin parametrina saatua lukija-olioa käyttäen! Myös kaikki käännökset on talletettava  konstruktorin parametrina saatuun sanakirja-olioon. Tekstikäyttöliittymä ei saa luoda olioita itse!
        </strong>
        </p>

        <p><strong>HUOM:</strong> vielä uudelleen edellinen, eli <strong>Tekstikäyttöliittymä ei saa luoda itse skanneria</strong> vaan sen on käytettävä parametrina saamaansa skanneria syötteiden lukemiseen!</p>

        <p>Tekstikäyttöliittymässä tulee aluksi olla vain komento <code>lopeta</code>, joka poistuu tekstikäyttöliittymästä. Jos käyttäjä syöttää jotain muuta, käyttäjälle sanotaan "Tuntematon komento".</p>

        <pre class="sh_java">
    Scanner lukija = new Scanner(System.in);
    Sanakirja sanakirja = new Sanakirja();

    Tekstikayttoliittyma kayttoliittyma = new Tekstikayttoliittyma(lukija, sanakirja);
    kayttoliittyma.kaynnista();
        </pre>

        <pre>
Komennot:
  lopeta - poistuu käyttöliittymästä

Komento: <font color="red">apua</font>
Tuntematon komento.

Komento: <font color="red">lopeta</font>
Hei hei!
        </pre>

        <h4  >Sanojen lisääminen ja kääntäminen</h4>

        <p>Lisää tekstikäyttöliittymälle komennot <code>lisaa</code> ja <code>kaanna</code>. Komento <code>lisaa</code> lisää kysyy käyttäjältä sanaparin ja lisää sen sanakirjaan. Komento <code>kaanna</code> kysyy käyttäjältä sanaa ja tulostaa sen käännöksen.</p>

        <pre class="sh_java">
    Scanner lukija = new Scanner(System.in);
    Sanakirja sanakirja = new Sanakirja();

    Tekstikayttoliittyma kayttoliittyma = new Tekstikayttoliittyma(lukija, sanakirja);
    kayttoliittyma.kaynnista();
        </pre>

        <pre>
Komennot:
  lisaa - lisää sanaparin sanakirjaan
  kaanna - kysyy sanan ja tulostaa sen käännöksen
  lopeta - poistuu käyttöliittymästä

Komento: <font color="red">lisaa</font>
Suomeksi: <font color="red">porkkana</font>
Käännös: <font color="red">carrot</font>

Komento: <font color="red">kaanna</font>
Anna sana: <font color="red">porkkana</font>
Käännös: carrot

Komento: <font color="red">lopeta</font>
Hei hei!
        </pre>

      </div>
    </div>


    <h2>Kohti testauksen automatisointia</h2>

    <p>Ohjelman testaaminen käsin on toivottoman työlästä. Syötteen antaminen on kuitenkin mahdollista automatisoida esimerkiksi syöttämällä Scanner-oliolle luettava merkkijono. Alla on annettu esimerkki siitä, miten yllä olevassa tehtävässä luotua ohjelmaa voi testata automaattisesti.</p>

    <pre class="sh_java">
    String syote = "kaanna\n" + "apina\n"  +
                   "kaanna\n" + "juusto\n" +
                   "lisaa\n"  + "juusto\n" + "cheese\n" +
                   "kaanna\n" + "juusto\n" +
                   "lopeta\n";

    Scanner lukija = new Scanner(syote);
    Sanakirja sanakirja = new Sanakirja();

    Tekstikayttoliittyma kayttoliittyma = new Tekstikayttoliittyma(lukija, sanakirja);
    kayttoliittyma.kaynnista();
    </pre>

    <p>Ohjelma tulostus näyttää vain ohjelman antaman tulostuksen, ei käyttäjän tekemiä komentoja.</p>

    <pre>
Komennot:
  lisaa - lisää sanaparin sanakirjaan
  kaanna - kysyy sanan ja tulostaa sen käännöksen
  lopeta - poistuu käyttöliittymästä

Komento: Anna sana: Tuntematon sana!

Komento: Anna sana: Tuntematon sana!

Komento: Suomeksi: Käännös:
Komento: Anna sana: Käännös: cheese

Komento: Hei hei!
    </pre>

    <p>Merkkijonon antaminen Scanner-luokalle korvaa näppäimistöltä luettavan syötteen merkkijonolla. Merkkijonomuuttujan <code>syote</code> sisältö siis "simuloi" käyttäjän antamaa syötettä. Rivinvaihto syötteeseen merkitään <code>\n</code>:llä. Jokainen yksittäinen rivinvaihtomerkkiin loppuva osa <code>syote</code>-merkkijonossa siis vastaa käyttäjän yhteen nextLine()-komentoon antamaa syötettä.</p>

    <p>Testityötettä on helppo muuttaa, esim. seuraavassa syötetään lisää uusia sanoja sanakirjaan:</p>

    <pre class="sh_java">
    String syote = "lisaa\n"  + "juusto\n" +     "cheese\n" +
                   "lisaa\n"  + "olut\n"   +     "beer\n" +
                   "lisaa\n"  + "kirja\n"  +     "book\n" +
                   "lisaa\n"  + "tietokone\n" +  "computer\n" +
                   "lisaa\n"  + "auto\n"   +     "car\n" +
                   "lopeta\n";
    </pre>

    <p>Kun haluat testata ohjelmasi toimintaa jälleen käsin, vaihda Scanner-olion konstruktorin parametriksi <code>System.in</code>, eli järjestelmän syötevirta.</p>

    <p>Ohjelman toiminnan oikeellisuus pitää edelleen tarkastaa itse ruudulta. Tulostus voi olla aluksi hieman hämmentävää, sillä automatisoitu syöte ei näy ruudulla ollenkaan.</p>

    <p>Lopullinen tavoite on automatisoida myös ohjelman tulostuksen oikeellisuden tarkastaminen niin hyvin, että ohjelman testaus ja testituloksen analysointi onnistuu "nappia painamalla". Palaamme aiheeseen myöhemmin kurssin aikana.</p>




    <h2>Java API</h2>

    <p>Kurssilla käyttämämme Java-ohjelmointikieli koostuu kolmesta osasta. Ensimmäinen osa on ohjelmointikielen  syntaksi ja semantiikka: muuttujien määrittelytapa, kontrollirakenteiden muoto, ja muuttujien ja luokkien rakenne ja niiden toimintatapa. Toinen osa on JVM, eli <em>Java Virtual Machine</em>, jota käytetään ohjelmien suorittamiseen. Java-ohjelmat käännetään <em>tavukoodiksi</em>, jota voidaan suorittaa missä tahansa koneessa olevan JVM:n avulla. Emme oikeastaan ole törmänneet ohjelmien kääntämiseen, sillä ohjelmointiympäristöt tekevät sen ohjelmoijien puolesta. Silloin tällöin ohjelmointiympäristö ei toimi odotetulla tavalla, ja saatamme joutua valitsemaan <em>clean & build</em>, joka poistaa vanhat lähdekoodit ja kääntää ohjelman uudestaan. Kolmantena osana on API (<em>Application Programming Interface</em>), eli ohjelmointirajapinta tai standardikirjasto.</p>

    <p>API on ohjelmointikielen tarjoama joukko valmiita luokkia, joita ohjelmoija voi käyttää omissa projekteissaan. Esimerkiksi luokat <code>ArrayList</code>, <code>Arrays</code>, <code>Collections</code>, ja <code>String</code> ovat kaikki osa Javan valmista APIa. Javan version 7 API-kuvaus löytyy osoitteesta <a href="http://docs.oracle.com/javase/7/docs/api/" target="_blank">http://docs.oracle.com/javase/7/docs/api/</a>. Osoitteessa olevan sivuston vasemmassa laidassa on Javan valmiille luokille luokkakuvaus. Etsiessäsi sivulta luokkaa <code>ArrayList</code>, löydät sivun <a href="http://docs.oracle.com/javase/7/docs/api/java/util/ArrayList.html" target="_blank">http://docs.oracle.com/javase/7/docs/api/java/util/ArrayList.html</a>, joka kuvaa <code>ArrayList</code>-luokan rakenteen, konstruktorit, ja metodit.</p>

    <p>NetBeans osaa näyttää luokkaan liittyvän APIn tarvittaessa. Kun kirjoitat luokan nimen ja lisäät siihen liittyvän import-lauseen, voit klikata luokan nimeä oikealla hiirennapilla ja valita <em>Show Javadoc</em>. Tämä avaa luokkaan liittyvän API-kuvauksen selaimessa.</p>

    <div class="tehtavat">
      <p class="mooc-pakollinen"></p>
      <div class="tehtava pakollinen-hakuun">
        <h3>Lentokenttä</h3>

        <p>Jokaisella viikolla on yksi laajempi tehtävä, jossa pääset vapaasti suunnittelemaan ohjelman rakenteen, käyttöliittymän ulkomuoto ja vaaditut komennot on määritelty ennalta. Ohjelmoinnin jatkokurssin ensimmäinen vapaasti suunniteltava tehtävä on <em>Lentokenttä</em>.</p>

        <p><b>Huom: jotta testit toimisivat, ohjelmasi saa luoda vain yhden Scanner-olion. Älä myöskään käytä staattisia muuttujia, testit suorittavat ohjelman useita kertoja joten staattisiin muuttujiin edellisillä suorituskerroilla jääneet arvot todennäköisesti häiritsevät testien toimintaa!</b></p>

        <p>Lentokenttä-tehtävässä toteutetaan lentokentän hallintasovellus. Lentokentän hallintasovelluksessa hallinnoidaan lentokoneita ja lentoja. Lentokoneista tiedetään aina tunnus ja kapasiteetti. Lennoista tiedetään lennon lentokone, lähtöpaikan tunnus (esim. <a href="http://en.wikipedia.org/wiki/Helsinki_Airport" target="_blank">HEL</a>) ja kohdepaikan tunnus (esim. <a href="http://en.wikipedia.org/wiki/Batman_Airport" target="_blank">BAL</a>).</p>

        <p>Sekä lentokoneita että lentoja voi olla useita. Sama lentokone voi myös lentää useaa eri lentoa (useaa eri reittiä). Sovelluksen tulee toimia kahdessa vaiheessa. Ensin lentokentän työntekijä syöttää lentokoneiden ja lentojen tietoja hallintakäyttöliittymässä.</p>

        <p>Kun käyttäjä poistuu hallintakäyttöliittymässä, avautuu käyttäjälle mahdollisuus lentopalvelun käyttöön. Lentopalvelussa on kolme toimintoa; lentokoneiden tulostaminen, lentojen tulostaminen, ja lentokoneen tietojen tulostaminen. Tämän lisäksi käyttäjä voi poistua ohjelmasta valitsemalla vaihtoehdon <code>x</code>. Jos käyttäjä syöttää epäkelvon komennon, kysytään komentoa uudestaan.</p>


        <pre>
Lentokentän hallinta
--------------------

Valitse toiminto:
[1] Lisää lentokone
[2] Lisää lento
[x] Poistu hallintamoodista
> <font color="red">1</font>
Anna lentokoneen tunnus: <font color="red">HA-LOL</font>
Anna lentokoneen kapasiteetti: <font color="red">42</font>
Valitse toiminto:
[1] Lisää lentokone
[2] Lisää lento
[x] Poistu hallintamoodista
> <font color="red">1</font>
Anna lentokoneen tunnus: <font color="red">G-OWAC</font>
Anna lentokoneen kapasiteetti: <font color="red">101</font>
Valitse toiminto:
[1] Lisää lentokone
[2] Lisää lento
[x] Poistu hallintamoodista
> <font color="red">2</font>
Anna lentokoneen tunnus: <font color="red">HA-LOL</font>
Anna lähtöpaikan tunnus: <font color="red">HEL</font>
Anna kohdepaikan tunnus: <font color="red">BAL</font>
Valitse toiminto:
[1] Lisää lentokone
[2] Lisää lento
[x] Poistu hallintamoodista
> <font color="red">2</font>
Anna lentokoneen tunnus: <font color="red">G-OWAC</font>
Anna lähtöpaikan tunnus: <font color="red">JFK</font>
Anna kohdepaikan tunnus: <font color="red">BAL</font>
Valitse toiminto:
[1] Lisää lentokone
[2] Lisää lento
[x] Poistu hallintamoodista
> <font color="red">2</font>
Anna lentokoneen tunnus: <font color="red">HA-LOL</font>
Anna lähtöpaikan tunnus: <font color="red">BAL</font>
Anna kohdepaikan tunnus: <font color="red">HEL</font>
Valitse toiminto:
[1] Lisää lentokone
[2] Lisää lento
[x] Poistu hallintamoodista
> <font color="red">x</font>

Lentopalvelu
------------

Valitse toiminto:
[1] Tulosta lentokoneet
[2] Tulosta lennot
[3] Tulosta lentokoneen tiedot
[x] Lopeta
> <font color="red">1</font>
G-OWAC (101 henkilöä)
HA-LOL (42 henkilöä)
Valitse toiminto:
[1] Tulosta lentokoneet
[2] Tulosta lennot
[3] Tulosta lentokoneen tiedot
[x] Lopeta
> <font color="red">2</font>
HA-LOL (42 henkilöä) (HEL-BAL)
HA-LOL (42 henkilöä) (BAL-HEL)
G-OWAC (101 henkilöä) (JFK-BAL)

Valitse toiminto:
[1] Tulosta lentokoneet
[2] Tulosta lennot
[3] Tulosta lentokoneen tiedot
[x] Lopeta
> <font color="red">3</font>
Mikä kone: <font color="red">G-OWAC</font>
G-OWAC (101 henkilöä)

Valitse toiminto:
[1] Tulosta lentokoneet
[2] Tulosta lennot
[3] Tulosta lentokoneen tiedot
[x] Lopeta
> <font color="red">x</font>
        </pre>

        <p><strong>Huom1:</strong> Testien kannalta on oleellista että <em>käyttöliittymä</em> toimii <b>täsmälleen</b> kuten yllä kuvattu. Ohjelman tulostamat menut kannattaneekin copypasteta tästä ohjelmakoodiin. Testit eivät oleta, että ohjelmasi on varautunut epäkelpoihin syötteisiin. Tämä tehtävä on kolmen yksittäisen tehtäväpisteen arvoinen.</p>

        <p><strong>Huom2:</strong> älä käytä luokkein nimissä skandeja, ne saattavat aiheuttaa ongelmia testeihin!</p>

        <p><em><strong>Ohjelman tulee käynnistyä kun tehtäväpohjassa oleva main-metodi suoritetaan.</strong></em></p>

        <p><b>Vielä uudelleen varoitus:</b> jotta testit toimisivat, ohjelmasi saa luoda vain yhden Scanner-olion. Älä myöskään käytä staattisia muuttujia, testit suorittavat ohjelman useita kertoja joten staattisiin muuttujiin edellisillä suorituskerroilla jääneet arvot todennäköisesti häiritsevät testien toimintaa!</p>
      </div>

    </div>
  </div>
</section>




<section class="viikkoraja" id="2" >
  <div class="viikkoraja"></div>
  <div class="viikkoraja-mooc" id="Viikko 8" deadline="avautuu kun 85 % viikosta 7 tehty" data-first-chapter-index="38" data-first-exercise-index="116" data-first-week-index="8"  data-first-chapter-index-mooc="39" data-first-exercise-index-mooc="116" data-first-week-index-mooc="8" tekija="Arto Vihavainen, Matti Luukkainen">


    <h2 id="object">Object</h2>

    <p>Kurssilla on jo useampaan otteeseen käytetty metodia <code>public String toString()</code> olion merkkijonoesityksen muodostamiseen esim. tulostuskomennon yhteydessä. Emme ole saaneet selvyyttä <em>miksi</em> Java osaa käyttää kyseistä metodia. Olemattoman metodin kutsuminenhan tuottaa normaalisti virheen. Tutkitaan seuraavaa luokkaa <code>Kirja</code>, jolla ei ole metodia <code>public String toString()</code>, ja ohjelmaa joka yrittää tulostaa <code>Kirja</code>-luokasta luodun olion <code>System.out.println()</code>-komennolla.</p>

    <pre class="sh_java">
public class Kirja {
    private String nimi;
    private int julkaisuvuosi;

    public Kirja(String nimi, int julkaisuvuosi) {
        this.nimi = nimi;
        this.julkaisuvuosi = julkaisuvuosi;
    }

    public String getNimi() {
        return this.nimi;
    }

    public int getJulkaisuvuosi() {
        return this.julkaisuvuosi;
    }
}
    </pre>

    <pre class="sh_java">
Kirja olioKirja = new Kirja("Oliokirja", 2000);
System.out.println(olioKirja);
    </pre>

    <p>Ohjelmamme ei tulosta virheilmoitusta tai kaadu kun annamme <code>Kirja</code>-luokasta tehdyn olion parametrina <code>System.out.println</code>-komennolle. Näemme virheilmoituksen tai kaatumisen sijaan mielenkiintoisen tulosteen. Tuloste sisältää luokan <code>Kirja</code> nimen ja epämääräisen @-merkkiä seuraavan merkkijonon. Huomaa että kutsussa <code>System.out.println(olioKirja)</code> Java tekee oikeasti kutsun <code>System.out.println(olioKirja.toString())</code></p>

    <p>Selitys liittyy Javan luokkien rakenteeseen. Jokainen Javan luokka <em>perii</em> automaattisesti luokan <code><a href="http://docs.oracle.com/javase/6/docs/api/java/lang/Object.html" target="_blank">Object</a></code>, joka sisältää joukon jokaiselle Javan luokalle hyödyllisiä perusmetodeja. Perintä tarkoittaa että oma luokkamme saa käyttöön perittävän luokan määrittelemiä toiminnallisuuksia ja ominaisuuksia. Luokka <code>Object</code> sisältää muun muassa metodin <code>toString</code>, joka periytyy luomiimme luokiin.</p>

    <p>Object-luokassa määritelty <code>toString</code>-metodin tuottama merkkijono ei yleensä ole toivomamme. Tämän takia meidän tulee <em>korvata</em>, eli syrjäyttää metodi omalla toteutuksellamme. Lisätään luokkaan <code>Kirja</code> metodi <code>public String toString()</code>, joka korvaa perityssä <code>Object</code> luokassa olevan metodin <code>toString</code>.</p>

    <pre class="sh_java">
public class Kirja {
    private String nimi;
    private int julkaisuvuosi;

    public Kirja(String nimi, int julkaisuvuosi) {
        this.nimi = nimi;
        this.julkaisuvuosi = julkaisuvuosi;
    }

    public String getNimi() {
        return this.nimi;
    }

    public int getJulkaisuvuosi() {
        return this.julkaisuvuosi;
    }

    @Override
    public String toString() {
        return this.nimi + " (" + this.julkaisuvuosi + ")";
    }
}
    </pre>

    <p>Nyt kun teemme oliosta ilmentymän ja annamme sen tulostusmetodille, näemme luokassa <code>Kirja</code> olevan <code>toString</code>-metodin tuottaman merkkijonon.</p>

    <pre class="sh_java">
Kirja olioKirja = new Kirja("Oliokirja", 2000);
System.out.println(olioKirja);
    </pre>

    <pre>
Oliokirja (2000)
    </pre>

    <p>Luokassa <code>Kirja</code> olevan metodin <code>toString</code> yläpuolella on <em>annotaatio</em> <code>@Override</code>. Annotaatioilla annetaan vinkkejä sekä kääntäjälle että lukijalle siitä, miten metodeihin tulisi suhtautua. Annotaatio <code>@Override</code> antaa vihjeen että annotaatiota seuraava korvaa perityssä luokassa määritellyn metodin. Jos korvattavaan metodiin ei liitetä annotaatiota,
    antaa kääntäjä tilanteesa <em>varoituksen</em>, overriden kirjottamatta jättäminen ei kuitenkaan ole virhe.</p>

    <p>Luokasta <code>Object</code> peritään muitakin hyödyllisiä metodeja. Tutustutaan seuraavaksi metodeihin <code>equals</code> ja <code>hashCode</code>.</p>

    <h3>Metodi equals</h3>

    <p>Metodia <code><a href="http://docs.oracle.com/javase/6/docs/api/java/lang/Object.html#equals(java.lang.Object)" target="_blank">equals</a></code> käytetään kahden olion yhtäsuuruusvertailuun. Metodia on jo käytetty muun muassa <code>String</code>-olioiden yhteydessä.</p>

    <pre class="sh_java">
Scanner lukija = new Scanner(System.in);

System.out.print("Kirjoita salasana: ");
String salasana = lukija.nextLine();

if(salasana.equals("salasana")) {
    System.out.println("Oikein meni!");
} else {
    System.out.println("Pieleen meni!");
}
    </pre>

    <pre>
Kirjoita salasana: <font color="red">mahtiporkkana</font>
Pieleen meni!
    </pre>

    <p>Luokassa <code>Object</code> määritelty <code>equals</code>-metodi tarkistaa onko parametrina annetulla oliolla sama viite kuin oliolla johon verrataan, eli toisinsanoen oletusarvoisesti vertaillaan onko kyse kahdesta <em>samasta</em> oliosta. Jos viite on sama, palauttaa metodi arvon <code>true</code>, muuten <code>false</code>. Tämä selvenee seuraavalla esimerkillä. Luokassa <code>Kirja</code> ei ole omaa <code>equals</code>-metodin toteutusta, joten se käyttää <code>Object</code>-luokassa olevaa toteutusta.</p>

    <pre class="sh_java">
Kirja olioKirja = new Kirja("Oliokirja", 2000);
Kirja toinenOlioKirja = olioKirja;

if (olioKirja.equals(toinenOlioKirja)) {
    System.out.println("Kirjat olivat samat");
} else {
    System.out.println("Kirjat eivät olleet samat");
}

// nyt luodaan saman sisältöinen olio joka kuitenkin on oma erillinen olionsa
toinenOlioKirja = new Kirja("Oliokirja", 2000);

if (olioKirja.equals(toinenOlioKirja)) {
    System.out.println("Kirjat olivat samat");
} else {
    System.out.println("Kirjat eivät olleet samat");
}
    </pre>

    <p>Tulostuu:</p>

    <pre>
Kirjat olivat samat
Kirjat eivät olleet samat
    </pre>

    <p>Vaikka <code>Kirja</code>-olioiden sisäinen rakenne (eli oliomuuttujien arvot) ovat molemmissa tapauksissa täsmälleen samat, vain ensimmäinen vertailu tulostaa merkkijonon "<code>Kirjat olivat samat</code>". Tämä johtuu siitä että vain ensimmäisessä tapauksessa myös viitteet ovat samat eli vertaillaan olioa itseensä. Toisessa vertailussa kyse on kahdesta eri oliosta, vaikka muuttujilla onkin samat arvot.</p>

    <p>Merkkijonojen eli Stringien yhteydessä <code>equals</code> toimii odotetulla tavalla, eli se ilmoittaa kaksi <em>samansisältöistä</em> merkkijonoa "equalseiksi" vaikka kyseessä olisikin kaksi erillistä olioa. String-luokassa onkin korvattu oletusarvoinen <code>equals</code> omalla toteutuksella.</p>

    <p>Haluamme että kirjojen vertailu onnistuu myös nimen ja vuoden perusteella. Korvataan <code>Object</code>-luokassa oleva metodi <code>equals</code> määrittelemällä sille toteutus luokkaan <code>Kirja</code>. Metodin <code>equals</code> tehtävänä on selvittää onko olio sama kuin metodin parametrina saatu olio. Metodi saa parametrina <code>Object</code>-tyyppisen viitteen olion. Määritellään ensin metodi, jonka mielestä kaikki oliot ovat samoja.</p>

    <pre class="sh_java">
    public boolean equals(Object olio) {
        return true;
    }
    </pre>

    <p>Metodimme on varsin optimistinen, joten muutetaan sen toimintaa hieman. Määritellään että oliot eivät ole samoja jos parametrina saatu olio on <em>null</em> tai jos olioiden tyypit eivät ole samat. Olion tyypin saa (<code>Object</code>-luokassa määritellyllä) metodilla <code>getClass()</code>. Muussa tapauksessa oletetaan että oliot ovat samat.</p>

    <pre class="sh_java">
    public boolean equals(Object olio) {
        if (olio == null) {
            return false;
        }

        if (this.getClass() != olio.getClass()) {
            return false;
        }

        return true;
    }
    </pre>

    <p>Metodi <code>equals</code> huomaa eron erityyppisten olioiden välillä, mutta ei vielä osaa erottaa samanlaisia olioita toisistaan. Jotta voisimme verrata nykyistä oliota ja parametrina saatua <code>Object</code>-tyyppisellä parametrilla viitattua olioa, tulee Object-viitteen tyyppiä muuttaa. Viitteen tyyppiä voidaan muuttaa tyyppimuunnoksella jos ja vain jos olion tyyppi on oikeasti sellainen, mihin sitä yritetään muuttaa. Tyyppimuunnos tapahtuu antamalla asetuslauseen oikealla puolella haluttu luokka suluissa, esimerkiksi:</p>

    <pre class="sh_java">
    HaluttuTyyppi muuttuja = (HaluttuTyyppi) vanhaMuuttuja;
    </pre>

    <p>Voimme tehdä tyyppimuunnoksen koska tiedämme olioiden olevan samantyyppisiä, jos ne ovat erityyppisiä yllä oleva metodi <code>getClass</code> palauttaa arvon false. Muunnetaan metodissa <code>equals</code> saatu <code>Object</code>-tyyppinen parametri <code>Kirja</code>-tyyppiseksi, ja todetaan kirjojen olevan eri jos niiden julkaisuvuodet ovat eri. Muuten kirjat ovat vielä samat.</em>

  <pre class="sh_java">
    public boolean equals(Object olio) {
        if (olio == null) {
            return false;
        }

        if (getClass() != olio.getClass()) {
            return false;
        }

        Kirja verrattava = (Kirja) olio;

        if(this.julkaisuvuosi != verrattava.getJulkaisuvuosi()) {
            return false;
        }

        return true;
    }
  </pre>

  <p>Nyt vertailumetodimme osaa erottaa  eri vuosina julkaistut kirjat. Lisätään vielä tarkistus, että kirjojemme nimet ovat samat ja että oman kirjamme nimi ei ole <em>null</em>.</p>

  <pre class="sh_java">
    public boolean equals(Object olio) {
        if (olio == null) {
            return false;
        }

        if (getClass() != olio.getClass()) {
            return false;
        }

        Kirja verrattava = (Kirja) olio;

        if (this.julkaisuvuosi != verrattava.getJulkaisuvuosi()) {
            return false;
        }

        if (this.nimi == null || !this.nimi.equals(verrattava.getNimi())) {
            return false;
        }

        return true;
    }
  </pre>

  <p>Mahtavaa, viimeinkin toimiva vertailumetodi! Alla vielä tämänhetkinen <code>Kirja</code>-luokkamme.</p>

  <pre class="sh_java">
public class Kirja {
    private String nimi;
    private int julkaisuvuosi;

    public Kirja(String nimi, int julkaisuvuosi) {
        this.nimi = nimi;
        this.julkaisuvuosi = julkaisuvuosi;
    }

    public String getNimi() {
        return this.nimi;
    }

    public int getJulkaisuvuosi() {
        return this.julkaisuvuosi;
    }

    @Override
    public String toString() {
        return this.nimi + " (" + this.julkaisuvuosi + ")";
    }

    @Override
    public boolean equals(Object olio) {
        if (olio == null) {
            return false;
        }

        if (getClass() != olio.getClass()) {
            return false;
        }

        Kirja verrattava = (Kirja) olio;

        if (this.julkaisuvuosi != verrattava.getJulkaisuvuosi()) {
            return false;
        }

        if (this.nimi == null || !this.nimi.equals(verrattava.getNimi())) {
            return false;
        }

        return true;
    }
}
  </pre>

  <p>Nyt kirjojen vertailu palauttaa <code>true</code> jos kirjojen sisällöt ovat samat.</p>

  <pre class="sh_java">
Kirja olioKirja = new Kirja("Oliokirja", 2000);
Kirja toinenOlioKirja = new Kirja("Oliokirja", 2000);

if (olioKirja.equals(toinenOlioKirja)) {
    System.out.println("Kirjat olivat samat");
} else {
    System.out.println("Kirjat eivät olleet samat");
}
  </pre>

  <pre>
Kirjat olivat samat
  </pre>

  <h4>Equals ja ArrayList</h4>

  <p>Useat Javan valmiit tietorakenteet käyttävät <code>equals</code>-metodia osana sisäistä hakumekanismiaan. Esimerkiksi luokan <code>ArrayList</code> <code>contains</code>-metodi vertailee olioiden yhtäsuuruutta <code>equals</code>-metodin avulla. Jatketaan aiemmin määrittelemämme <code>Kirja</code>-luokan käyttöä seuraavassa esimerkissä. Jos emme toteuta omissa olioissamme <code>equals</code>-metodia, emme voi käyttää esimerkiksi <code>contains</code>-metodia. Kokeile alla olevaa koodia kahdella erilaisella <code>Kirja</code>-luokalla. Toisessa on <code>equals</code>-metodi, ja toisessa sitä ei ole.</p>

  <pre class="sh_java">
ArrayList&lt;Kirja&gt; kirjat = new ArrayList&lt;Kirja&gt;();
Kirja olioKirja = new Kirja("Oliokirja", 2000);
kirjat.add(olioKirja);

if (kirjat.contains(olioKirja)) {
    System.out.println("Oliokirja löytyi.");
}

olioKirja = new Kirja("Oliokirja", 2000);

if (!kirjat.contains(olioKirja)) {
    System.out.println("Oliokirjaa ei löytynyt.");
}
  </pre>

  <h3>Metodi hashCode</h3>

  <p>Metodi <code>hashCode</code> luo oliosta numeerisen arvon eli hajautusarvon. Numeerista arvoa tarvitaan esimerkiksi
  jos olioa käytetään HashMap:in avaimena.
  Olemme tähän mennessä käyttäneet HashMapin avaimina ainoastaan String- ja Integer-tyyppisiä olioita ja niillä on valmiit sopivasti toteutetut  <code>hashCode</code>-metodit. Luodaan esimerkki jossa näin ei ole: jatketaan kirjojen parissa ja ruvetaan pitämään kirjaa lainassa olevista kirjoista. Päätetään ratkaista kirjanpito HashMapin avulla. Avaimena toimii kirja ja kirjaan liitetty arvo on merkkijono, joka keroo lainaajan nimen:</p>

  <pre class="sh_java">
        HashMap&lt;Kirja, String&gt; lainaajat = new HashMap&lt;Kirja, String&gt;();

        Kirja oliokirja = new Kirja("Oliokirja", 2000);
        lainaajat.put( oliokirja, "Pekka" );
        lainaajat.put( new Kirja("Test Driven Development",1999), "Arto" );

        System.out.println( lainaajat.get( oliokirja ) );
        System.out.println( lainaajat.get( new Kirja("Oliokirja", 2000) );
        System.out.println( lainaajat.get( new Kirja("Test Driven Development", 1999) );
  </pre>

  <p>Tulostuu:</p>

  <pre>
Pekka
null
null
  </pre>

  <p>Löydämme lainaajan hakiessamme samalla oliolla, joka annettiin hajautustaulun <code>put</code>-metodille avaimeksi. Täsmälleen samanlaisella kirjalla mutta eri oliolla haettaessa lainaajaa ei kuitenkaan löydy ja saamme <em>null</em>-viitteen. Syynä on taas <code>Object</code>-luokassa oleva <code>hashCode</code>-metodin oletustoteutus. Oletustoteutus luo indeksin viitteen perusteella eli samansisältöiset mutta eri oliot saavat eri tuloksen hashCode-metodista ja tämän takia olioa ei osata etsiä oikeasta paikasta HashMapia.</p>

  <p>Jotta HashMap toimisi haluamallamme tavalla, eli palauttaisi lainaajan kun avaimeksi annetaan oikean <em>sisältöinen</em> olio (ei välttämässä siis sama olio kuin alkuperäinen avain), on avaimena toimivan luokan ylikirjoitettava metodin <code>equals</code> lisäksi metodi <code>hashCode</code>. Metodi on ylikirjoitettava siten, että se antaa saman numeerisen tuloksen kaikille samansisältöisille olioille. Myös jotkut erisisältöiset oliot saavat saada saman tuloksen hashCode-metodista, on kuitenkin HashMapin tehokkuuden kannalta oleellista, että erisisältöiset oliot saavat mahdollisimman harvoin saman tuloksen.</p>

  <p> Olemme aiemmin käyttäneet <code>String</code>-olioita menestyksekkäästi HashMapin avaimena, joten voimme päätellä että <code>String</code>-luokassa on oma järkevästi toimiva <code>hashCode</code>-toteutus. <em>Delegoidaan</em>, eli siirretään laskemisvastuu <code>String</code>-oliolle.</p>

  <pre class="sh_java">
    public int hashCode() {
        return this.nimi.hashCode();
    }
  </pre>

  <p>Yllä oleva ratkaisu on melko hyvä, mutta jos <code>nimi</code> on <em>null</em>, näemme <code>NullPointerException</code>-virheen. Korjataan tämä vielä määrittelemällä ehto: jos <code>nimi</code>-muuttujan arvo on <em>null</em>, palautetaan arvo 7. Arvo 7 on "satunnaisesti"  valittu alkuluku, yhtä hyvin olisi voitu valita esimerkiksi arvo 13.</p>

  <pre class="sh_java">
    public int hashCode() {
        if (this.nimi == null) {
            return 7;
        }

        return this.nimi.hashCode();
    }
  </pre>

  <p>Parantelemme vielä <code>hashCode</code>-metodia siten, että koodin laskennassa huomioidaan myös kirjan julkaisuvuosi:</p>

  <pre class="sh_java">
    public int hashCode() {
        if (this.nimi == null) {
            return 7;
        }

        return this.julkaisuvuosi + this.nimi.hashCode();
    }
  </pre>


  <p>Sivuhuomautus: HashMapissa avaimina olevien olioiden hashCode-metodin tulos kertoo hajautusrakenteeseen talletettavien arvon paikan eli indeksin hajautustaulussa. Saatat tässä kohtaa miettiä "eikö tämä johda tilanteeseen jossa useampi olio päätyy samaan indeksiin hajautustaulussa?". Vastaus on kyllä ja ei. Vaikka metodi <code>hashCode</code> antaisi kahdelle eri oliolle saman arvon, on hajautustaulut toteutettu sisäisesti siten että useampi olio voi olla samassa indeksissä. Jotta samassa indeksissä olevat oliot voi erottaa toisistaan, tulee hajautustaulun avaimina toimivina olioilla olla metodi <code>equals</code> toteutettuna. Lisätietoa hajautustaulujen toteuttamisen periaatteista tulee kurssilla <em>tietorakenteet ja algoritmit</em>.</p>

  <p>Luokka <code>Kirja</code> nyt kokonaisuudessaan.</p>

  <pre class="sh_java">
public class Kirja {

    private String nimi;
    private int julkaisuvuosi;

    public Kirja(String nimi, int julkaisuvuosi) {
        this.nimi = nimi;
        this.julkaisuvuosi = julkaisuvuosi;
    }

    public String getNimi() {
        return this.nimi;
    }

    public int getJulkaisuvuosi() {
        return this.julkaisuvuosi;
    }

    @Override
    public String toString() {
        return this.nimi + " (" + this.julkaisuvuosi + ")";
    }

    @Override
    public boolean equals(Object olio) {
        if (olio == null) {
            return false;
        }

        if (getClass() != olio.getClass()) {
            return false;
        }

        Kirja verrattava = (Kirja) olio;

        if (this.julkaisuvuosi != verrattava.getJulkaisuvuosi()) {
            return false;
        }

        if (this.nimi == null || !this.nimi.equals(verrattava.getNimi())) {
            return false;
        }

        return true;
    }

    public int hashCode() {
        if (this.nimi == null) {
            return 7;
        }

        return this.julkaisuvuosi + this.nimi.hashCode();
    }
}
  </pre>

  <p><b>Kerrataan vielä:</b> jotta luokkaa voidaan käyttää HashMap:in avaimena, tulee sille määritellä</p>
  <ul>
    <li>metodi <code>equals</code> siten, että kaikki samansisältöisenä ajatellut oliot tuottavat vertailussa tuloksen true ja erisisältöiset false</li>
    <li>metodi <code>hashCode</code> siten, että kaikki samansisältöisenä ajatelluille olioille metodin kutsu tuottaa saman arvon</li>
  </ul>

  <p>Luokalle <code>Kirja</code> määrittelemämme equals ja hashCode selvästi täyttävät nämä ehdot.
  Nyt myös aiemmin kohtaamamme ongelma ratkeaa ja kirjojen lainaajat löytyvät:</p>

  <pre class="sh_java">
        HashMap&lt;Kirja, String&gt; lainaajat = new HashMap&lt;Kirja, String&gt;();

        Kirja oliokirja = new Kirja("Oliokirja", 2000);
        lainaajat.put( oliokirja, "Pekka" );
        lainaajat.put( new Kirja("Test Driven Development",1999), "Arto" );

        System.out.println( lainaajat.get( oliokirja ) );
        System.out.println( lainaajat.get( new Kirja("Oliokirja", 2000) );
        System.out.println( lainaajat.get( new Kirja("Test Driven Development", 1999) );
  </pre>

  <p>Tulostuu:</p>

  <pre>
Pekka
Pekka
Arto
  </pre>

  <p><em>NetBeans tarjoaa metodien <code>equals</code> ja <code>hashCode</code> automaattisen luonnin. Voit valita valikosta Source -> Insert Code, ja valita aukeavasta listasta <em>equals() and hashCode()</em>. Tämän jälkeen NetBeans kysyy oliomuuttujat joita metodeissa käytetään.</em></p>

  <div class="tehtavat" id="viikko8">

    <div class="tehtava">
      <h3>Autorekisterikeskus</h3>

      <h4>Rekisterinumeron equals ja hashCode</h4>

      <p>Eurooppalaiset rekisteritunnukset koostuvat kahdesta osasta: yksi tai kaksikirjaimisesta maatunnuksesta ja maakohtaisesti määrittyvästä rekisterinumerosta, joka taas koostuu numeroista ja merkeistä. Rekisterinumeroita esitetään seuraavanlaisen luokan avulla:</p>

      <pre class="sh_java">
public class Rekisterinumero {
    // HUOM: oliomuuttujissa on määre final eli niiden arvoa ei voi muuttaa!
    private final String rekNro;
    private final String maa;

    public Rekisterinumero(String rekNro, String maa) {
       this.rekNro = rekNro;
       this.maa = maa;
    }

    public String toString(){
        return maa+ " "+rekNro;
    }
}
      </pre>

      <p>Rekisterinumeroja halutaan tallettaa esim. ArrayList:eille ja käyttää HashMap:in avaimina, eli kuten yllä mainittu, tulee niille toteuttaa
      metodit <code>equals</code> ja <code>hashCode</code>, muuten ne eivät toimi halutulla tavalla. </p>

      <p><strong>Vihje:</strong> ota equals- ja hashCode-metodeihin mallia yllä olevasta Kirja-esimerkistä. Rekisterinumeron hashCode voidaan muodostaa esim. maatunnuksen ja rekNro:n hashCodejen summana.</p>

      <p>Esimerkkiohjelma:</p>

      <pre class="sh_java">
    public static void main(String[] args) {
        Rekisterinumero rek1 = new Rekisterinumero("FI", "ABC-123");
        Rekisterinumero rek2 = new Rekisterinumero("FI", "UXE-465");
        Rekisterinumero rek3 = new Rekisterinumero("D", "B WQ-431");

        ArrayList&lt;Rekisterinumero&gt; suomalaiset = new ArrayList&lt;Rekisterinumero&gt;();
        suomalaiset.add(rek1);
        suomalaiset.add(rek2);

        Rekisterinumero uusi = new Rekisterinumero("FI", "ABC-123");
        if (!suomalaiset.contains(uusi)) {
            suomalaiset.add(uusi);
        }
        System.out.println("suomalaiset: " + suomalaiset);
        // jos equals-metodia ei ole ylikirjoitettu, menee sama rekisterinumero toistamiseen listalle

        HashMap&lt;Rekisterinumero, String&gt; omistajat = new HashMap&lt;Rekisterinumero, String&gt;();
        omistajat.put(rek1, "Arto");
        omistajat.put(rek3, "Jürgen");

        System.out.println("omistajat:");
        System.out.println(omistajat.get(new Rekisterinumero("FI", "ABC-123")));
        System.out.println(omistajat.get(new Rekisterinumero("D", "B WQ-431")));
        // jos hashCode ei ole ylikirjoitettu, eivät omistajat löydy
    }
      </pre>

      <p>Jos equals ja hashCode on toteutettu oikein, tulostus on seuraavanlainen</p>

      <pre>
suomalaiset: [FI ABC-123, FI UXE-465]
omistajat:
Arto
Jürgen

      </pre>

      <h4>Omistaja rekisterinumeron perusteella</h4>

      <p>Toteuta luokka <code>Ajoneuvorekisteri</code> jolla on seuraavat metodit:</p>

      <ul>
        <li><code>public boolean lisaa(Rekisterinumero rekkari, String omistaja)</code> lisää parametrina olevaa rekisterinumeroa vastaavalle autolle parametrina olevan omistajan, metodi palauttaa true jos omistajaa ei ollut ennestään, jos rekisterinumeroa vastaavalla autolla oli jo omistaja, metodi palauttaa false ja ei tee mitään</li>
        <li><code>public String hae(Rekisterinumero rekkari)</code> palauttaa parametrina olevaa rekisterinumeroa vastaavan auton omistajan. Jos auto ei ole rekisterissä, palautetaan <code>null</code></li>
        <li><code>public boolean poista(Rekisterinumero rekkari)</code> poistaa parametrina olevaa rekisterinumeroa vastaavat tiedot, metodi palauttaa true jos tiedot poistetiin, ja false jos parametria vastaavia tietoja ei ollut rekisterissä</li>
      </ul>

      <p><strong>Huom:</strong> Ajoneuvorekisterin täytyy tallettaa omistajatiedot <code>HashMap&lt;Rekisterinumero, String&gt; omistajat</code> -tyyppiseen oliomuuttujaan!</p>

      <h4>Ajoneuvorekisteri laajenee</h4>

      <p>Lisää Ajoneuvorekisteriin vielä seuraavat metodit:</p>

      <ul>
        <li><code>public void tulostaRekisterinumerot()</code> tulostaa rekisterissä olevat rekisterinumerot</li>
        <li><code>public void tulostaOmistajat()</code> tulostaa rekisterissä olevien autojen omistajat, yhden omistajan nimeä ei saa tulostaa kuin kertaalleen vaikka omistajalla olisikin useampi auto</li>
      </ul>

    </div>
  </div>
  <h2 id="rajapinta">Rajapinta</h2>

  <p>Rajapinta (engl. <em>interface</em>) on väline luokilta vaaditun käyttäytymisen määrittelyyn. Rajapinnat määritellään kuten normaalit Javan olevat luokat, mutta luokan alussa olevan määrittelyn "<code>public class ...</code>" sijaan käytetään määrittelyä "<code>public interface ...</code>". Rajapinnat määrittelevät käyttäytymisen metodien niminä ja palautusarvoina, mutta ne <em>eivät sisällä metodien toteutusta</em>. Näkyvyysmäärettä ei merkitä erikseen, sillä se on aina <code>public</code>. Tutkitaan luettavuutta kuvaavaa rajapintaa <em>Luettava</em>.</p>

  <pre class="sh_java">
public interface Luettava {
    String lue();
}
  </pre>

  <p>Rajapinta <code>Luettava</code> määrittelee metodin <code>lue()</code>, joka palauttaa String-tyyppisen olion. Rajapinnan toteuttavat luokat päättävät <em>miten</em> rajapinnassa määritellyt metodit lopulta toteutetaan. Luokka toteuttaa rajapinnan lisäämällä luokan nimen jälkeen avainsanalla <em>implements</em>, jota seuraa rajapinnan nimi. Luodaan luokka <code>Tekstiviesti</code>, joka toteuttaa rajapinnan <code>Luettava</code>.</p>

  <pre class="sh_java">
public class Tekstiviesti implements Luettava {
    private String lahettaja;
    private String sisalto;

    public Tekstiviesti(String lahettaja, String sisalto) {
        this.lahettaja = lahettaja;
        this.sisalto = sisalto;
    }

    public String getLahettaja() {
        return this.lahettaja;
    }

    public String lue() {
        return this.sisalto;
    }
}
  </pre>

  <p>Koska luokka <code>Tekstiviesti</code> toteuttaa rajapinnan <code>Luettava</code> (<code>public class Tekstiviesti implements Luettava</code>),  on luokassa <code>Tekstiviesti</code> <em>pakko</em> olla metodin <code>public String lue()</code> toteutus. Rajapinnassa määriteltyjen metodien toteutuksilla tulee aina olla näkyvyysmääre public.</p>

  <p><em>Rajapinta on sopimus käyttäytymisestä. Jotta käyttäytyminen toteutuu, tulee luokan toteuttaa rajapinnan määrittelemät metodit. Rajapinnan toteuttavan luokan ohjelmoijan vastuulla on määritellä millaista käyttäytyminen on. Rajapinnan toteuttaminen tarkoittaa sopimuksen tekemistä siitä, että luokka tarjoaa kaikki rajapinnan määrittelemät toiminnot eli rajapinnan määrittelemän käyttäytymisen. Luokkaa, joka toteuttaa rajapinnan, mutta ei toteuta rajapinnan metodeja, ei voi olla olemassa.</em></p>

  <p>Toteutetaan luokan <code>Tekstiviesti</code> lisäksi toinen <code>Luettava</code> rajapinnan toteuttava luokka. Luokka <code>Sahkokirja</code> on sähköinen toteutus kirjasta, joka sisältää kirjan nimen ja sivut. Sähkökirjaa luetaan sivu kerrallaan, metodin <code>public String lue()</code> kutsuminen palauttaa aina seuraavan sivun merkkijonona.</p>

  <pre class="sh_java">
public class Sahkokirja implements Luettava {
    private String nimi;
    private ArrayList&lt;String&gt; sivut;
    private int sivunumero;

    public Sahkokirja(String nimi, ArrayList&lt;String&gt; sivut) {
        this.nimi = nimi;
        this.sivut = sivut;
        this.sivunumero = 0;
    }

    public String getNimi() {
        return this.nimi;
    }

    public int sivuja() {
        return this.sivut.size();
    }

    public String lue() {
        String sivu = this.sivut.get(this.sivunumero);
        seuraavaSivu();
        return sivu;
    }

    private void seuraavaSivu() {
        this.sivunumero = this.sivunumero + 1;
        if(this.sivunumero % this.sivut.size() == 0) {
            this.sivunumero = 0;
        }
    }
}
  </pre>

  <p>Rajapinnan toteuttavasta luokasta voi tehdä olioita aivan kuten normaaleistakin luokista, ja niitä voidaan käyttää myös esimerkiksi ArrayList-listojen tyyppinä.</p>

  <pre class="sh_java">
    Tekstiviesti viesti = new Tekstiviesti("ope", "Huikeaa menoa!");
    System.out.println(viesti.lue());

    ArrayList&lt;Tekstiviesti&gt; tekstiviestit = new ArrayList&lt;Tekstiviesti&gt;();
    tekstiviestit.add(new Tekstiviesti("tuntematon numero", "I hid the body.");
  </pre>

  <pre>Huikeaa menoa!</pre>

  <pre class="sh_java">
    ArrayList&lt;String&gt; sivut = new ArrayList&lt;String&gt;();
    sivut.add("Pilko metodisi lyhyiksi luettaviksi kokonaisuuksiksi.");
    sivut.add("Erota käyttöliittymälogiikka sovelluksen logiikasta.");
    sivut.add("Ohjelmoi aina ensin pieni ohjelma joka ratkaisee vain osan ongelmasta.");
    sivut.add("Harjoittelu tekee mestarin. Keksi joku hauska oma projekti.");

    Sahkokirja kirja = new Sahkokirja("Vinkkejä ohjelmointiin.", sivut);
    for(int sivu = 0; sivu &lt; kirja.sivuja(); sivu++) {
        System.out.println(kirja.lue());
    }
  </pre>

  <pre>
Pilko metodisi lyhyiksi luettaviksi kokonaisuuksiksi.
Erota käyttöliittymälogiikka sovelluksen logiikasta.
Ohjelmoi aina ensin pieni ohjelma joka ratkaisee vain osan ongelmasta.
Harjoittelu tekee mestarin. Keksi joku hauska oma projekti.
  </pre>

  <div class="tehtavat">
    <div class="tehtava">

      <h3>Palvelusvelvollinen</h3>

      <p>Tehtäväpohjassa on valmiina rajapinta <code>Palvelusvelvollinen</code>, jossa on seuraavat toiminnot:</p>

      <ul>
        <li> metodi <code>int getTJ()</code> palauttaa jäljellä olevien palveluspäivien määrän</li>
        <li> metodi <code>void palvele()</code> vähentää yhden palveluspäivän. Palveluspäivien määrä ei saa mennä negatiiviseksi.</li>
      </ul>

      <pre class="sh_java">
public interface Palvelusvelvollinen {
    int getTJ();
    void palvele();
}
      </pre>

      <h4>Sivari</h4>

      <p>Tee <code>Palvelusvelvollinen</code>-rajapinnan toteuttava luokka <code>Sivari</code>, jolla parametriton konstruktori. Luokalla on oliomuuttuja TJ, joka alustetaan konstruktorikutsun yhteydessä arvoon 362.</p>

      <h4>Asevelvollinen</h4>

      <p>Tee <code>Palvelusvelvollinen</code>-rajapinnan toteuttava luokka <code>Asevelvollinen</code>, jolla on parametrillinen konstruktori, jolla määritellään palvelusaika (<code>int tj</code>).</p>
    </div>
  </div>

  <h3>Rajapinta muuttujan tyyppinä</h3>

  <p>Uutta muuttujaa esitellessä esitellään aina muuttujan tyyppi. Muuttujatyyppejä on kahdenlaisia, alkeistyyppiset muuttujat (int, double, ...) ja viitetyyppiset muuttujat (kaikki oliot). Olemme tähän mennessä käyttäneet viitetyyppisten muuttujien tyyppinä olion luokkaa.</p>

  <pre class="sh_java">
    String merkkijono = "merkkijono-olio";
    Tekstiviesti viesti = new Tekstiviesti("ope", "Kohta tapahtuu huikeita");
  </pre>

  <p>Olion tyyppi voi olla muutakin kuin sen luokka. Esimerkiksi rajapinnan <code>Luettava</code> toteuttavan luokan tyyppi on lisäksi <code>Luettava</code>. Esimerkiksi koska luokka <code>Tekstiviesti</code> toteuttaa rajapinnan <code>Luettava</code>, on sillä tyypin <code>Tekstiviesti</code> lisäksi myös tyyppi <code>Luettava</code>.</p>

  <pre class="sh_java">
    Tekstiviesti viesti = new Tekstiviesti("ope", "Kohta tapahtuu huikeita");
    Luettava luettava = new Tekstiviesti("ope", "Tekstiviesti on Luettava!");
  </pre>

  <pre class="sh_java">
    ArrayList&lt;String&gt; sivut = new ArrayList&lt;String&gt;();
    sivut.add("Metodi voi kutsua itse itseään.");

    Luettava kirja = new Sahkokirja("Rekursion alkeet.", sivut);
    for(int sivu = 0; sivu &lt; kirja.sivuja(); sivu++) {
        System.out.println(kirja.lue());
    }
  </pre>

  <p>Koska rajapintaa voidaan käyttää tyyppinä, on mahdollista luoda rajapintaluokan tyyppisiä olioita sisältävä lista.</p>

  <pre class="sh_java">
    ArrayList&lt;Luettava&gt; lukulista = new ArrayList&lt;Luettava&gt;();

    lukulista.add(new Tekstiviesti("ope", "never been programming before..."));
    lukulista.add(new Tekstiviesti("ope", "gonna love it i think!"));
    lukulista.add(new Tekstiviesti("ope", "give me something more challenging! :)"));
    lukulista.add(new Tekstiviesti("ope", "you think i can do it?"));
    lukulista.add(new Tekstiviesti("ope", "up here we send several messages each day"));

    for (Luettava luettava: lukulista) {
        System.out.println(luettava.lue());
    }
  </pre>

  <p>Huomaa että vaikka rajapinnan <code>Luettava</code> toteuttava luokka <code>Sahkokirja</code> on aina rajapinnan tyyppinen, eivät kaikki <code>Luettava</code>-rajapinnan toteuttavat luokat ole tyyppiä <code>Sahkokirja</code>. Luokasta <code>Sahkokirja</code> tehdyn olion asettaminen <code>Luettava</code>-tyyppiseen muuttujaan onnistuu, mutta toiseen suuntaan asetus ei ole sallittua ilman erillistä tyyppimuunnosta.</p>

  <pre class="sh_java">
    Luettava luettava = new Tekstiviesti("ope", "Tekstiviesti on Luettava!"); // toimii
    Tekstiviesti viesti = luettava; // ei toimi

    Tekstiviesti muunnettuViesti = (Tekstiviesti) luettava; // toimii
  </pre>

  <p>Tyyppimuunnos onnistuu jos ja vain jos muuttuja on oikeastikin sitä tyyppiä johon sitä yritetään muuntaa. Tyyppimuunnoksen käyttöä ei yleisesti suositella, ja lähes ainut sallittu paikka sen käyttöön on <code>equals</code>-metodin toteutuksessa.</p>

  <h3>Rajapinta metodin parametrina</h3>

  <p>Rajapintojen todelliset hyödyt tulevat esille kun niitä käytetään metodille annettavan parametrin tyyppinä. Koska rajapintaa voidaan käyttää muuttujan tyyppinä, voidaan sitä käyttää metodikutsuissa parametrin tyyppinä. Esimerkiksi seuraavan luokan <code>Tulostin</code> metodi <code>tulosta</code> saa parametrina <code>Luettava</code>-tyyppisen muuttujan.</p>

  <pre class="sh_java">
public class Tulostin {
    public void tulosta(Luettava luettava) {
        System.out.println(luettava.lue());
    }
}
  </pre>

  <p>Luokan <code>Tulostin</code> tarjoaman metodin <code>tulosta</code> huikeus piilee siinä, että sille voi antaa parametrina <em>minkä tahansa</em> <code>Luettava</code>-rajapinnan toteuttavan luokan ilmentymän. Kutsummepa metodia millä tahansa Luettava-luokan toteuttaneen luokan oliolla, metodi osaa toimia oikein.</p>

  <pre class="sh_java">
    Tekstiviesti viesti = new Tekstiviesti("ope", "Huhhuh, tää tulostinkin osaa tulostaa näitä!");
    ArrayList&lt;String&gt; sivut = new ArrayList&lt;String&gt;();
    sivut.add("Lukujen {1, 3, 5} ja {2, 3, 4, 5} yhteisiä lukuja ovat {3, 5}.");

    Sahkokirja kirja = new Sahkokirja("Yliopistomatematiikan perusteet.", sivut);

    Tulostin tulostin = new Tulostin();
    tulostin.tulosta(viesti);
    tulostin.tulosta(kirja);
  </pre>

  <pre>
Huhhuh, tää tulostinkin osaa tulostaa näitä!
Lukujen {1, 3, 5} ja {2, 3, 4, 5} yhteisiä lukuja ovat {3, 5}.
  </pre>

  <p>Toteutetaan toinen luokka <code>Lukulista</code>, johon voidaan lisätä mielenkiintoisia luettavia asioita. Luokalla on oliomuuttujana <code>ArrayList</code>-luokan ilmentymä, johon luettavia asioita tallennetaan. Lukulistaan lisääminen tapahtuu <code>lisaa</code>-metodilla, joka saa parametrikseen <code>Luettava</code>-tyyppisen olion.</p>

  <pre class="sh_java">
public class Lukulista {
    private ArrayList&lt;Luettava&gt; luettavat;

    public Lukulista() {
        this.luettavat = new ArrayList&lt;Luettava&gt;();
    }

    public void lisaa(Luettava luettava) {
        this.luettavat.add(luettava);
    }

    public int luettavia() {
        return this.luettavat.size();
    }
}
  </pre>

  <p>Lukulistat ovat yleensä luettavia, joten toteutetaan luokalle <code>Lukulista</code> rajapinta <code>Luettava</code>. Lukulistan <code>lue</code>-metodi lukee kaikki <code>luettavat</code>-listalla olevat oliot läpi, ja lisää yksitellen niiden <code>lue()</code>-metodin palauttaman merkkijonoon.</p>

  <pre class="sh_java">
public class Lukulista implements Luettava {
    private ArrayList&lt;Luettava&gt; luettavat;

    public Lukulista() {
        this.luettavat = new ArrayList&lt;Luettava&gt;();
    }

    public void lisaa(Luettava luettava) {
        this.luettavat.add(luettava);
    }

    public int luettavia() {
        return this.luettavat.size();
    }

    public String lue() {
        String luettu = "";
        for(Luettava luettava: this.luettavat) {
            luettu += luettava.lue() + "\n";
        }

        this.luettavat.clear();
        return luettu;
    }
}
  </pre>

  <pre class="sh_java">
    Lukulista joelinLista = new Lukulista();
    joelinLista.lisaa(new Tekstiviesti("matti", "teitkö jo testit?"));
    joelinLista.lisaa(new Tekstiviesti("matti", "katsoitko jo palautukset?"));

    System.out.println("Joelilla luettavia: " + joelinLista.luettavia());
  </pre>

  <pre>
Joelilla luettavia: 2
  </pre>

  <p>Koska <code>Lukulista</code> on tyyppiä <code>Luettava</code>, voi lukulistalle lisätä <code>Lukulista</code>-olioita. Alla olevassa esimerkissä Joelilla on paljon luettavaa. Onneksi Mikael tulee hätiin ja lukee viestit Joelin puolesta.</p>

  <pre class="sh_java">
    Lukulista joelinLista = new Lukulista();
    for (int i = 0; i &lt; 1000; i++) {
        joelinLista.lisaa(new Tekstiviesti("matti", "teitkö jo testit?"));
    }

    System.out.println("Joelilla luettavia: " + joelinLista.luettavia());
    System.out.println("Delegoidaan lukeminen Mikaelille");

    Lukulista mikaelinLista = new Lukulista();
    mikaelinLista.lisaa(joelinLista);
    mikaelinLista.lue();

    System.out.println();
    System.out.println("Joelilla luettavia: " + joelinLista.luettavia());
  </pre>

  <pre>
Joelilla luettavia: 1000
Delegoidaan lukeminen Mikaelille

Joelilla luettavia: 0
  </pre>

  <p>Ohjelmassa Mikaelin listalle kutsuttu <code>lue</code>-metodi käy kaikki sen sisältämät <code>Luettava</code>-oliot läpi, ja kutsuu niiden <code>lue</code>-metodia. Kutsuttaessa <code>lue</code>-metodia Mikaelin listalle käydään myös Mikaelin lukulistalla oleva Joelin lukulista läpi. Joelin lukulista käydään läpi kutsumalla sen <code>lue</code>-metodia. Jokaisen <code>lue</code>-metodin kutsun lopussa tyhjennetään juuri luettu lista. Eli Joelin lukulista tyhjenee kun Mikael lukee sen.</p>

  <p><em>Tässä on jo hyvin paljon viitteitä, kannattaa piirtää oliot paperille ja hahmotella miten <code>mikaelinLista</code>-oliolle tapahtuva metodikutsu <code>lue</code> etenee!</em></p>

  <div class="tehtavat">
    <div class="tehtava">
      <h3>Tavaroita ja laatikoita</h3>

      <h4  >Talletettavia</h4>

      <p>Muuton yhteydessa tarvitaan muuttolaatikoita. Laatikoihin talletetaan erilaisia esineitä. Kaikkien laatikoihin talletettavien esineiden on toteutettava seuraava rajapinta:</p>

      <pre class="sh_java">
public interface Talletettava {
    double paino();
}
      </pre>

      <p>Lisää rajapinta ohjelmaasi. Rajapinta lisätään melkein samalla tavalla kuin luokka, <i>new Java class</i> sijaan valitaan <i>new Java interface</i>.</p>

      <p>Tee rajapinnan toteuttavat luokat <code>Kirja</code> ja <code>CDLevy</code>. Kirja saa konstruktorin parametreina kirjan kirjoittajan (String), kirjan nimen (String), ja kirjan painon (double). CD-Levyn konstruktorin parametreina annetaan artisti (String), levyn nimi (String), ja julkaisuvuosi (int). Kaikkien CD-levyjen paino on 0.1 kg.</p>

      <p>Muista toteuttaa luokilla myös rajapinta <code>Talletettava</code>. Luokkien tulee toimia seuraavasti:</p>

      <pre class="sh_java">
    public static void main(String[] args) {
        Kirja kirja1 = new Kirja("Fedor Dostojevski", "Rikos ja Rangaistus", 2);
        Kirja kirja2 = new Kirja("Robert Martin", "Clean Code", 1);
        Kirja kirja3 = new Kirja("Kent Beck", "Test Driven Development", 0.5);

        CDLevy cd1 = new CDLevy("Pink Floyd", "Dark Side of the Moon", 1973);
        CDLevy cd2 = new CDLevy("Wigwam", "Nuclear Nightclub", 1975);
        CDLevy cd3 = new CDLevy("Rendezvous Park", "Closer to Being Here", 2012);

        System.out.println(kirja1);
        System.out.println(kirja2);
        System.out.println(kirja3);
        System.out.println(cd1);
        System.out.println(cd2);
        System.out.println(cd3);
    }
      </pre>

      <p>Tulostus:</p>

      <pre>
Fedor Dostojevski: Rikos ja Rangaistus
Robert Martin: Clean Code
Kent Beck: Test Driven Development
Pink Floyd: Dark Side of the Moon (1973)
Wigwam: Nuclear Nightclub (1975)
Rendezvous Park: Closer to Being Here (2012)
      </pre>

      <p>Huom! Painoa ei ilmoiteta tulostuksessa.</p>

      <h4>Laatikko</h4>

      <p>Tee luokka laatikko, jonka sisälle voidaan tallettaa <code>Talletettava</code>-rajapinnan toteuttavia tavaroita. Laatikko saa konstruktorissaan parametrina laatikon maksimikapasiteetin kiloina. Laatikkoon ei saa lisätä enempää tavaraa kuin sen maksimikapasiteetti määrää. Laatikon sisältämien tavaroiden paino ei siis koskaan saa olla yli laatikon maksimikapasiteetin.</p>

      <p>Seuraavassa esimerkki laatikon käytöstä:</p>

      <pre class="sh_java">
    public static void main(String[] args) {
        Laatikko laatikko = new Laatikko(10);

        laatikko.lisaa( new Kirja("Fedor Dostojevski", "Rikos ja Rangaistus", 2) ) ;
        laatikko.lisaa( new Kirja("Robert Martin", "Clean Code", 1) );
        laatikko.lisaa( new Kirja("Kent Beck", "Test Driven Development", 0.7) );

        laatikko.lisaa( new CDLevy("Pink Floyd", "Dark Side of the Moon", 1973) );
        laatikko.lisaa( new CDLevy("Wigwam", "Nuclear Nightclub", 1975) );
        laatikko.lisaa( new CDLevy("Rendezvous Park", "Closer to Being Here", 2012) );

        System.out.println( laatikko );
    }
      </pre>

      <p>Tulostuu</p>

      <pre>
Laatikko: 6 esinettä, paino yhteensä 4.0 kiloa
      </pre>

      <p>Huom: koska painot esitetään doubleina, saattaa laskutoimituksissa tulla pieniä pyöristysvirheitä. Tehtävässä ei tarvitse välittää niistä.</p>

      <h4>Laatikon paino</h4>

      <p>Jos teit laatikon sisälle oliomuuttujan <code>double paino</code>, joka muistaa laatikossa olevien esineiden painon, korvaa se metodilla, joka laskee painon:</p>

      <pre class="sh_java">
public class Laatikko {
    //...

    public double paino() {
        double paino = 0;
        // laske laatikkoon talletettujen tavaroiden yhteispaino
        return paino;
    }
}
      </pre>

      <p>Kun tarvitset laatikon sisällä painoa esim. uuden tavaran lisäyksen yhteydessä, riittää siis kutsua laatikon painon laskevaa metodia.</p>

      <p>Metodi toki voisi palauttaa myös oliomuuttujan arvon. Harjoittelemme tässä kuitenkin tilannetta, jossa oliomuuttujaa ei tarvitse eksplisiittisesti ylläpitää vaan se voidaan tarpeentullen laskea. Seuraavan tehtävän jälkeen laatikossa olevaan oliomuuttujaan talletettu painotieto ei kuitenkaan välttämättä enää toimisi. Miksi? </p>

      <h4  >Laatikkokin on talletettava!</h4>

      <p>Rajapinnan <code>Talletettava</code> toteuttaminen siis edellyttää että luokalla on metodi <code>double paino()</code>. Laatikollehan lisättiin juuri tämä metodi. Laatikosta voidaan siis tehdä talletettava!</p>

      <p>Laatikot ovat oliota joihin voidaan laittaa <code>Talletettava</code>-rajapinnan toteuttavia olioita. Laatikot toteuttavat itsekin rajapinnan. Eli <b>laatikon sisällä voi olla myös laatikoita!</b></p>

      <p>Kokeile että näin varmasti on, eli tee ohjelmassasi muutama laatikko, laita laatikoihin tavaroita ja laita pienempiä laatikoita isompien laatikoiden sisään. Kokeile myös mitä tapahtuu kun laitat laatikon itsensä sisälle. Miksi näin käy?</p>
    </div>
  </div>

  <h3>Rajapinta metodin paluuarvona</h3>

  <p>Kuten mitä tahansa muuttujan tyyppiä, myös rajapintaa voi käyttää metodin paluuarvona. Seuraavassa <code>Tehdas</code>, jota voi pyytää valmistamaan erilaisia <code>Talletettava</code>-rajapinnan toteuttavia oliota. Tehdas valmistaa aluksi satunnaisesti kirjoja ja levyjä.</p>

  <pre class="sh_java">
   public class Tehdas {
      public Tehdas(){
          // HUOM: parametritonta tyhjää konstruktoria ei ole pakko kirjoittaa, jos luokalla ei ole muita konstruktoreja
          //       Java tekee automaattisesti tälläisissä tilanteissa luokalle oletuskonstruktorin eli parametrittoman tyhjän konstruktorin
      }

       public Talletettava valmistaUusi(){
           Random arpa = new Random();
           int luku = arpa.nextInt(4);
           if ( luku==0 ) {
               return new CDLevy("Pink Floyd", "Dark Side of the Moon", 1973);
           } else if ( luku==1 ) {
               return new CDLevy("Wigwam", "Nuclear Nightclub", 1975);
           } else if ( luku==2 ) {
               return new Kirja("Robert Martin", "Clean Code", 1 );
           } else {
               return new Kirja("Kent Beck", "Test Driven Development", 0.7);
           }
       }
   }
  </pre>

  <p>Tehdasta on mahdollista käyttää tuntematta tarkalleen mitä erityyppisiä Talletettava-rajapinnan luokkia on olemassa. Seuraavassa luokka Pakkaaja, jolta voi pyytää laatikollisen esineitä. Pakkaaja tuntee tehtaan, jota se pyytää luomaan esineet:</p>

  <pre class="sh_java">
   public class Pakkaaja {
       private Tehdas tehdas;

       public Pakkaaja(){
            tehdas = new Tehdas();
       }

       public Laatikko annaLaatikollinen() {
            Laatikko laatikko = new Laatikko(100);

            for ( int i=0; i &lt; 10; i++ ) {
                Talletettava uusiTavara = tehdas.valmistaUusi();
                laatikko.lisaa(uusiTavara);
            }

            return laatikko;
       }
   }
  </pre>

  <p>Koska pakkaaja ei tunne rajapinnan Talletettava toteuttavia luokkia, on ohjelmaan mahdollisuus lisätä uusia luokkia jotka toteuttavat rajapinnan ilman tarvetta muuttaa pakkaajaa. Seuraavassa on luotu uusi Talletettava-rajapinnan toteuttava luokka, <code>Suklaalevy</code>. Tehdasta on muutettu siten, että se luo kirjojen ja cd-levyjen lisäksi suklaalevyjä. Luokka <code>Pakkaaja</code> toimii muuttamatta tehtaan laajennetun version kanssa.</p>

  <pre class="sh_java">
   public class Suklaalevy implements Talletettava {
      // koska Javan generoima oletuskonstruktori riittää, emme tarvitse konstruktoria!

      public double paino(){
         return 0.2;
      }
   }

   public class Tehdas {
       // koska Javan generoima oletuskonstruktori riittää, emme tarvitse konstruktoria!

       public Talletettava valmistaUusi(){
           Random arpa = new Random();
           int luku = arpa.nextInt(5);
           if ( luku==0 ) {
               return new CDLevy("Pink Floyd", "Dark Side of the Moon", 1973);
           } else if ( luku==1 ) {
               return new CDLevy("Wigwam", "Nuclear Nightclub", 1975);
           } else if ( luku==2 ) {
               return new Kirja("Robert Martin", "Clean Code", 1 );
           } else if ( luku==3 ) {
               return new Kirja("Kent Beck", "Test Driven Development", 0.7);
           } else {
               return new Suklaalevy();
           }
       }
   }
  </pre>


  <p><em>Rajapintojen käyttö ohjelmoinnissa mahdollistaa luokkien välisten riippuvaisuuksien vähentämisen. Esimerkissämme Pakkaaja ei ole riippuvainen rajapinnan Talletettava-toteuttavista luokista vaan ainoastaan rajapinnasta. Tämä mahdollistaa rajapinnan toteuttavien luokkien lisäämisen ohjelmaan ilman tarvetta muuttaa luokkaa Pakkaaja. Myöskään pakkaajan käyttäjiin rajapinnan toteuttavien luokkien lisääminen ei vaikuta. Vähäisemmät riippuvuudet siis helpottavat ohjelman laajennettavuutta.
  </em></p>

  <!--

<p> Toteutetaan luokat <code>Uutinen</code>, joka kuvaa yksittäistä luettavaa uutista, ja <code>Uutispalvelu</code>, jonka tehtävänä on luoda luettavia uutisia. Uutispalvelua käyttäville sovelluksille ei ole tärkeää tai edes mielekästä tietää uutisten todellisesta toteutuksesta, oleellista on vain niiden lukeminen. Uutispalvelu voi siis hyvin tarjota uutisensa <code>Luettava</code>-rajapinnan kautta.</p>

<pre class="sh_java">
public class Uutinen implements Luettava {
    private String teksti;

    public Uutinen(String teksti) {
        this.teksti = teksti;
    }

    public String lue() {
        return this.teksti;
    }
}
</pre>

<pre class="sh_java">
public class Uutispalvelu {

    public Luettava haeViimeisinUutinen() {
        return new Uutinen("uusinta hottia!");
    }
}
</pre>

        <p>Uutispalvelu tuottaa uutisensa aina <code>Luettava</code>-rajapinnan tyyppisenä. Tässä kohtaa nousee usein esille erinomainen kysymys "<code>Miksi emme käyttäisi vain luokkaa Uutinen?</code>". Vastaus on pitkähkö, mutta toivottavasti selvittää taustaidean.</p>

        <p>Pohditaan tilannetta, jossa meillä on uutisia julkaiseva <code>Julkaisupalvelu</code>. Julkaisupalvelun tehtävänä on lukea uutisia tasaisin väliajoin uutispalvelulta ja tulostaa viestit näkyville (julkaisupalvelu voisi lähettää hyvin viestin esimerkiksi eri medioille, mutta pidättäydytään pienemmässä esimerkissä). Oletetaan että Uutispalvelu palauttaa Uutinen-olioita.</p>

<pre class="sh_java">
public class Uutispalvelu {

    public Uutinen haeViimeisinUutinen() {
        return new Uutinen("uusinta hottia!");
    }
}
</pre>

        <p>Julkaisupalvelun oleellinen toiminnallisuus on toistolauseke, joka kutsuu tasaisin väliajoin uutispalvelun <code>haeViimeisinUutinen-metodia</code>.</p>

<pre class="sh_java">
public class Julkaisupalvelu {
    private Uutispalvelu uutispalvelu;

    public Julkaisupalvelu() {
        this.uutispalvelu = new Uutispalvelu();
    }

    public void kaynnista() {
        while (true) {
            Uutinen uutinen = uutispalvelu.haeViimeisinUutinen();
            System.out.println(uutinen.lue());

            try {
                Thread.sleep(10000);
            } catch (Exception e) {
            }
        }
    }
}
</pre>

        <p>Tässä vaiheessa kaikki toimii hyvin. Oletetaan että Uutispalvelun toimitusjohtaja huomaa, että he tarvitsevat uuden formaatin kuvallisille uutisille. Kuvallisia uutisia varten toteutetaan erillinen luokka <code>KuvaUutinen</code>. KuvaUutinen on luettava, joten Uutispalvelun ohjelmoijat toteuttavat myös sille rajapinnan Luettava-rajapinta.</p>

<pre class="sh_java">
public class KuvaUutinen implements Luettava {
    private String kuvaOsoite;
    private String teksti;

    public KuvaUutinen(String teksti, String kuvaOsoite) {
        this.teksti = teksti;
        this.kuvaOsoite = kuvaOsoite;
    }

    public String lue() {
        return this.teksti + " (kuvan osoite: " + this.kuvaOsoite + ")";
    }
}
</pre>

        <p>Samalla he joutuvat myös muuttamaan UutisPalvelu-luokan toteutusta, sillä se ei tue uutta uutisformaattia: </p>

<pre class="sh_java">
public class Uutispalvelu {

    public KuvaUutinen haeViimeisinUutinen() {
        return new KuvaUutinen("uusinta hottia!", "kuvan osoite");
    }
}
</pre>

        <p>Nyt julkaisupalvelun toteutusta on <em>pakko</em> muuttaa, sillä se ei enää toimi koska Uutispalvelu palauttaa <code>KuvaUutinen</code>-luokan ilmentymän. Kuinka montaa luokkaa pitäisi muuttaa jos uutispalvelua olisi käyttänyt kymmenen palvelua, entä jos tuhat? Tässä vaiheessa <em>jokaisen</em> uutispalvelua käyttävän sovelluksen tulee muuttaa omaa toimintaansa.</p>

        <p>Entä jos kaikissa uutisissa ei ole kuvia, ja haluaisimme silloin tällöin kuitenkin palauttaa <code>Uutinen</code>-luokan ilmentymän? Yllä oleva metodi <code>haeViimeisinUutinen</code> ei taida riittää..</p>

        <p>Pohditaan seuraavaksi yllä tehtyä uutisformaatin muutosta tilanteessa, jossa Uutispalvelun <code>haeViimeisinUutinen</code>-metodin palautustyyppi on <code>Luettava</code>.</p>


<pre class="sh_java">
public class Uutispalvelu {

    public Luettava haeViimeisinUutinen() {
        return new Uutinen("uusinta hottia!");
    }
}
</pre>

        <p>Kun Uutispalvelun toimitusjohtaja haluaa uuden kuvaformaatin, ei Uutispalvelun <code>haeViimeisinUutinen</code>-metodin palautustyypille tarvitse tehdä mitään.</p>

<pre class="sh_java">
public class Uutispalvelu {

    public Luettava haeViimeisinUutinen() {
        return new KuvaUutinen("uusinta hottia!", "kuvan osoite");
    }
}
</pre>

        <p>Julkaisupalveluunkaan ei tarvitse tehdä muutoksia.</p>

<pre class="sh_java">
public class Julkaisupalvelu {
    private Uutispalvelu uutispalvelu;

    public Julkaisupalvelu() {
        this.uutispalvelu = new Uutispalvelu();
    }

    public void kaynnista() {
        while (true) {
            Luettava luettava = uutispalvelu.haeViimeisinUutinen();
            System.out.println(luettava.lue());

            try {
                Thread.sleep(10000);
            } catch (Exception e) {
            }
        }
    }
}
</pre>

        <p>Kuinka montaa luokkaa olisi pitänyt muuttaa jos uutispalvelua olisi käyttänyt kymmenen palvelua, entä jos tuhat? Nollaa. Entä jos uutispalvelu haluaa välillä lähettää normaaleja uutisia, välillä kuvallisia uutisia? Helppo homma, muutos tarvitaan vain uutispalvelun puolelle.</p>

<pre class="sh_java">
public class Uutispalvelu {

    public Luettava haeViimeisinUutinen() {
        Random random = new Random();

        if(random.nextDouble() > 0.5) {
            return new Uutinen("uusinta hottia!");
        }

        return new KuvaUutinen("uusinta hottia!", "kuvan osoite");
    }
}
</pre>

    <p>Emme joudu tässäkään tapauksessa muuttamaan Uutispalvelua käyttäviä sovelluksia.</p>


    <p><em>Rajapintojen käyttö ohjelmoinnissa mahdollistaa riippuvaisuuksien vähentämisen. Jos kaikki uutispalvelua käyttävät palvelut käyttävät rajapintaa Luettava, eivät ne ole suoraan riippuvaisia jostain tietystä Luettava-rajapinnan toteuttavasta luokasta. Yllä olevassa esimerkissä uutispalvelun sisäistä toteutusta pystyi muuttamaan siten, että siinä tehdyt muutokset eivät vaikuttaneet uutispalvelua käyttäneisiin olioihin millään tavalla.</em></p>

-->

  <h3>Valmiit rajapinnat</h3>

  <p>Javan API tarjoaa huomattavan määrän valmiita rajapintoja. Tutustutaan tässä neljään ehkä Javan eniten käytettyyn rajapintaan: <code><a href="http://download.oracle.com/javase/6/docs/api/java/util/List.html" target="_blank">List</a></code>, <code><a href="http://download.oracle.com/javase/6/docs/api/java/util/Map.html" target="_blank">Map</a></code>, <code><a href="http://download.oracle.com/javase/6/docs/api/java/util/Set.html" target="_blank">Set</a></code> ja <code><a href="http://download.oracle.com/javase/6/docs/api/java/util/Collection.html" target="_blank">Collection</a></code>.</p>

  <h4>List</h4>

  <p>Rajapinta <a href="http://download.oracle.com/javase/6/docs/api/java/util/List.html">List</a> määrittelee listoihin liittyvän peruskäyttäytymisen. Koska ArrayList-luokka toteuttaa <code>List</code>-rajapinnan, voi sitä käyttää myös <code>List</code>-rajapinnan kautta.</p>

  <pre class="sh_java">
List&lt;String&gt; merkkijonot = new ArrayList&lt;String&gt;();
merkkijonot.add("merkkijono-olio arraylist-oliossa!");
  </pre>

  <p>Kuten huomaamme <a href="http://download.oracle.com/javase/6/docs/api/java/util/List.html">List-rajapinnan Java API</a>:sta, rajapinnan <code>List</code> toteuttavia luokkia on useita. Eräs tietojenkäsittelijöille tuttu listarakenne on linkitetty lista (<a href="http://docs.oracle.com/javase/6/docs/api/java/util/LinkedList.html" target="_blank">linked list</a>). Linkitettyä listaa voi käyttää rajapinnan List-kautta täysin samoin kuin ArrayLististä luotua oliota.</p>

  <pre class="sh_java">
List&lt;String&gt; merkkijonot = new LinkedList&lt;String&gt;();
merkkijonot.add("merkkijono-olio linkedlist-oliossa!");
  </pre>

  <p>Molemmat rajapinnan <code>List</code> toteutukset toimivat käyttäjän näkökulmasta samoin. Rajapinta siis <em>abstrahoi</em> niiden sisäisen toiminnallisuuden. ArrayListin ja LinkedListin sisäinen rakenne on kuitenkin huomattavan erilainen. ArrayList tallentaa alkioita taulukkoon, josta tietyllä indeksillä hakeminen on nopeaa. LinkedList taas rakentaa listan, jossa jokaisessa listan alkiossa on viite seuraavan listan alkioon. Kun linkitetyssä listassa haetaan alkiota tietyllä indeksillä, tulee listaa käydä läpi alusta indeksiin asti.</p>

  <p>Isoilla listoille voimme nähdä huomattaviakin suorituskykyeroja. Linkitetyn listan vahvuutena on se, että listaan lisääminen on aina nopeaa. ArrayListillä taas taustalla on taulukko, jota täytyy kasvattaa aina kun se täyttyy. Taulukon kasvattaminen vaatii uuden taulukon luonnin ja vanhan taulukon tietojen kopioinnin uuteen taulukkoon. Toisaalta, indeksin perusteella hakeminen on Arraylististä erittäin nopeaa, kun taas linkitetyssä listassa joudutaan käymään listan alkioita yksitellen läpi tiettyyn indeksiin pääsemiseksi. Tietorakenteiden kuten linkitetyn listan ja ArrayListin sisäisestä toteutuksesta tulee lisää tietoa kurssilla <em>Tietorakenteet ja algoritmit</em>.</p>

  <p>Ohjelmointikurssilla eteen tulevissa tilanteissa kannattaa käytännössä aina valita ArrayList. Rajapintoihin ohjelmointi kuitenkin kannattaa: toteuta ohjelmasi siten, että käytät tietorakenteita rajapintojen kautta.</p>

  <h4>Map</h4>

  <p>Rajapinta <a href="http://download.oracle.com/javase/6/docs/api/java/util/Map.html">Map</a> määrittelee hajautustauluihin liittyvän peruskäyttäytymisen. Koska HashMap-luokka toteuttaa <code>Map</code>-rajapinnan, voi sitä käyttää myös <code>Map</code>-rajapinnan kautta.</p>

  <pre class="sh_java">
Map&lt;String, String&gt; kaannokset = new HashMap&lt;String, String&gt;();
kaannokset.put("gambatte", "tsemppiä");
kaannokset.put("hai", "kyllä");
  </pre>

  <p>Hajautustaulun avaimet saa hajautustaulusta <code>keySet</code>-metodin avulla.</p>

  <pre class="sh_java">
Map&lt;String, String&gt; kaannokset = new HashMap&lt;String, String&gt;();
kaannokset.put("gambatte", "tsemppiä");
kaannokset.put("hai", "kyllä");

for(String key: kaannokset.keySet()) {
    System.out.println(key + ": " + kaannokset.get(key));
}
  </pre>

  <pre>
gambatte: tsemppiä
hai: kyllä
  </pre>

  <p>Metodi <code>keySet</code> palauttaa <code>Set</code>-rajapinnan toteuttavan joukon alkioita. <code>Set</code>-rajapinnan toteuttavan joukon voi käydä läpi for-each -toistorakenteella. Hajautustaulusta saa talletetut arvot metodin <code>values</code>-avulla. Metodi <code>values</code> palauttaa <code>Collection</code> rajapinnan toteuttavan joukon alkioita. Tutustutaan vielä pikaisesti Set- ja Collection-rajapintoihin.</p>

  <h4>Set</h4>

  <p>Rajapinta <a href="http://download.oracle.com/javase/6/docs/api/java/util/Set.html" target="_blank">Set</a> kuvaa joukkoihin liittyvää toiminnallisuutta. Javassa joukot sisältävät aina joko 0 tai 1 kappaletta tiettyä oliota. Set-rajapinnan toteuttaa muun muassa <code><a href="http://docs.oracle.com/javase/6/docs/api/java/util/HashSet.html" target="_blank">HashSet</a></code>. Joukon alkioita pystyy käymään läpi for-each -rakenteen avulla seuraavasti.</p>

  <pre class="sh_java">
Set&lt;String&gt; joukko = new HashSet&lt;String&gt;();
joukko.add("yksi");
joukko.add("yksi");
joukko.add("kaksi");

for (String alkio: joukko) {
    System.out.println(alkio);
}
  </pre>

  <pre>
yksi
kaksi
  </pre>

  <p>Huomaa että HashSet ei ota millään tavalla kantaa joukon alkioiden järjestykseen.</p>

  <h4>Collection</h4>

  <p>Rajapinta <a href="http://download.oracle.com/javase/6/docs/api/java/util/Collection.html" target="_blank">Collection</a> kuvaa kokoelmiin liittyvää toiminnallisuutta. Javassa muun muassa listat ja joukot ovat kokoelmia -- rajapinnat List ja Set toteuttavat rajapinnan Collection. Kokoelmarajapinta tarjoaa metodit muun muassa alkioiden olemassaolon tarkistamiseen (metodi <code>contains</code>) ja kokoelman koon tarkistamiseen (metodi <code>size</code>). Kaikkia kokoelmarajapinnan toteuttavia luokkia voi käydä läpi <code>for-each</code> -toistolausekkeella. </p>

  <p>Luodaan vielä hajautustaulu ja käydään erikseen läpi siihen liittyvät avaimet ja arvot.</p>

  <pre class="sh_java">
Map&lt;String, String&gt; kaannokset = new HashMap&lt;String, String&gt;();
kaannokset.put("gambatte", "tsemppiä");
kaannokset.put("hai", "kyllä");

Set&lt;String&gt; avaimet = kaannokset.keySet();
Collection&lt;String&gt; avainKokoelma = avaimet;

System.out.println("Avaimet:");
for(String avain: avainKokoelma) {
    System.out.println(avain);
}

System.out.println();
System.out.println("Arvot:");
Collection&lt;String&gt; arvot = kaannokset.values();
for(String arvo: arvot) {
    System.out.println(arvo);
}
  </pre>

  <pre>
Avaimet:
gambatte
hai

Arvot:
kyllä
tsemppiä
  </pre>


  <p>Myös seuraavanlainen hajautustaulun käyttö olisi luonut saman tulostuksen.</p>

  <pre class="sh_java">
Map&lt;String, String&gt; kaannokset = new HashMap&lt;String, String&gt;();
kaannokset.put("gambatte", "tsemppiä");
kaannokset.put("hai", "kyllä");

System.out.println("Avaimet:");
for(String avain: kaannokset.keySet()) {
    System.out.println(avain);
}

System.out.println();
System.out.println("Arvot:");
for(String arvo: kaannokset.values()) {
    System.out.println(arvo);
}
  </pre>

  <p>Seuraavassa tehtävässä rakennetaan verkkokauppa ja harjoitellaan luokkien käyttämistä niiden tarjoamien rajapintojen kautta.</p>

  <div class="tehtavat">
    <div class="tehtava">
      <h3>Verkkokauppa</h3>

      <p>Teemme tehtävässä muutamia verkkokaupan hallinnointiin soveltuvia ohjelmakomponentteja.</p>

      <h4>Varasto</h4>

      <p>Tee luokka Varasto jolla on seuraavat metodit:</p>

      <ul>
        <li><code>public void lisaaTuote(String tuote, int hinta, int saldo)</code> lisää varastoon tuotteen jonka hinta ja varastosaldo ovat parametrina annetut luvut</li>
        <li><code>public int hinta(String tuote)</code> palauttaa parametrina olevan tuotteen hinnan, jos tuotetta ei ole varastossa, palauttaa metodi -99</li>
      </ul>


      <p>Varaston sisällä tuotteiden hinnat (ja seuraavassa kohdassa saldot) tulee tallettaa <code>Map&lt;String, Integer&gt;</code>-tyyppiseksi määriteltyyn muuttujaan! Luotava olio voi olla tyypiltään <code>HashMap</code>, muuttujan tyyppinä on kuitenkin käytettävä <code>Map</code>-rajapintaa (ks. <a href="#46.4.2">46.4.2.</a>)</p>

      <p>Seuraavassa esimerkki varaston käytöstä:</p>

      <pre class="sh_java">
        Varasto varasto = new Varasto();
        varasto.lisaaTuote("maito", 3, 10);
        varasto.lisaaTuote("kahvi", 5, 7);

        System.out.println("hinnat:");
        System.out.println("maito:  " + varasto.hinta("maito"));
        System.out.println("kahvi:  " + varasto.hinta("kahvi"));
        System.out.println("sokeri: " + varasto.hinta("sokeri"));
      </pre>

      <p>Tulostuu:</p>

      <pre>
hinnat:
maito:  3
kahvi:  5
sokeri: -99
      </pre>

      <h4>Tuotteen varastosaldo</h4>

      <p>Talleta tuotteiden varastosaldot samaan tapaan <code>Map&lt;String, Integer&gt;</code>-tyyppiseen muuttujaan kuin talletit hinnat. Täydennä varastoa seuraavilla metodeilla:</p>

      <ul>
        <li><code>public int saldo(String tuote)</code> palauttaa parametrina olevan tuotteen varastosaldon.</li>
        <li><code>public boolean ota(String tuote)</code> vähentää parametrina olevan tuotteen saldoa yhdellä ja palauuttaa <em>true</em> jos tuotetta oli varastossa. Jos tuotetta ei ole varastossa, palauttaa metodi <em>false</em>, tuotteen saldo ei saa laskea alle nollan.</li>
      </ul>


      <p>Esimerkki varaston käytöstä:</p>

      <pre class="sh_java">
        Varasto varasto = new Varasto();
        varasto.lisaaTuote("kahvi", 5, 1);

        System.out.println("saldot:");
        System.out.println("kahvi:  " + varasto.saldo("kahvi"));
        System.out.println("sokeri: " + varasto.saldo("sokeri"));

        System.out.println("otetaan kahvi " + varasto.ota("kahvi"));
        System.out.println("otetaan kahvi " + varasto.ota("kahvi"));
        System.out.println("otetaan sokeri " + varasto.ota("sokeri"));

        System.out.println("saldot:");
        System.out.println("kahvi:  " + varasto.saldo("kahvi"));
        System.out.println("sokeri: " + varasto.saldo("sokeri"));
      </pre>

      <p>Tulostuu:</p>

      <pre>
saldot:
kahvi:  1
sokeri: 0
otetaan kahvi true
otetaan kahvi false
otetaan sokeri false
saldot:
kahvi:  0
sokeri: 0
      </pre>

      <h4>Tuotteiden listaus</h4>

      <p>Listätään varastolle vielä yksi metodi:</p>

      <ul>
        <li><code>public Set&lt;String&gt; tuotteet()</code> palauttaa <em>joukkona</em> varastossa olevien tuotteiden nimet</li>
      </ul>

      <p>Metodi on helppo toteuttaa. Saat tietoon varastossa olevat tuotteet kysymällä ne joko hinnat tai saldot muistavalta Map:iltä metodin <code>keySet</code> avulla.</p>

      <p>Esimerkki varaston käytöstä:</p>

      <pre class="sh_java">
        Varasto varasto = new Varasto();
        varasto.lisaaTuote("maito", 3, 10);
        varasto.lisaaTuote("kahvi", 5, 6);
        varasto.lisaaTuote("piimä", 2, 20);
        varasto.lisaaTuote("jugurtti", 2, 20);

        System.out.println("tuotteet:");
        for (String tuote : varasto.tuotteet()) {
            System.out.println(tuote);
        }
      </pre>

      <p>Tulostuu:</p>

      <pre>
tuotteet:
piimä
jugurtti
kahvi
maito
      </pre>

      <h4>Ostos</h4>

      <p>Ostoskoriin lisätään <em>ostoksia</em>. Ostoksella tarkoitetaan tiettyä määrää tiettyjä tuotteita. Koriin voidaan laittaa esim. ostos joka vastaa yhtä leipää tai ostos joka vastaa 24:ää kahvia.</p>

      <p>Tee luokka <code>Ostos</code> jolla on seuraavat toiminnot:</p>

      <ul>
        <li><code>public Ostos(String tuote, int kpl, int yksikkohinta)</code> konstruktori joka luo ostoksen joka vastaa parametrina annettua tuotetta. Tuotteita ostoksessa on <em>kpl</em> kappaletta ja yhden tuotteen hinta on kolmantena parametrina annettu <em>yksikkohinta</em></li>
        <li><code>public int hinta()</code> palauttaa ostoksen hinnan. Hinta saadaan kertomalla kappalemäärä yksikköhinnalla</li>
        <li><code>public void kasvataMaaraa()</code> kasvattaa ostoksen kappalemäärää yhdellä</li>
        <li><code>public String toString()</code> palauttaa ostoksen merkkijonomuodossa, joka on alla olevan esimerkin mukainen</li>
      </ul>

      <p>Esimerkki ostoksen käytöstä</p>

      <pre class="sh_java">
        Ostos ostos = new Ostos("maito", 4, 2);
        System.out.println( "ostoksen joka sisältää 4 maitoa yhteishinta on " + ostos.hinta() );
        System.out.println( ostos );
        ostos.kasvataMaaraa();
        System.out.println( ostos );
      </pre>

      <p>Tulostuu:</p>

      <pre>
ostoksen joka sisältää 4 maitoa yhteishinta on 8
maito: 4
maito: 5
      </pre>

      <p>Huom: <em>toString</em> on siis muotoa <em>tuote: kpl</em> hintaa ei merkkijonoesitykseen tule!</p>

      <h4>Ostoskori</h4>

      <p>Vihdoin pääsemme toteuttamaan luokan ostoskori!</p>

      <p>Ostoskori tallettaa sisäisesti koriin lisätyt tuotteet <em>Ostos-olioina</em>. Ostoskorilla tulee olla oliomuuttuja jonka tyyppi on joko <code>Map&lt;String, Ostos&gt;</code> tai <code>List&lt;Ostos&gt;</code>. Älä laita mitään muita oliomuuttujia ostoskorille kuin ostosten talletukseen tarvittava Map tai List.</p>

      <p>Huom: jos talletat Ostos-oliot Map-tyyppiseen apumuuttujaan, on tässä ja seuraavassa tehtävässä hyötyä Map:in metodista values(), jonka avulla on helppo käydä läpi kaikki talletetut ostos-oliot.</p>

      <p>Tehdään aluksi ostoskorille parametriton konstruktori ja metodit:</p>

      <ul>
        <li><code>public void lisaa(String tuote, int hinta)</code> lisää ostoskoriin ostoksen joka vastaa parametrina olevaa tuotetta ja jolla on parametrina annettu hinta.</li>
        <li><code>public int hinta()</code> palauttaa ostoskorin kokonaishinnan</li>
      </ul>

      <p>Esimerkki ostoksen käytöstä</p>

      <pre class="sh_java">
        Ostoskori kori = new Ostoskori();
        kori.lisaa("maito", 3);
        kori.lisaa("piimä", 2);
        kori.lisaa("juusto", 5);
        System.out.println("korin hinta: " + kori.hinta());
        kori.lisaa("tietokone", 899);
        System.out.println("korin hinta: " + kori.hinta());
      </pre>

      <p>Tulostuu:</p>

      <pre>
korin hinta: 10
korin hinta: 909
      </pre>

      <h4>Ostoskorin tulostus</h4>

      <p>Tehdään ostoskorille metodi <code>public void tulosta()</code> joka tulostaa korin sisältämät <em>Ostos</em>-oliot. Tulostusjärjestyksessä ei ole merkitystä. Edellisen esimerkin ostoskori tulostetuna olisi:</p>

      <pre>
piimä: 1
juusto: 1
tietokone: 1
maito: 1
      </pre>

      <p>Huomaa, että tulostuva numero on siis tuotteen korissa oleva kappalemäärä, ei hinta!</p>

      <h4>yhtä tuotetta kohti vain yksi Ostos-olio</h4>

      <p>Täydennetään Ostoskoria siten, että jos korissa on jo tuote joka sinne lisätään, ei koriin luoda uutta Ostos-olioa vaan päivitetään jo korissa olevaa tuotetta vastaavaa ostosolioa kutsumalla sen metodia <em>kasvataMaaraa()</em>.</p>

      <p>Esimerkki:</p>

      <pre class="sh_java">
        Ostoskori kori = new Ostoskori();
        kori.lisaa("maito", 3);
        kori.tulosta();
        System.out.println("korin hinta: " + kori.hinta() +"\n");

        kori.lisaa("piimä", 2);
        kori.tulosta();
        System.out.println("korin hinta: " + kori.hinta() +"\n");

        kori.lisaa("maito", 3);
        kori.tulosta();
        System.out.println("korin hinta: " + kori.hinta() +"\n");

        kori.lisaa("maito", 3);
        kori.tulosta();
        System.out.println("korin hinta: " + kori.hinta() +"\n");
      </pre>

      <p>Tulostuu:</p>

      <pre>
maito: 1
korin hinta: 3

piimä: 1
maito: 1
korin hinta: 5

piimä: 1
maito: 2
korin hinta: 8

piimä: 1
maito: 3
korin hinta: 11
      </pre>

      <p>Eli ensin koriin lisätään maito ja piimä ja niille omat ostos-oliot. Kun koriin lisätään lisää maitoa, ei luoda uusille maidoille omaa ostosolioa, vaan päivitetään jo korissa olevan maitoa kuvaavan ostosolion kappalemäärää.</p>

      <h4>Kauppa</h4>

      <p>Nyt meillä on valmiina kaikki osat "verkkokauppaa" varten. Verkkokaupassa on varasto joka sisältää kaikki tuotteet. Jokaista asiakkaan asiointia varten on oma ostoskori. Aina kun asiakas valitsee ostoksen, lisätään se asiakkaan ostoskoriin jos tuotetta on varastossa. Samalla varastosaldoa pienennetään yhdellä.</p>

      <p>Seuraavassa on valmiina verkkokaupan koodin runko. Tee projektiin luokka <code>Kauppa</code> ja kopioi alla oleva koodi luokkaan.</p>

      <pre class="sh_java">
import java.util.Scanner;

public class Kauppa {

    private Varasto varasto;
    private Scanner lukija;

    public Kauppa(Varasto varasto, Scanner lukija) {
        this.varasto = varasto;
        this.lukija = lukija;
    }

    // metodi jolla hoidetaan yhden asiakkaan asiointi kaupassa
    public void asioi(String asiakas) {
        Ostoskori kori = new Ostoskori();
        System.out.println("Tervetuloa kauppaan " + asiakas);
        System.out.println("valikoimamme:");

        for (String tuote : varasto.tuotteet()) {
            System.out.println( tuote );
        }

        while (true) {
            System.out.print("mitä laitetaan ostoskoriin (pelkkä enter vie kassalle):");
            String tuote = lukija.nextLine();
            if (tuote.isEmpty()) {
                break;
            }

            // tee tänne koodi joka lisää tuotteen ostoskoriin jos sitä on varastossa
            // ja vähentää varastosaldoa
            // älä koske muuhun koodiin!

        }

        System.out.println("ostoskorissasi on:");
        kori.tulosta();
        System.out.println("korin hinta: " + kori.hinta());
    }
}
      </pre>

      <p>Seuraavassa pääohjelma joka täyttää kaupan varaston ja laittaa Pekan asioimaan kaupassa:</p>

      <pre class="sh_java">
    Varasto varasto = new Varasto();
    varasto.lisaaTuote("kahvi", 5, 10);
    varasto.lisaaTuote("maito", 3, 20);
    varasto.lisaaTuote("piimä", 2, 55);
    varasto.lisaaTuote("leipä", 7, 8);

    Kauppa kauppa = new Kauppa(varasto, new Scanner(System.in));
    kauppa.asioi("Pekka");
      </pre>

      <p>Kauppa on melkein valmiina. Yhden asiakkaan asioinnin hoitavan metodin <code>public void asioi(String asiakas)</code> on kommenteilla merkitty kohta jonka joudut täydentämään. Lisää kohtaan koodi joka tarkastaa onko asiakkaan haluamaa tuotetta varastossa. Jos on, vähennä tuotteen varastosaldoa ja lisää tuote ostoskoriin.</p>

      <p><em>Vapise, verkkokauppa.com!</em></p>
    </div>
  </div>

  <h2>Geneerisyys</h2>

  <p>Geneerisyys (<em>generics</em>) liittyy olioita säilövien luokkien tapaan säilöä vapaavalintaisen tyyppisiä olioita. Vapaavalintaisuus perustuu luokkien määrittelyssä käytettyyn geneeriseen tyyppiparametriin, jonka avulla voidaan määritellä <em>olion luontivaiheessa</em> valittavia tyyppejä. Luokan geneerisyys määritellään antamalla luokan nimen jälkeen haluttu määrä luokan tyyppiparametreja pienempi kuin ja suurempi kuin -merkkien väliin. Toteutetaan oma geneerinen luokka <code>Lokero</code>, johon voi asettaa yhden minkälaisen tahansa olion.</p>

  <pre class="sh_java">
public class Lokero&lt;T&gt; {
    private T alkio;

    public void asetaArvo(T alkio) {
        this.alkio = alkio;
    }

    public T haeArvo() {
        return alkio;
    }
}
  </pre>

  <p>Määrittely <code>public class Lokero&lt;T&gt;</code> kertoo että luokalle <code>Lokero</code> tulee antaa konstruktorissa tyyppiparametri. Konstruktorikutsun jälkeen kaikki olion sisäiset muuttujat tulevat olemaan kutsun yhteydessä annettua tyyppiä. Luodaan merkkijonon tallentava lokero.</p>

  <pre class="sh_java">
    Lokero&lt;String&gt; merkkijono = new Lokero&lt;String&gt;();
    merkkijono.asetaArvo(":)");

    System.out.println(merkkijono.haeArvo());
  </pre>

  <pre>
:)
  </pre>

  <p>Tyyppiparametria vaihtamalla voidaan luoda myös muuntyyppisiä olioita tallentavia <code>Lokero</code>-olioita. Esimerkiksi kokonaisluvun saa tallennettua seuraavasti</p>

  <pre class="sh_java">
    Lokero&lt;Integer&gt; luku = new Lokero&lt;Integer&gt;();
    luku.asetaArvo(5);

    System.out.println(luku.haeArvo());
  </pre>


  <pre>
5
  </pre>

  <p>Huomattava osa Javan tietorakenteista on ohjelmoitu geneerisiksi. Esimerkiksi ArrayList saa yhden tyyppiparametrin, HashMap kaksi.</p>

  <pre class="sh_java">
    List&lt;String&gt; merkkijonot = new ArrayList&lt;String&gt;();
    Map&lt;String, String&gt; avainArvoParit = new HashMap&lt;String, String&gt;();
  </pre>

  <p>Jatkossa kun näet esimerkiksi tyypin <code>ArrayList&lt;String&gt;</code> tiedät että sen sisäisessä rakenteessa on käytetty geneeristä tyyppiparametria.</p>

  <h3>Geneerisyyttä hyödyntävä rajapinta: Comparable</h3>

  <p>Normaalien rajapintojen lisäksi Javassa on geneerisyyttä hyödyntäviä rajapintoja. Geneerisille rajapinnoille määritellään sisäisten arvojen tyypit samalla tavalla kuin geneerisille luokille. Tutkitaan Javan valmista rajapintaa <code><a href="http://java.sun.com/javase/6/docs/api/java/lang/Comparable.html">Comparable</a></code>. Rajapinta <code>Comparable</code> määrittelee metodin <code>compareTo</code>, jonka tulee palauttaa <code>this</code>-olion paikan vertailujärjestyksessä verrattuna parametrina annettuun olioon (negatiivinen luku, 0 tai positiivinen luku). Jos <code>this</code>-olio on vertailujärjestyksessä ennen parametrina saatavaa olioa, tulee metodin palauttaa negatiivinen luku, jos taas parametrina saatava olio on järjestyksessä ennen, tulee metodin palauttaa positiivinen luku. Jos oliot ovat vertailujärjestykseltään samat, palautetaan 0. Vertailujärjestyksellä tarkoitetaan tässä ohjelmoijan määrittelemää olioiden "suuruusjärjestystä", eli jos oliot järjestetään sort-metodilla, mikä on niiden järjestys.</p>

  <p>Yksi <code>Comparable</code>-rajapinnan eduista on se, että se mahdollistaa Comparable-tyyppisistä alkioista koostuvan listan järjestämisen esimerkiksi standardikirjaston <code>Collections.sort</code>-metodin avulla. <code>Collections.sort</code> käyttää listan alkioiden <code>compareTo</code>-metodia selvittääkseen, missä järjestyksessä alkoiden kuuluisi olla. Tätä <code>compareTo</code>-metodin avulla johdettua järjestystä kutsutaan <em>luonnolliseksi järjestykseksi</em> (natural ordering).</p>

  <p>Luodaan luokka <code>Kerholainen</code>, joka kuvaa kerhossa käyvää lasta tai nuorta. Jokaisella kerholaisella on nimi ja pituus. Kerholaisten tulee mennä aina syömään pituusjärjestyksessä, joten toteutetaan kerholaisille rajapinta <code>Comparable</code>. Comparable-rajapinta ottaa tyyppiparametrinaan myös luokan, johon sitä verrataan. Käytetään tyyppiparametrina luokkaa <code>Kerholainen</code>-luokkaa.</p>

  <pre class="sh_java">
public class Kerholainen implements Comparable&lt;Kerholainen&gt; {
    private String nimi;
    private int pituus;

    public Kerholainen(String nimi, int pituus) {
        this.nimi = nimi;
        this.pituus = pituus;
    }

    public String getNimi() {
        return this.nimi;
    }

    public int getPituus() {
        return this.pituus;
    }

    @Override
    public String toString() {
        return this.getNimi() + " (" + this.getPituus() + ")";
    }

    @Override
    public int compareTo(Kerholainen kerholainen) {
        if(this.pituus == kerholainen.getPituus()) {
            return 0;
        } else if (this.pituus &gt; kerholainen.getPituus()) {
            return 1;
        } else {
            return -1;
        }
    }
}
  </pre>

  <p>Rajapinnan vaatima metodi <code>compareTo</code> palauttaa kokonaisluvun, joka kertoo vertausjärjestyksestä. Koska <code>compareTo()</code>-metodista riittää palauttaa negatiivinen luku, jos <code>this</code>-olio on pienempi kuin parametrina annettu olio ja nolla, kun pituudet ovat samat, voidaan edellä esitelty metodi <code>compareTo</code> toteuttaa myös seuraavasti:</p>

  <pre class="sh_java">
    @Override
    public int compareTo(Kerholainen kerholainen) {
        return this.pituus - kerholainen.getPituus();
    }
  </pre>

  <p>Kerholaisten järjestäminen on nyt helppoa.</p>

  <pre class="sh_java">
    List&lt;Kerholainen&gt; kerholaiset = new ArrayList&lt;Kerholainen&gt;();
    kerholaiset.add(new Kerholainen("mikael", 182));
    kerholaiset.add(new Kerholainen("matti", 187));
    kerholaiset.add(new Kerholainen("joel", 184));

    System.out.println(kerholaiset);
    Collections.sort(kerholaiset);
    System.out.println(kerholaiset);
  </pre>

  <pre>
[mikael (182), matti (187), joel (184)]
[mikael (182), joel (184), matti (187)]
  </pre>

  <p>Jos kerholaiset haluaa järjestää käänteiseen järjestykseen, riittää vain <code>compareTo</code>-metodissa olevien muuttujien paikan vaihtaminen.</p>


  <div class="tehtavat">
    <div class="tehtava">
      <h3>Köyhät kyykkyyn</h3>

      <p>Saat valmiin luokan Ihminen. Ihmisellä on nimi- ja palkkatiedot. Muokkaa Ihminen-luokasta <code>Comparable</code>-rajapinnan toteuttava niin, että <code>compareTo</code>-metodi lajittelee ihmiset palkan mukaan järjestykseen - suuripalkkaiset ensin, köyhät kyykkyyn listan loppuun.</p>
    </div>
    <div class="tehtava">

      <h3>Opiskelijat nimijärjestykseen</h3>

      <p>Saat valmiin luokan Opiskelija. Opiskelijalla on nimi. Muokkaa Opiskelija-luokasta <code>Comparable</code>-rajapinnan toteuttava niin, että <code>compareTo</code>-metodi lajittelee opiskelijat nimen mukaan aakkosjärjestykseen.</p>

      <p><b>Vinkki:</b> Opiskelijan nimi on String, ja String-luokka on itsessään <code>Comparable</code>. Voit hyödyntää String-luokan <code>compareTo</code>-metodia Opiskelija-luokan metodia toteuttaessasi. <code>String.compareTo</code> kohtelee kirjaimia eriarvoisesti kirjainkoon mukaan, ja tätä varten String-luokalla on myös metodi <code>compareToIgnoreCase</code> joka nimensä mukaisesti jättää kirjainkoon huomioimatta. Voit käyttää opiskelijoiden järjestämiseen kumpaa näistä haluat.</p>
    </div>
    <div class="tehtava">

      <h3>Kortit ojennukseen</h3>

      <p>Tehtäväpohjan mukana on luokka, jonka oliot kuvaavat pelikortteja. Kortilla on arvo ja maa. Kortin arvo on <em>2, 3, ..., 10, J, Q, K </em> tai <em>A</em> ja maa <em>Risti, Ruutu, Hertta</em> tai <em>Pata</em>. Arvo ja maa kuitenkin esitetään olioiden sisällä kokonaislukuina. Kortilla on myös metodi toString, jota käyttäen kortin arvo ja maa tulostuvat "ihmisystävällisesti". </p>

      <p>Jotta korttien käyttäjän ei tarvitsisi käsitellä korttien maita numeroina, on luokkaan määritelty neljä <strong>vakioa</strong> eli <code>public static final</code> -muuttujaa: </p>

      <pre class="sh_java">
public class Kortti {
    public static final int RISTI  = 0;
    public static final int RUUTU  = 1;
    public static final int HERTTA = 2;
    public static final int PATA   = 3;

    // ...
}
      </pre>

      <p>Nyt ohjelmassa voidaan luvun 1 sijaan käyttää vakioa <code>Kortti.RUUTU</code>. Seuraavassa esimerkissä luodaan kolme korttia ja tulostetaan ne:</p>

      <pre class="sh_java">
  Kortti eka = new Kortti(2, Kortti.RUUTU);
  Kortti toka = new Kortti(14, Kortti.PATA);
  Kortti kolmas = new Kortti(12, Kortti.HERTTA);

  System.out.println(eka);
  System.out.println(toka);
  System.out.println(kolmas);
      </pre>

      <p>Tulostuu:</p>

      <pre>
Ruutu 2
Pata A
Hertta Q
      </pre>

      <p><b>HUOM:</b> vaikioiden käyttö ylläolevaan tapaan ei ole tyylikkäin tapa asian hoitamiseen. Myöhemmin kurssilla opimme oikeaoppisen tyylin maan esittämiseen!</p>

      <h4>Kortti-luokasta Comparable</h4>

      <p>Tee Kortti-luokasta Comparable. Toteuta <code>compareTo</code>-metodi niin, että korttien järjestys on arvon mukaan nouseva. Jos verrattavien Korttien arvot ovat samat, verrataan niitä maan perusteella nousevassa järjestyksessä: <em>risti ensin, ruutu toiseksi, hertta kolmanneksi, pata viimeiseksi.</em> </p>

      <p>Järjestyksessä pienin kortti siis olisi risti kakkonen ja suurin pataässä.</p>

      <h4>Käsi</h4>

      <p>Tehdään seuraavaksi luokka <code>Kasi</code> joka edustaa pelaajan kädessään pitämää korttien joukkoa. Tee kädelle seuraavat metodit:</p>

      <ul>
        <li><code>public void lisaa(Kortti kortti)</code> lisää käteen kortin</li>
        <li><code>public void tulosta()</code> tulostaa kädessä olevat kortit alla olevan esimerkin tyylillä</li>
      </ul>

      <pre class="sh_java">
  Kasi kasi = new Kasi();

  kasi.lisaa( new Kortti(2, Kortti.RUUTU) );
  kasi.lisaa( new Kortti(14, Kortti.PATA) );
  kasi.lisaa( new Kortti(12, Kortti.HERTTA) );
  kasi.lisaa( new Kortti(2, Kortti.PATA) );

  kasi.tulosta();
      </pre>

      <p>Tulostuu:</p>

      <pre>
Ruutu 2
Pata A
Hertta Q
Pata 2
      </pre>

      <p>Talleta käden sisällä olevat kortit ArrayListiin.</p>

      <h4>Käden järjestäminen</h4>

      <p>Tee kädelle metodi <code>public void jarjesta()</code> jota kutsumalla käden sisällä olevat kortit menevät suuruusjärjestykseen. Järjestämisen jälkeen kortit tulostuvat järjestyksessä:</p>

      <pre class="sh_java">
  Kasi kasi = new Kasi();

  kasi.lisaa( new Kortti(2, Kortti.RUUTU) );
  kasi.lisaa( new Kortti(14, Kortti.PATA) );
  kasi.lisaa( new Kortti(12, Kortti.HERTTA) );
  kasi.lisaa( new Kortti(2, Kortti.PATA) );

  kasi.jarjesta();

  kasi.tulosta();
      </pre>

      <p>Tulostuu:</p>

      <pre>
Ruutu 2
Pata 2
Hertta Q
Pata A
      </pre>

      <h4>Käsien vertailu</h4>

      <p>Eräässä korttipelissä kahdesta korttikädestä arvokkaampi on se, jonka sisältämien korttien arvon summa on suurempi. Tee luokasta <code>Kasi</code> vertailtava tämän kriteerin mukaan, eli laita luokka toteuttamaan rajapinta <code>Comparable&lt;Kasi&gt;</code>.</p>

      <p>Esimerkkiohjelma, jossa vertaillaan käsiä:</p>

      <pre class="sh_java">
  Kasi kasi1 = new Kasi();

  kasi1.lisaa( new Kortti(2, Kortti.RUUTU) );
  kasi1.lisaa( new Kortti(14, Kortti.PATA) );
  kasi1.lisaa( new Kortti(12, Kortti.HERTTA) );
  kasi1.lisaa( new Kortti(2, Kortti.PATA) );

  Kasi kasi2 = new Kasi();

  kasi2.lisaa( new Kortti(11, Kortti.RUUTU) );
  kasi2.lisaa( new Kortti(11, Kortti.PATA) );
  kasi2.lisaa( new Kortti(11, Kortti.HERTTA) );

  int vertailu = kasi1.compareTo(kasi2);

  if ( vertailu &lt; 0 ) {
    System.out.println("arvokkaampi käsi sisältää kortit");
    kasi2.tulosta();
  } else if ( vertailu &gt; 0 ){
    System.out.println("arvokkaampi käsi sisältää kortit");
    kasi1.tulosta();
  } else {
    System.out.println("kädet yhtä arvokkaat");
  }
      </pre>

      <p>Tulostuu</p>

      <pre>
arvokkaampi käsi sisältää kortit
Ruutu J
Pata J
Hertta J
      </pre>

      <h4>Korttien järjestäminen eri kriteerein</h4>

      <p>Entä jos haluaisimme välillä järjestää kortit hieman eri tavalla, esim. kaikki saman maan kortit peräkkäin?
      Luokalla voi olla vain yksi compareTo-metodi, joten joudumme muunlaisia järjestyksiä saadaksemme turvautumaan muihin keinoihin.</p>

      <p>
      Vaihtoehtoiset järjestämistavat toteutetaan erillisten vertailun suorittavien luokkien avulla. Korttien vaihtoehtoisten järjestyksen määräävän luokkien tulee toteuttaa <code>Comparator&lt;Kortti&gt;</code>-rajapinta. Järjestyksen määräävän luokan olio vertailee kahta parametrina saamaansa korttia. Metodeja on ainoastaan yksi compare(Kortti k1, Kortti k2), jonka tulee palauttaa negatiivinen arvo, jos kortti k1 on järjestyksessä ennen korttia k2, positiivinen arvo jos k2 on järjestyksessä ennen k1:stä ja 0 muuten.

      <p>
      Periaatteena on luoda jokaista järjestämistapaa varten oma vertailuluokka, esim. saman maan kortit vierekkäin vievän järjestyksen määrittelevä luokka:</p>

      <pre class="sh_java">
import java.util.Comparator;

public class SamatMaatVierekkain implements Comparator&lt;Kortti&gt; {
    public int compare(Kortti k1, Kortti k2) {
        return k1.getMaa()-k2.getMaa();
    }
}
      </pre>

      <p>Maittainen järjestys on sama kuin kortin metodin <code>compareTo</code> maille määrittelemä järjestys eli <em>ristit ensin, ruudut toiseksi, hertat kolmanneksi, padat viimeiseksi.</em></p>

      <p>Järjestäminen tapahtuu edelleen luokan Collections metodin sort avulla. Metodi saa nyt toiseksi parametrikseen järjestyksen määräävän luokan olion:</p>

      <pre class="sh_java">
  ArrayList&lt;Kortti&gt; kortit = new ArrayList&lt;Kortti&gt;();

  kortit.add( new Kortti(3, Kortti.PATA) );
  kortit.add( new Kortti(2, Kortti.RUUTU) );
  kortit.add( new Kortti(14, Kortti.PATA) );
  kortit.add( new Kortti(12, Kortti.HERTTA) );
  kortit.add( new Kortti(2, Kortti.PATA) );

  SamatMaatVierekkain samatMaatVierekkainJarjestaja = new SamatMaatVierekkain();
  Collections.sort(kortit, samatMaatVierekkainJarjestaja );

  for (Kortti k : kortit) {
    System.out.println( k );
  }
      </pre>

      <p>Tulostuu:</p>

      <pre>
Ruutu 2
Hertta Q
Pata 3
Pata A
Pata 2
      </pre>

      <p>Järjestyksen määrittelevä olio voidaan myös luoda suoraan sort-kutsun yhteydessä:</p>

      <pre class="sh_java">
Collections.sort(kortit, new SamatMaatVierekkain() );
      </pre>
      <p>

      <p>Tarkempia ohjeita vertailuluokkien tekemiseen <a href="http://leepoint.net/notes-java/data/collections/comparators.html">täällä</a></p>

      <p>Tee nyt luokka Comparator-rajapinnan toteuttava luokka <code>SamatMaatVierekkainArvojarjestykseen</code>
      jonka avulla saat kortit muuten samanlaiseen järjestykseen kuin edellisessä esimerkissä paitsi, että saman maan kortit järjestyvät arvon mukaiseesti.
      </p>

      <h4>Käden järjestäminen maittain</h4>

      <p>Lisää luokalle <code>Kasi</code> metodi <code>public void jarjestaMaittain()</code> jota kutsumalla käden sisällä olevat kortit menevät edellisen tehtävän vertailijan määrittelemään järjestykseen. Järjestämisen jälkeen kortit tulostuvat järjestyksessä:</p>

      <pre class="sh_java">
  Kasi kasi = new Kasi();

  kasi.lisaa( new Kortti(12, Kortti.HERTTA) );
  kasi.lisaa( new Kortti(4, Kortti.PATA) );
  kasi.lisaa( new Kortti(2, Kortti.RUUTU) );
  kasi.lisaa( new Kortti(14, Kortti.PATA) );
  kasi.lisaa( new Kortti(7, Kortti.HERTTA) );
  kasi.lisaa( new Kortti(2, Kortti.PATA) );

  kasi.jarjestaMaittain();

  kasi.tulosta();
      </pre>

      <p>Tulostuu:</p>

      <pre>
Ruutu 2
Hertta 7
Hertta Q
Pata 2
Pata 4
Pata A
      </pre>

    </div>
  </div>

  <h2>Collections</h2>

  <p>Luokkakirjasto <code><a href="http://java.sun.com/javase/6/docs/api/java/util/Collections.html" target="_blank">Collections</a></code> on Javan yleishyödyllinen kokoelmaluokkiin liittyvä kirjasto. Kuten tiedämme, <code>Collections</code> tarjoaa metodit olioiden järjestämiseen joko <code>Comparable</code>- tai <code>Comparator</code> -rajapinnan kautta. Järjestämisen lisäksi luokkakirjaston avulla voi etsiä esimerkiksi minimi- (<code>min</code>-metodi) tai maksimialkioita (<code>max</code>-metodi), hakea tiettyä arvoa (<code>binarySearch</code>-metodi), tai kääntää listan (<code>reverse</code>-metodi).</p>

  <h3>Hakeminen</h3>

  <p>Collections-luokkakirjasto tarjoaa valmiiksi toteutetun binäärihaun. Metodi <code>binarySearch()</code> palauttaa haetun alkion indeksin listasta jos se löytyy. Jos alkiota ei löydy, hakualgoritmi palauttaa negatiivisen arvon. Metodi <code>binarySearch()</code> käyttää Comparable-rajapintaa haetun olion löytämiseen. Jos olion <code>compareTo()</code>-metodi palauttaa arvon 0, eli olio on sama, ajatellaan arvon löytyneen.</p>

  <p>Kerholainen-luokkamme vertaa pituuksia <code>compareTo()</code>-metodissaan, eli listasta etsiessä etsisimme samanpituista kerholaista.</p>

  <pre class="sh_java">
    List&lt;Kerholainen&gt; kerholaiset = new ArrayList&lt;Kerholainen&gt;();
    kerholaiset.add(new Kerholainen("mikael", 182));
    kerholaiset.add(new Kerholainen("matti", 187));
    kerholaiset.add(new Kerholainen("joel", 184));

    Collections.sort(kerholaiset);

    Kerholainen haettava = new Kerholainen("Nimi", 180);
    int indeksi = Collections.binarySearch(kerholaiset, haettava);
    if(indeksi &gt;= 0) {
        System.out.println("180 senttiä pitkä löytyi indeksistä " + indeksi);
        System.out.println("nimi: " + kerholaiset.get(indeksi).getNimi());
    }

    haettava = new Kerholainen("Nimi", 187);
    int indeksi = Collections.binarySearch(kerholaiset, haettava);
    if(indeksi &gt;= 0) {
        System.out.println("187 senttiä pitkä löytyi indeksistä " + indeksi);
        System.out.println("nimi: " + kerholaiset.get(indeksi).getNimi());
    }
  </pre>

  <p>Esimerkkimme tulostaa seuraavaa</p>

  <pre>
187 senttiä pitkä löytyi indeksistä 2
nimi: matti
  </pre>

  <p>Huomaa että esimerkissä kutsuttiin myös metodia <code>Collections.sort()</code>. Tämä tehdään sen takia, että binäärihakua ei voida tehdä jos taulukko tai lista ei ole valmiiksi järjestyksessä.</p>







  <div class="tehtavat">
    <p class="mooc-pakollinen"></p>
    <div class="tehtava pakollinen-hakuun">
      <h3>Mäkihyppy</h3>

      <p>Harjoitellaan taas ohjelman rakenteen omatoimista suunnittelua. Käyttöliittymän ulkomuoto ja vaadittu toiminnallisuus on määritelty ennalta, rakenteen saat toteuttaa vapaasti.</p>

      <p><b>Huom: jotta testit toimisivat, ohjelmasi saa luoda vain yhden Scanner-olion. Älä myöskään käytä staattisia muuttujia, testit suorittavat ohjelman useita kertoja joten staattisiin muuttujiin edellisillä suorituskerroilla jääneet arvot todennäköisesti häiritsevät testien toimintaa!</b></p>

      <p>Mäkihyppy on suomalaisille erittäin rakas laji, jossa pyritään hyppäämään hyppyrimäestä mahdollisimman pitkälle mahdollisimman tyylikkäästi. Tässä tehtävässä tulee toteuttaa simulaattori mäkihyppykilpailulle.</p>

      <p>Simulaattori kysyy ensin käyttäjältä hyppääjien nimiä. Kun käyttäjä antaa tyhjän merkkijonon (eli painaa enteriä) hyppääjän nimeksi siirrytään hyppyvaiheeseen. Hyppyvaiheessa hyppääjät hyppäävät yksitellen käänteisessä pistejärjestyksessä. Hyppääjä jolla on vähiten pisteitä kerättynä hyppää aina kierroksen ensimmäisenä, toiseksi vähiten pisteitä omaava toisena jne, ..., eniten pisteitä kerännyt viimeisenä.</p>

      <p>Hyppääjän yhteispisteet lasketaan yksittäisten hyppyjen pisteiden summana. Yksittäisen hypyn pisteytys lasketaan hypyn pituudesta (käytä satunnaista kokonaisluku väliltä 60-120) ja tuomariäänistä. Jokaista hyppyä kohden annetaan 5 tuomariääntä (satunnainen luku väliltä 10-20). Tuomariääniä laskettaessa otetaan huomioon vain kolme keskimmäistä ääntä: pienintä ja suurinta ääntä ei oteta huomioon. Esimerkiksi jos Mikael hyppää 61 metriä ja saa tuomariäänet 11, 12, 13, 14 ja 15, on hänen hyppynsä yhteispisteet 100.</p>

      <p>Kierroksia hypätään niin monta kuin ohjelman käyttäjä haluaa. Kun käyttäjä haluaa lopettaa tulostetaan lopuksi kilpailun lopputulokset. Lopputuloksissa tulostetaan hyppääjät, hyppääjien yhteispisteet ja hyppääjien hyppäämien hyppyjen pituudet. Lopputulokset on järjestetty hyppääjien yhteispisteiden mukaan siten, että eniten pisteitä kerännyt on ensimmäinen.</p>

      <p>Tehtävän tekemisessä on hyötyä <em>muun muassa</em> metodeista <code>Collections.sort</code> ja <code>Collections.reverse</code>. Kannattaa aluksi hahmotella minkälaisia luokkia ja olioita ohjelmassa voisi olla. On myös hyvä pyrkiä tilanteeseen, jossa käyttöliittymäluokka on ainut luokka joka kutsuu tulostuskomentoa.</p>

      <pre>
Kumpulan mäkiviikot

Syötä kilpailun osallistujat yksi kerrallaan, tyhjällä merkkijonolla siirtyy hyppyvaiheeseen.
  Osallistujan nimi: <font color="red">Mikael</font>
  Osallistujan nimi: <font color="red">Mika</font>
  Osallistujan nimi:

Kilpailu alkaa!

Kirjoita "hyppaa" niin hypätään, muuten lopetetaan: <font color="red">hyppaa</font>

1. kierros

Hyppyjärjestys:
  1. Mikael (0 pistettä)
  2. Mika (0 pistettä)

Kierroksen 1 tulokset
  Mikael
    pituus: 95
    tuomaripisteet: [15, 11, 10, 14, 14]
  Mika
    pituus: 112
    tuomaripisteet: [14, 12, 18, 18, 17]

Kirjoita "hyppaa" niin hypätään, muuten lopetetaan: <font color="red">hyppaa</font>

2. kierros

Hyppyjärjestys:
  1. Mikael (134 pistettä)
  2. Mika (161 pistettä)

Kierroksen 2 tulokset
  Mikael
    pituus: 96
    tuomaripisteet: [20, 19, 15, 13, 18]
  Mika
    pituus: 61
    tuomaripisteet: [12, 11, 15, 17, 11]

Kirjoita "hyppaa" niin hypätään, muuten lopetetaan: <font color="red">hyppaa</font>

3. kierros

Hyppyjärjestys:
  1. Mika (260 pistettä)
  2. Mikael (282 pistettä)

Kierroksen 3 tulokset
  Mika
    pituus: 88
    tuomaripisteet: [11, 19, 13, 10, 15]
  Mikael
    pituus: 63
    tuomaripisteet: [12, 19, 19, 12, 12]

Kirjoita "hyppaa" niin hypätään, muuten lopetetaan: <font color="red">lopeta</font>

Kiitos!

Kilpailun lopputulokset:
Sija    Nimi
1       Mikael (388 pistettä)
          hyppyjen pituudet: 95 m, 96 m, 63 m
2       Mika (387 pistettä)
          hyppyjen pituudet: 112 m, 61 m, 88 m
      </pre>



      <p><strong>Huom1:</strong> Testien kannalta on oleellista että <em>käyttöliittymä</em> toimii kuten yllä kuvattu, esim. rivien alussa olevien välilyöntien määrän on oltava oikea. <strong>Rivien alussa oleva tyhjä pitää tehdä välilyönneillä</strong>, testit eivät toimi jos tyhjä on tehty tabulaattoreilla. Ohjelman tulostamat tekstit kannattaneekin copypasteta ohjelmakoodiin joko tehtävänannosta tai testien virheilmoituksista. <em>Tehtävä on neljän yksittäisen tehtäväpisteen arvoinen.</em></p>

      <p><strong>Huom2:</strong> älä käytä luokkein nimissä skandeja, ne saattavat aiheuttaa ongelmia testeihin!</p>

      <p><strong>Ohjelman tulee käynnistyä kun tehtäväpohjassa oleva main-metodi suoritetaan, muistutuksena vieltä, että tehtävässä saa luoda vain yhden Scanner-olion.</strong></p>

    </div>
  </div>

  <p>Screencast jossa tehdään viikon 1 ja 2 ydinasioita hyödyntävä hieman isompi sovellus:</p>

  <a href="http://www.youtube.com/watch?feature=player_embedded&v=LFxtwce8chM" height="300" target="_blank"><img src="https://www.cs.helsinki.fi/group/java/k13/ohja/img/youtube.jpg"/></a>


  <!--
    <p><iframe allowfullscreen="" frameborder="0"  height="450" width="700" src="http://www.youtube.com/embed/LFxtwce8chM"></iframe></p>
-->
</div>
</section>



<section class="viikkoraja" id="3" >
<div class="viikkoraja"></div>
<div class="viikkoraja-mooc" id="Viikko 9" deadline="avautuu kun 85 % viikosta 8 tehty" data-first-chapter-index="42" data-first-exercise-index="124" data-first-week-index="9"  data-first-chapter-index-mooc="42" data-first-exercise-index-mooc="124" data-first-week-index-mooc="9" tekija="Arto Vihavainen, Matti Luukkainen">

  <h2>Single responsibility principle</h2>

  <p>Isompia ohjelmia suunniteltaessa pohditaan usein mille luokalle minkäkin asian toteuttaminen kuuluu. Jos kaikki ohjelmaan kuuluva toiminnallisuus asetetaan samaan luokkaan, on tuloksena väistämättä kaaos. Ohjelmistojen suunnittelun osa-alue <em>oliosuunnittelu</em> sisältää periaatteen <em>Single responsibility principle</em>, jota meidän kannattaa seurata.</p>

  <p>Single responsibility principle sanoo että jokaisella luokalla tulee olla vain yksi vastuu ja selkeä tehtävä. Jos luokalla on yksi selkeä tehtävä, on tehtävässä tapahtuvien muutosten toteuttaminen helppoa, muutos tulee tehdä vain yhteen luokkaan. <em>Jokaisella luokalla tulisi olla vain yksi syy muuttua</em>.</p>

  <p>Tutkitaan seuraavaa luokkaa <code>Tyontekija</code>, jolla on metodit palkan laskemiseen ja tuntien raportointiin.</p>

  <pre class="sh_java">
public class Tyontekija {
    // oliomuuttujat

    // työntekijään liittyvät konstruktorit ja metodit

    public double laskePalkka() {
        // palkan laskemiseen liittyvä logiikka
    }

    public String raportoiTunnit() {
        // työtuntien raportointiin liittyvä logiikka
    }
}
  </pre>

  <p>Vaikka yllä olevasta esimerkistä puuttuvat konkreettiset toteutukset, tulisi hälytyskellojen soida. Luokalla <code>Tyontekija</code> on ainakin kolme eri vastuualuetta. Se kuvaa sovelluksessa työntekijää, se toteuttaa palkanlaskennan tehtävää palkan laskemisesta, ja tuntiraportointijärjestelmän tehtävää työtuntien raportoinnista. Yllä oleva luokka tulee pilkkoa kolmeen osaan: yksi osa kuvaa työntekijää, toinen osa palkanlaskentaa ja kolmas osa tuntikirjanpitoa.</p>

  <pre class="sh_java">
public class Tyontekija {
    // oliomuuttujat

    // työntekijään liittyvät konstruktorit ja metodit
}
  </pre>

  <pre class="sh_java">
public class Palkanlaskenta {
    // oliomuuttujat

    // palkanlaskentaan liittyvät metodit

    public double laskePalkka(Henkilo henkilo) {
        // palkan laskemiseen liittyvä logiikka
    }
}
  </pre>


  <pre class="sh_java">
public class Tuntikirjanpito {
    // oliomuuttujat

    // tuntikirjanpitoon liittyvät metodit

    public String luoTuntiraportti(Henkilo henkilo) {
        // työtuntien raportointiin liittyvä logiikka
    }
}
  </pre>

  <p><em>Jokainen muuttuja, jokainen koodirivi, jokainen metodi, jokainen luokka, ja jokainen ohjelma pitäisi olla vain yhtä tarkoitusta varten. Usein ohjelman "parempi" rakenne on ohjelmoijalle selkeää vasta kun ohjelma on toteutettu jo kertaalleen. Tämä on täysin hyväksyttävää: vielä tärkeämpää on se, että ohjelmaa pyritään muuttamaan aina selkeämpään suuntaan. <strong>Refaktoroi eli muokkaa ohjelmaasi aina tarpeen tullen!</strong></em></p>


  <h2>Luokkien organisointi pakkauksiin</h2>

  <p>Suurempia ohjelmia suunniteltaessa ja toteutettaessa luokkamäärä kasvaa helposti suureksi. Luokkien määrän kasvaessa niiden tarjoamien toiminnallisuuksien ja metodien muistaminen vaikeutuu. Järkevä luokkien nimeäminen helpottaa toiminnallisuuksien muistamista. Järkevän nimennän lisäksi lähdekooditiedostot kannattaa jakaa toiminnallisuutta, käyttötarkoitusta tai jotain muuta loogista kokonaisuutta kuvaaviin pakkauksiin. Pakkaukset (<em>package</em>) ovat käytännössä hakemistoja, joihin lähdekooditiedostot organisoidaan. Windowsissa ja puhekielessä hakemistoja (engl. directory) kutsutaan usein kansioiksi. Me käytämme kuitenkin termiä hakemisto.</p>

  <p>Ohjelmointiympäristöt tarjoavat valmiit työkalut pakkausten hallintaan. Olemme tähän mennessä luoneet luokkia ja rajapintoja vain projektiin liittyvän lähdekoodipakkaukset-osion (<code>Source Packages</code>) oletuspakkaukseen (<code>default package</code>). Uuden pakkauksen voi luoda NetBeansissa projektin pakkauksiin liittyvässä <code>Source Packages</code> -osiossa oikeaa hiirennappia painamalla ja valitsemalla <code>New -&gt; Java Package...</code>. Luodun pakkauksen sisälle voidaan luoda luokkia aivan kuten oletuspakkaukseenkin (<code>default package</code>).</p>

  <p>Pakkaus, jossa luokka sijaitsee, näkyy lähdekooditiedoston alussa ennen muita komentoja olevasta lauseesta <code>package <em>pakkaus</em></code>. Esimerkiksi alla oleva luokka <code>Sovellus</code> sijaitsee pakkauksessa <code>kirjasto</code>.</p>

  <pre class="sh_java">
package kirjasto;

public class Sovellus {

    public static void main(String[] args) {
        System.out.println("Hello packageworld!");
    }
}
  </pre>

  <p>Pakkaukset voivat sisältää pakkauksia. Esimerkiksi pakkausmäärittelyssä <code>package kirjasto.domain</code> pakkaus <code>domain</code> on pakkauksen <code>kirjasto</code> sisällä. Asettamalla pakkauksia pakkausten sisään rakennetaan sovelluksen luokille ja rajapinnoille hierarkiaa. Esimerkiksi kaikki Javan luokat sijaitsevat pakkauksen <code>java</code> alla olevissa pakkauksissa. Pakkausnimeä <code>domain</code> käytetään usein kuvaamaan sovellusalueen käsitteisiin liittyvien luokkien säilytyspaikkaa. Esimerkiksi luokka <code>Kirja</code> voisi hyvin olla pakkauksen <code>kirjasto.domain</code> sisällä sillä se kuvaa kirjastosovellukseen liittyvää käsitettä.</p>

  <pre class="sh_java">
package kirjasto.domain;

public class Kirja {
    private String nimi;

    public Kirja(String nimi) {
        this.nimi = nimi;
    }

    public String getNimi() {
        return this.nimi;
    }
}
  </pre>

  <p>Pakkauksissa olevia luokkia tuodaan luokan käyttöön <code>import</code>-lauseen avulla. Esimerkiksi <code>kirjasto</code>-pakkauksessa oleva luokka <code>Sovellus</code> saisi käyttöönsä pakkauksessa <code>kirjasto.domain</code> olevan luokan määrittelyllä <code>import kirjasto.domain.Kirja</code>.</p>


  <pre class="sh_java">
package kirjasto;

import kirjasto.domain.Kirja;

public class Sovellus {

    public static void main(String[] args) {
        Kirja kirja = new Kirja("pakkausten ABC!");
        System.out.println("Hello packageworld: " + kirja.getNimi());
    }
}
  </pre>

  <pre>
Hello packageworld: pakkausten ABC!
  </pre>

  <p>Import-lauseet asetetaan lähdekooditiedostossa pakkausmäärittelyn jälkeen mutta ennen luokkamäärittelyä. Niitä voi olla myös useita -- esimerkiksi kun haluamme käyttää useita luokkia. Javan valmiit luokat sijaitsevat yleensä ottaen pakkauksen <code>java</code> alipakkauksissa. Luokkiemme alussa usein esiintyvät lauseet <code>import java.util.ArrayList</code> ja <code>import java.util.Scanner;</code> alkavat nyt toivottavasti vaikuttaa merkityksellisimmiltä.</p>

  <p>Jatkossa <em>kaikissa</em> tehtävissämme käytetään pakkauksia. Luodaan seuraavaksi ensimmäiset pakkaukset itse.</p>

  <div class="tehtavat" id="viikko9">
    <div class="tehtava">
      <h3>Ensimmäisiä pakkauksia</h3>

      <h4>Käyttöliittymä-rajapinta</h4>

      <p>Luo projektipohjaan pakkaus <code>mooc</code>. Rakennetaan tämän pakkauksen sisälle sovelluksen toiminta. Lisää sovellukseen pakkaus <code>ui</code> (tämän jälkeen pitäisi olla käytössä pakkaus <code>mooc.ui</code>), ja lisää sinne rajapinta <code>Kayttoliittyma</code>.</p>

      <p>Rajapinnan <code>Kayttoliittyma</code> tulee määritellä metodi <code>void paivita()</code>. </p>

      <h4>Tekstikäyttöliittymä</h4>

      <p>
      Luo samaan pakkaukseen luokka <code>Tekstikayttoliittyma</code>, joka toteuttaa rajapinnan <code>Kayttoliittyma</code>. Toteuta luokassa <code>Tekstikayttoliittyma</code> rajapinnan <code>Kayttoliittyma</code> vaatima metodi <code>public void paivita()</code> siten, että sen ainut tehtävä on merkkijonon "<code>Päivitetään käyttöliittymää</code>"-tulostaminen <code>System.out.println</code>-metodikutsulla.</p>

      <h4>Sovelluslogiikka</h4>

      <p>Luo tämän jälkeen pakkaus <code>mooc.logiikka</code>, ja lisää sinne luokka <code>Sovelluslogiikka</code>. Sovelluslogiikan APIn tulee olla seuraavanlainen.</p>

      <p>
      <ul>
        <li><code>public Sovelluslogiikka(Kayttoliittyma kayttoliittyma)</code></li>Sovelluslogiikka-luokan konstruktori. Saa parametrina Kayttoliittyma-rajapinnan toteuttavan luokan. Huom: jotta sovelluslogiikka näkisi rajapinnan, on sen "importoitava" se, eli tarvitset tiedoston alkuun rivin <code>import mooc.ui.Kayttoliittyma;</code> <br/>
        <li><code>public void suorita(int montaKertaa)</code></li> Tulostaa <code>montaKertaa</code>-muuttujan määrittelemän määrän merkkijonoa "Sovelluslogiikka toimii". Jokaisen "Sovelluslogiikka toimii"-tulostuksen jälkeen tulee kutsua konstruktorin parametrina saadun rajapinnan <code>Kayttoliittyma</code>-toteuttaman olion määrittelemää <code>paivita()</code>-metodia.<br/>
      </ul>
      </p>

      <p>Voit testata sovelluksen toimintaa seuraavalla pääohjelmaluokalla.</p>

      <pre class="sh_java">
import mooc.logiikka.Sovelluslogiikka;
import mooc.ui.Kayttoliittyma;
import mooc.ui.Tekstikayttoliittyma;

public class Main {

    public static void main(String[] args) {
        Kayttoliittyma kayttoliittyma = new Tekstikayttoliittyma();
        new Sovelluslogiikka(kayttoliittyma).suorita(3);
    }
}
      </pre>

      <p>Ohjelman tulostuksen tulee olla seuraava:</p>

      <pre>
Sovelluslogiikka toimii
Päivitetään käyttöliittymää
Sovelluslogiikka toimii
Päivitetään käyttöliittymää
Sovelluslogiikka toimii
Päivitetään käyttöliittymää
      </pre>

    </div>
  </div>

  <h3>Konkreettinen hakemistorakenne</h3>

  <p>Kaikki NetBeansissa näkyvät projektit ovat tietokoneesi <em><a href="http://fi.wikipedia.org/wiki/Tiedostoj%C3%A4rjestelm%C3%A4" target="_blank">tiedostojärjestelmässä</a></em>. Jokaiselle projektille on olemassa oma hakemisto (eli kansio), jonka sisällä on projektiin liittyvät tiedostot ja hakemistot.</p>

  <p>Projektin hakemistossa <code>src</code> on ohjelmaan liittyvät lähdekoodit. Jos luokan pakkauksena on kirjasto, sijaitsee se projektin lähdekoodihakemiston <code>src</code> sisällä olevassa hakemistossa <code>kirjasto</code>. Jos olet kiinnostunut, NetBeansissa voi käydä katsomassa projektien konkreettista rakennetta <em>Files</em>-välilehdeltä joka on normaalisti <em>Projects</em>-välilehden vieressä. Jos et näe välilehteä <em>Files</em>, saa sen näkyville valitsemalla vaihtoehdon <em>Files</em> valikosta <em>Window</em>.</p>

  <p>Sovelluskehitystä tehdään normaalisti <em>Projects</em>-välilehdeltä, jossa NetBeans on piilottanut projektiin liittyviä tiedostoja joista ohjelmoijan ei tarvitse välittää.</p>

  <h3>Näkyvyysmääreet ja pakkaukset</h3>

  <p>Olemme aiemmin tutustuneet kahteen näkyvyysmääreeseen. Näkyvyysmääreellä <code>private</code> varustetut metodit ja muuttujat ovat näkyvissä vain sen luokan sisällä joka määrittelee ne. Niitä ei voi käyttää luokan ulkopuolelta. Näkyvyysmääreellä <code>public</code> varustetut metodit ja muuttujat ovat taas kaikkien käytettävissä.</p>

  <pre class="sh_java">
package kirjasto.ui;

public class Kayttoliittyma {
    private Scanner lukija;

    public Kayttoliittyma(Scanner lukija) {
        this.lukija = lukija;
    }

    public void kaynnista() {
        tulostaOtsikko();

        // muu toiminnallisuus
    }

    private void tulostaOtsikko() {
        System.out.println("************");
        System.out.println("* KIRJASTO *");
        System.out.println("************");
    }
}
  </pre>

  <p>Yllä olevasta <code>Kayttoliittyma</code>-luokasta tehdyn olion konstruktori ja <code>kaynnista</code>-metodi on kutsuttavissa mistä tahansa ohjelmasta. Metodi <code>tulostaOtsikko</code> ja <code>lukija</code>-muuttuja on käytössä vain luokan sisällä.</p>

  <p>Pakkausnäkyvyyttä käytettäessä muuttujille tai metodeille ei aseteta mitään näkyvyyteen liittyvää etuliitettä. Muutetaan yllä olevaa esimerkkiä siten, että metodilla <code>tulostaOtsikko</code> on pakkausnäkyvyys.</p>

  <pre class="sh_java">
package kirjasto.ui;

public class Kayttoliittyma {
    private Scanner lukija;

    public Kayttoliittyma(Scanner lukija) {
        this.lukija = lukija;
    }

    public void kaynnista() {
        tulostaOtsikko();

        // muu toiminnallisuus
    }

    void tulostaOtsikko() {
        System.out.println("************");
        System.out.println("* KIRJASTO *");
        System.out.println("************");
    }
}
  </pre>

  <p>Nyt <em>saman pakkauksen sisällä</em> olevat luokat voivat käyttää metodia <code>tulostaOtsikko</code>.

  <pre class="sh_java">
package kirjasto.ui;

import java.util.Scanner;

public class Main {

    public static void main(String[] args) {
        Scanner lukija = new Scanner(System.in);
        Kayttoliittyma kayttoliittyma = new Kayttoliittyma(lukija);

        kayttoliittyma.tulostaOtsikko(); // onnistuu!
    }
}
  </pre>

  <p>Jos luokka on eri pakkauksessa, ei metodia <code>tulostaOtsikko</code> pysty käyttämään.</p>

  <pre class="sh_java">
package kirjasto;

import java.util.Scanner;
import kirjasto.ui.Kayttoliittyma;

public class Main {

    public static void main(String[] args) {
        Scanner lukija = new Scanner(System.in);
        Kayttoliittyma kayttoliittyma = new Kayttoliittyma(lukija);

        kayttoliittyma.tulostaOtsikko(); // ei onnistu!
    }
}
  </pre>

  <h2>Monta rajapintaa ja rajapintojen tarjoamasta joustavuudesta</h2>

  <p>Viime viikolla tutustuimme rajapintoihin. Rajapinta siis määrittelee yhden tai useamman metodin, jotka sen toteuttavan luokan on pakko toteuttaa. Rajapintoja, kuten kaikkia luokkia voi asettaa pakkauksiin. Esimerkiksi seuraava <code>Tunnistettava</code>-rajapinta sijaitsee pakkauksessa <code>sovellus.domain</code>, ja määrittelee että <code>Tunnistettava</code>-rajapinnan toteuttavien luokkien tulee toteuttaa metodi <code>public String getTunnus()</code>.</p>

  <pre class="sh_java">
package sovellus.domain;

public interface Tunnistettava {
    String getTunnus();
}
  </pre>

  <p>Luokka toteuttaa rajapinnan <code>implements</code>-avainsanalla. Toteutetaan luokka <code>Henkilo</code>, joka toteuttaa rajapinnan tunnistettava. Henkilo-luokan metodi <code>getTunnus</code> palauttaa aina henkilön henkilötunnuksen.</p>

  <pre class="sh_java">
package sovellus.domain;

public class Henkilo implements Tunnistettava {
    private String nimi;
    private String henkilotunnus;

    public Henkilo(String nimi, String henkilotunnus) {
        this.nimi = nimi;
        this.henkilotunnus = henkilotunnus;
    }

    public String getNimi() {
        return this.nimi;
    }

    public String getHenkilotunnus() {
        return this.henkilotunnus;
    }

    @Override
    public String getTunnus() {
        return getHenkilotunnus();
    }

    @Override
    public toString(){
        return this.nimi + " hetu: " +this.henkilotunnus;
    }
}
  </pre>


  <p>Rajapintojen vahvuus on se, että rajapinta on myös <em>tyyppi</em>. Kaikki rajapinnan toteuttavista luokista tehdyt oliot ovat myös rajapinnan tyyppisiä. Tämä helpottaa sovellusten rakentamista huomattavasti.</p>

  <p>Tehdään luokka <code>Rekisteri</code>, josta voimme hakea henkilöitä tunnisteen perusteella. Yksittäisten henkilöiden hakemisen lisäksi <code>Rekisteri</code> tarjoaa metodin kaikkien henkilöiden hakemiseen listana.</p>

  <pre class="sh_java">
public class Rekisteri {
    private HashMap&lt;String, Tunnistettava&gt; rekisteroidyt;

    public Rekisteri() {
        this.rekisteroidyt = new HashMap&lt;String, Tunnistettava&gt;();
    }

    public void lisaa(Tunnistettava lisattava) {
        this.rekisteroidyt.put(lisattava.getTunnus(), lisattava);
    }

    public Tunnistettava hae(String tunnus) {
        return this.rekisteroidyt.get(tunnus);
    }

    public List&lt;Tunnistettava&gt; haeKaikki() {
        return new ArrayList&lt;Tunnistettava&gt;(rekisteroidyt.values());
    }
}
  </pre>

  <p>Rekisterin käyttö on helppoa</p>

  <pre class="sh_java">
Rekisteri henkilokunta = new Rekisteri();
henkilokunta.lisaa( new Henkilo("Pekka", "221078-123X") );
henkilokunta.lisaa( new Henkilo("Jukka", "110956-326B") );

System.out.println( henkilokunta.hae("280283-111A") );

Henkilo loydetty = (Henkilo)henkilokunta.hae("110956-326B");
System.out.println( loydetty.getNimi() );
  </pre>

  <p>Koska henkilöt on talletettu rekisteriin <code>Tunnistettava</code>-tyyppisinä, joudumme muuntanaan ne takaisin oikeaan tyyppiin jos haluamme käsitellä henkilöitä sellaisten metodien kautta, joita ei rajapinnassa ole määritelty. Näin tapahtuu yllä olevan esimerkin kahdella viimeisellä rivillä.</p>

  <p>Entä jos haluaisimme operaation, joka palauttaa rekisteriin talletetut henkilöt tunnisteen mukaan järjestettynä?</p>

  <p>Yksi luokka voi toteuttaa useamman rajapinnan, eli voimme toteuttaa <code>Henkilo</code>-luokalla rajapinnan <code>Tunnistettava</code> lisäksi viime viikolta tutun rajapinnan <code>Comparable</code>. Useamman rajapinnan toteuttaminen tapahtuu erottamalla toteutettavat rajapinnat toisistaan pilkuilla (<code>public class ... implements <em>RajapintaEka</em>, <em>RajapintaToka</em> ...</code>). Toteuttaessamme useampaa rajapintaa, tulee meidän toteuttaa kaikki rajapintojen vaatimat metodit. Toteutetaan seuraavaksi luokalla <code>Henkilo</code> rajapinta <code>Comparable</code>.</p>

  <pre class="sh_java">
package sovellus.domain;

public class Henkilo implements Tunnistettava, Comparable&lt;Henkilo&gt; {
    private String nimi;
    private String henkilotunnus;

    public Henkilo(String nimi, String henkilotunnus) {
        this.nimi = nimi;
        this.henkilotunnus = henkilotunnus;
    }

    public String getNimi() {
        return this.nimi;
    }

    public String getHenkilotunnus() {
        return this.henkilotunnus;
    }

    @Override
    public String getTunnus() {
        return getHenkilotunnus();
    }

    @Override
    public int compareTo(Henkilo toinen) {
        return this.getTunnus().compareTo(toinen.getTunnus());
    }
}
  </pre>

  <p>Nyt voimme lisätä rekisterille metodin haeKaikkiJarjestyksessa:</p>

  <pre class="sh_java">
    public List&lt;Tunnistettava&gt; haeKaikkiJarjestyksessa() {
        ArrayList&lt;Tunnistettava&gt; kaikki = new ArrayList&lt;Tunnistettava&gt;(rekisteroidyt.values());
        Collections.sort(kaikki);
        return kaikki;
    }
  </pre>

  <p>Huomaamme kuitenkin, että ratkaisumme ei toimi. Koska henkilöt on talletettu rekisteriin <code>Tunnitettava</code>-tyyppisinä, onkin Henkilön toteutettava rajapinta <code>Comparable&lt;Tunnistettava&gt;</code> jotta rekisteri osaisi järjestää henkilöt metodin <code>Collections.sort()</code> avulla. Eli muutamme henkilön toteuttamaa rajapintaa:</p>

  <pre class="sh_java">
public class Henkilo implements Tunnistettava, Comparable&lt;Tunnistettava&gt; {
    // ...

    @Override
    public int compareTo(Tunnistettava toinen) {
        return this.getTunnus().compareTo(toinen.getTunnus());
    }
}
  </pre>

  <p>Nyt ratkaisu toimii!</p>

  <p>Rekisteri on täysin tietämätön sinne talletettavien olioiden todellisesta tyypistä. Voimmekin käyttää luokkaa rekisteri myös muuntyyppisten olioiden kuin henkilöiden rekisteröintiin, kunhan olioiden luokka vaan toteuttaa rajapinnan <code>Tunnistettava</code>. Esim. seuraavassa käytetään rekisteriä kaupassa myytävien tuotteiden hallintaan:</p>

  <pre class="sh_java">
public class Tuote implements Tunnistettava {
    private String nimi;
    private String viivakoodi;
    private int varastosaldo;
    private int hinta;

    public Tuote(String nimi, String viivakoodi) {
        this.nimi = nimi;
        this.viivakoodi = viivakoodi;
    }

    public String getTunniste() {
        return viivakoodi;
    }

    // ...
}

Rekisteri tuotteet = new Rekisteri();
tuotteet.lisaa( new Tuote("maito", "11111111") );
tuotteet.lisaa( new Tuote("piimä", "11111112") );
tuotteet.lisaa( new Tuote("juusto", "11111113") );

System.out.println( tuotteet.hae("99999999") );

Tuote tuote = (Tuote)tuotteet.hae("11111112");
tuote.kasvataSaldoa(100);
tuote.muutaHinta(23);
  </pre>

  <p>Eli olemme tehneet luokasta <code>Rekisteri</code> melko yleiskäyttöisen pitämällä sen riippumattomana konkreettisista luokista. Mikä tähänsa luokka, joka toteuttaa rajapinnan <code>Tunnistettava</code> on rekisterin kanssa käyttökelpoinen. Metodin <code>haeKaikkiJarjestyksessä</code> toimiminen tosin edellyttää luokalta myös vertailtavuuden eli Comparable&lt;Tunnistettava&gt;-rajapinnan toteuttamisen.</p>

  <!--

    <p>Tehdään luokka <code>Henkilorekisteri</code>, josta voimme hakea henkilöitä <code>Tunnistettava</code>-rajapinnan avulla. Yksittäisten henkilöiden hakemisen lisäksi <code>Henkilorekisteri</code> tarjoaa metodin kaikkien henkilöiden hakemiseen listana.</p>

<pre class="sh_java">
public class Henkilorekisteri {
    private HashMap&lt;String, Henkilo&gt; henkilot;

    public Henkilorekisteri(HashMap&lt;String, Henkilo&gt; henkilot) {
        this.henkilot = henkilot;
    }

    public void lisaaHenkilo(Henkilo henkilo) {
        this.henkilot.put(henkilo.getTunnus(), henkilo);
    }

    public void haeHenkiloTunnuksella(Tunnistettava tunnistettava) {
        this.henkilot.get(tunnistettava.getTunnus());
    }

    public List&lt;Henkilo&gt; getHenkilot() {
        return new ArrayList&lt;Henkilo&gt;(henkilot.values());
    }
}
</pre>

    <p>Entä jos haluaisimme järjestää henkilölistan aakkosjärjestykseen?</p>


    <p>Yksi luokka voi toteuttaa useamman rajapinnan, eli voimme toteuttaa <code>Henkilo</code>-luokalla rajapinnan <code>Tunnistettava</code> lisäksi viime viikolta tutun rajapinnan <code>Comparable</code>. Useamman rajapinnan toteuttaminen tapahtuu erottamalla toteutettavat rajapinnat toisistaan pilkuilla (<code>public class ... implements <em>RajapintaEka</em>, <em>RajapintaToka</em> ...</code>). Toteuttaessamme useampaa rajapintaa, tulee meidän toteuttaa kaikki rajapintojen vaatimat metodit. Toteutetaan seuraavaksi luokalla <code>Henkilo</code> rajapinta <code>Comparable</code>.</p>

<pre class="sh_java">
package sovellus.domain;

public class Henkilo implements Tunnistettava, Comparable&lt;Henkilo&gt; {
    private String nimi;
    private String henkilotunnus;

    public Henkilo(String nimi, String henkilotunnus) {
        this.nimi = nimi;
        this.henkilotunnus = henkilotunnus;
    }

    public String getNimi() {
        return this.nimi;
    }

    public String getHenkilotunnus() {
        return this.henkilotunnus;
    }

    @Override
    public String getTunnus() {
        return getHenkilotunnus();
    }

    @Override
    public int compareTo(Henkilo toinen) {
        return this.nimi.compareTo(toinen.getNimi());
    }
}
</pre>

    <p>Nyt henkilöstörekisterin listaa-metodia voidaan laajentaa seuraavaan tapaan:</p>

<pre class="sh_java">
    public List&lt;Henkilo&gt; getHenkilot() {
        ArrayList&lt;Henkilo&gt; henkilot = new ArrayList&lt;Henkilo&gt;(henkilot.values());
        Collections.sort(henkilot);
        return henkilot;
    }
</pre>

-->

  <!--

    <h3>Kassaesimerkki</h3>

    <p>Pohditaan seuraavaksi kauppojen kassalaitteessa olevaan lukijalaitteeseen liittyvää tuotteen tunnistamistoimintoa. Oletetaan että tuotteet sisältävät niihin liittyvän viivakoodin, nimen ja hinnan. Tuotteita kuvastava <code>Tuote</code>-olio toteuttaa aiemmin määritellyn rajapinnan <code>Tunnistettava</code>.</p>

<pre class="sh_java">
package sovellus.domain;

public class Tuote implements Tunnistettava {
    private String viivakoodi;
    private String nimi;
    private int hinta;

    public Tuote(String viivakoodi, String nimi, int hinta) {
        this.viivakoodi = viivakoodi;
        this.nimi = nimi;
        this.hinta = hinta;
    }

    public String getNimi() {
        return this.nimi;
    }

    public int getHinta() {
        return this.hinta;
    }

    @Override
    public String getTunnus() {
        return this.viivakoodi;
    }
}
</pre>

    <p>Toteutetaan seuraavaksi <code>Lukijalaite</code>, joka osaa muuntaa tunnistettavat oliot tuotteiksi. Lukijalaitteen tulee lukea ja tunnistaa tuotteet rajapinnan <code>Tunnistettava</code>-avulla. Toteutetaan luokka <code>Lukijalaite</code> siten, että se sisältää hajautustaulun, josta tuotteet löytyvät tunnisteen perusteella. Lukijalaite on osa sovelluksen logiikkaa, joten lisätään se pakkaukseen <code>sovellus.logiikka</code>.</p>

<pre class="sh_java">
package sovellus.logiikka;

public class Lukijalaite {
    private HashMap&lt;String, Tuote&gt; tuotteet;

    public Lukijalaite(HashMap&lt;String, Tuote&gt; tuotteet) {
        this.tuotteet = tuotteet;
    }

    public Tuote tunnista(Tunnistettava tunnistettava) {
        return this.tuotteet.get(tunnistettava.getTunnus());
    }
}
</pre>

    <p>Lukijalaite-olio palauttaa <code>Tuote</code>-olion jos sen tunnus löytyy lukijalaitteen sisältämästä hajautustaulusta. Luodaan seuraavaksi kassa, joka käyttää lukijalaitetta tuotteiden lisäämiseen ostettujen tuotteiden listalle. Kassalla on metodi <code>public void osta</code>, jolle annetaan luokan <code>Tunnistettava</code>-ilmentymä parametrina. Ostaminen lisää lukijalaitteella tunnistetun tuotteen ostettujen listalle. Jos tuotetta ei tunnisteta, ei tehdä mitään. Metodi <code>tulostaOstokset</code> tulostaa ostettujen tuotteiden nimet.</p>

<pre class="sh_java">
package sovellus.domain;

public class Kassa {
    private Lukijalaite laite;
    private List&lt;Tuote&gt; tuotteet;

    public Kassa(Lukijalaite lukijalaite) {
        this.laite = lukijalaite;
        this.tuotteet = new ArrayList&lt;Tuote&gt;();
    }

    public void osta(Tunnistettava tunnistettava) {
        Tuote tunnistettu = this.laite.tunnista(tunnistettava);
        if (tunnistettu == null) {
            return;
        }

        this.tuotteet.add(tunnistettu);
    }

    public void tulostaOstokset() {
        for(Tuote tuote: this.tuotteet) {
            System.out.println(tuote.getNimi());
        }
    }
}
</pre>

    <p>Huomaamme tässä vaiheessa että tuotteiden lukeminen listalta, joka on tulostettu tuotteiden lisäysjärjestyksessä, on hyvin kuormittavaa asiakkaalle. Muokataan tulostusta siten, että tuotteet listataan aakkosjärjestyksessä. Lisätään <code>Tuote</code>-luokalle rajapinta <code>Comparable</code>, jonka avulla tuotteet voidaan järjestää aakkosjärjestyksessä.</p>

<pre class="sh_java">
package sovellus.domain;

public class Tuote implements Tunnistettava, Comparable&lt;Tuote&gt; {
    private String viivakoodi;
    private String nimi;
    private int hinta;

    public Tuote(String viivakoodi, String nimi, int hinta) {
        this.viivakoodi = viivakoodi;
        this.nimi = nimi;
        this.hinta = hinta;
    }

    public String getNimi() {
        return this.nimi;
    }

    public int getHinta() {
        return this.hinta;
    }

    @Override
    public String getTunnus() {
        return this.viivakoodi;
    }

    @Override
    public int compareTo(Tuote tuote) {
        return this.nimi.compareTo(tuote.getNimi());
    }
}
</pre>

    <p>Muokataan vielä kassaan liittyvää toiminnallisuutta siten, että tuotteet järjestetään tarvittaessa. Huomaa että tuotteita tarvitsee järjestää vain silloin kun tuotteita <em>ostetaan</em>. Ostaminen on ainut tilanne, jossa tuotteita sisältävän listan järjestys mahdollisesti muuttuu. Tällöin ostokset ovat aina järjestyksessä metodia <code>tulostaOstokset</code> kutsuttaessa.</p>

<pre class="sh_java">
package sovellus.domain;

public class Kassa {
    private Lukijalaite laite;
    private List&lt;Tuote&gt; tuotteet;

    public Kassa(Lukijalaite lukijalaite) {
        this.laite = lukijalaite;
        this.tuotteet = new ArrayList&lt;Tuote&gt;();
    }

    public void osta(Tunnistettava tunnistettava) {
        Tuote tunnistettu = this.laite.tunnista(tunnistettava);
        if (tunnistettu == null) {
            return;
        }

        this.tuotteet.add(tunnistettu);
        Collections.sort(this.tuotteet);
    }

    public void tulostaOstokset() {
        for(Tuote tuote: this.tuotteet) {
            System.out.println(tuote.getNimi());
        }
    }
}
</pre>

-->

  <div>
    <big><big><b>Muutama NetBeans-vihje</b></big></big>
    <ul>
      <!-- TODO -->
      <li> Kaikki NetBeans-vihjeet löytyvät <a href="../../nb-vihjeet">täältä</a> </li>
      <p></p>

      <li> <b>Implement all abstract methods</b>

      <p>
      Oletetaan että ohjelmassasi on rajapinta <code>Rajapinta</code>, ja olet tekemässä rajapinnan toteuttavaa luokkaa <code>Luokka</code>. Joudut näkemään hieman vaivaa kirjoittaessasi toteuttavaan luokkaan rajapinnan määrittelemien metodien esittelyrivit.
      </p>

      <p>On kuitenkin mahdollista pyytää NetBeansia täydentämään automaattisesti metodirungot toteuttavalle luokalle. Kun olet määritellyt luokan toteuttavan rajapinnan, eli kirjoittanut</p>

      <pre class="sh_java">
public class Luokka implements Rajapinta {
}
      </pre>

      <p>NetBeans värjää luokan nimen punaisella. Mene rivin vasemmassa reunassa olevan lamppusymbolin kohdalle, klikkaa ja valitse <em>Implement all abstract methods</em> ja metodirungot ilmestyvät koodiin!</p>

      </li>

      <li> <b>Clean and Build</b>

      <p>
      Tietyissä tilanteissa NetBeans saattaa mennä sekaisin ja yrittää ajaa koodista versiota johon ei ole huomioitu kaikkia koodiin kirjoitettuja muutoksia. Yleensä huomaat tilanteen siten, että jotain "outoa" vaikuttaa tapahtuvan. Ongelman korjaa usein <em>Clean and build</em> -operaation suorittaminen. Operaatio löytyy Run-valikosta ja sen voi suorittaa myös painamalla <em>harja ja vasara</em> -symbolia. Clean and build poistaa koodista olemassa olevat käännetyt versiot ja tekee uuden käännöksen.
      </p>

      </li>
    </ul>
  </div>

  <div class="tehtavat">
    <div class="tehtava">

      <h3>Muuttaminen</h3>

      <p>Muuttokuormaa pakattaessa esineitä lisätään muuttolaatikoihin siten, että tarvittujen muuttolaatikoiden määrä on mahdollisimman pieni. Tässä tehtävässä simuloidaan esineiden pakkaamista muuttolaatikoihin. Jokaisella esineellä on tilavuus, ja muuttolaatikoilla on maksimitilavuus.</p>


      <h4>Tavara ja Esine</h4>

      <p>Muuttomiehet siirtävät tavarat myöhemmin rekka-autoon (ei toteuteta tässä), joten toteutetaan ensin kaikkia esineitä ja laatikoita kuvaava <code>Tavara</code>-rajapinta.</p>

      <p>Tavara-rajapinnan tulee määritellä metodi <code>int getTilavuus()</code>, jonka avulla tavaroita käsittelevät saavat selville kyseisen tavaran tilavuuden. Toteuta rajapinta <code>Tavara</code> pakkaukseen <code>muuttaminen.domain</code>.</p>

      <p>Toteuta seuraavaksi pakkaukseen <code>muuttaminen.domain</code> luokka <code>Esine</code>, joka saa konstruktorin parametrina esineen nimen (String) ja esineen tilavuuden (int). Luokan tulee toteuttaa rajapinta <code>Tavara</code>.</p>

      <p>Lisää luokalle <code>Esine</code> myös metodit <code>public String getNimi()</code> ja korvaa metodi <code>public String toString()</code> siten että se tuotta merkkijonoja muotoa "<code>nimi (tilavuus dm^3)</code>". Esineen pitäisi toimia nyt jotakuinkin seuraavasti</p>

      <pre class="sh_java">
    Tavara esine = new Esine("hammasharja", 2);
    System.out.println(esine);
      </pre>

      <pre>
hammasharja (2 dm^3)
      </pre>

      <h4>Esine vertailtavaksi</h4>

      <p>Pakatessamme esineitä muuttolaatikkoon haluamme aloittaa pakkaamisen järjestyksessä olevista esineistä. Toteuta <code>Esine</code>-luokalla rajapinta <code>Comparable</code> siten, että esineiden <em>luonnollinen järjestys</em> on tilavuuden mukaan nouseva. Kun olet toteuttanut esineellä rajapinnan <code>Comparable</code>, tulee niiden toimia <code>Collections</code>-luokan <code>sort</code>-metodin kanssa seuraavasti.</p>


      <pre class="sh_java">
    List&lt;Esine&gt; esineet = new ArrayList&lt;Esine&gt;();
    esineet.add(new Esine("passi", 2));
    esineet.add(new Esine("hammasharja", 1));
    esineet.add(new Esine("sirkkeli", 100));

    Collections.sort(esineet);
    System.out.println(esineet);
      </pre>

      <pre>
[hammasharja (1 dm^3), passi (2 dm^3), sirkkeli (100 dm^3)]
      </pre>

      <h4>Muuttolaatikko</h4>

      <p>Toteuta tämän jälkeen pakkaukseen <code>muuttaminen.domain</code> luokka <code>Muuttolaatikko</code>. Tee aluksi muuttolaatikolle seuraavat:</p>

      <p>
      <ul>
        <li><code>public Muuttolaatikko(int maksimitilavuus)</code></li>Muuttolaatikko-luokan konstruktori. Saa parametrina muuttolaatikon maksimitilavuuden.<br/>
        <li><code>public boolean lisaaTavara(Tavara tavara)</code></li> Lisää muuttolaatikkoon <code>Tavara</code>-rajapinnan toteuttaman esineen. Jos laatikkoon ei mahdu, metodi palauttaa arvon <code>false</code>. Jos tavara mahtuu laatikkoon, metodi palauttaa arvon <code>true</code>. Muuttolaatikon tulee tallettaa tavarat listaan.<br/>
      </ul>
      </p>

      <p>Laita vielä  <code>Muuttolaatikko</code> toteuttamaan rajapinta <code>Tavara</code>. Metodilla <code>getTilavuus</code> tulee saada selville muuttolaatikossa olevien tavaroiden tämänhetkinen yhteistilavuus.</p>

      <h4>Esineiden pakkaaminen</h4>

      <p>Toteuta luokka <code>Pakkaaja</code> pakkaukseen <code>muuttaminen.logiikka</code>. Luokan <code>Pakkaaja</code> konstruktorille annetaan parametrina <code>int laatikoidenTilavuus</code>, joka määrittelee minkä kokoisia muuttolaatikoita pakkaaja käyttää.</p>

      <p>Toteuta tämän jälkeen luokalle metodi <code>public List&lt;Muuttolaatikko&gt; pakkaaTavarat(List&lt;Tavara&gt; tavarat)</code>, joka pakkaa tavarat muuttolaatikoihin.</p>

      <p>Tee metodista sellainen, että kaikki parametrina annetussa listassa olevat tavarat päätyvät palautetussa listassa oleviin muuttolaatikoihin. Sinun ei tarvitse varautua tilanteisiin, joissa tavarat ovat suurempia kuin pakkaajan käyttämä muuttolaatikon koko. Testit eivät välitä siitä kuinka täyteen pakkaaja täyttää muuttolaatikot.</p>

      <p>Seuraavassa pakkaajan toimintaa demonstroiva esimerkki:</p>

      <pre class="sh_java">
    // tavarat jotka haluamme pakata
    List&lt;Tavara&gt; tavarat = new ArrayList&lt;Tavara&gt;();
    tavarat.add(new Esine("passi", 2));
    tavarat.add(new Esine("hammasharja", 1));
    tavarat.add(new Esine("kirja", 4));
    tavarat.add(new Esine("sirkkeli", 8));

    // luodaan pakkaaja, joka käyttää tilavuudeltaan 10:n kokoisia muuttolaatikoita
    Pakkaaja pakkaaja = new Pakkaaja(10);

    // pyydetään pakkaajaa pakkaamaan tavarat laatikoihin
    List&lt;Muuttolaatikko&gt; laatikot = pakkaaja.pakkaaTavarat( tavarat );

    System.out.println("laatikoita: "+laatikot.size());

    for (Muuttolaatikko laatikko : laatikot) {
        System.out.println("  laatikossa tavaraa: "+laatikko.getTilavuus()+" dm^3");
    }
      </pre>

      <p>Tulostuu:</p>

      <pre>
laatikoita: 2
  laatikossa tavaraa: 7 dm^3
  laatikossa tavaraa: 8 dm^3
      </pre>

      <p>Pakkaaja on siis pakannut tavarat kahteen laatikkoon, ensimmäiseen laatikkoon on mennyt 3 ensimmäistä tavaraa, yhteistilavuudeltaan 7, ja listan viimeinen tavara eli sirkkeli jonka tilavuus on 8 on mennyt toiseen laatikkoon. Testit eivät aseta rajoitusta pakkaajan käyttävien muuttolaatioiden määrälle, tavarat olisi siis voitu pakata vaikka jokainen eri laatikkoon, eli tuloste olisi ollut:</p>

      <p>Tulostuu:</p>

      <pre>
laatikoita: 4
  laatikossa tavaraa: 2 dm^3
  laatikossa tavaraa: 1 dm^3
  laatikossa tavaraa: 7 dm^3
  laatikossa tavaraa: 8 dm^3
      </pre>

      <p><strong>Huom:</strong> tehtävän testaamista helpottamaan kannatanee tehdä luokalle <code>Muuttolaatikko</code> esim. toString-metodi, jonka avulla voi printata laatikon sisällön.</p>

      <!--

  <h4>Tehokkaampi pakkaaminen</h4>

  <p>Alla on kuvattu eräs hieman tehokkaampi pakkaustapa <em>pseudokoodina</em>, eli ohjelmointikielen tapaisena koodina. Pseudokoodia käytetään muun muassa ohjelmointikieliriippumattomaan algoritmien eli ohjelmien kuvaamiseen.</p>

<pre>
pakkaaEsineet( esineet ):
    jarjesta( esineet )

    laatikot = [] // huom, kannattaa käyttää ArrayListiä

    while esineet is not empty:
        Muuttolaatikko pakattu = pakkaaLaatikko( esineet )
        laatikot.add( pakattu )

    return laatikot

pakkaaLaatikko( esineet ):
    Muuttolaatikko laatikko = new Muuttolaatikko

    lisaaSuuria( esineet, laatikko )
    lisaaPienia( esineet, laatikko )

    return laatikko

lisaaSuuria( esineet, laatikko ):
    while esineet is not empty:
        esine = suurin( esineet )

        if lisaa ( laatikko, esine ) == false:
            return

lisaaPienia(List esineet, Muuttolaatikko laatikko):
    while esineet is not empty:
        esine = pienin( esineet )

        if lisaa ( laatikko, esine ) == false:
            return
</pre>

  <p>Muokkaa luokkaa <code>Pakkaaja</code> siten, että se toimii samoin tai paremmin kuin yllä kuvattu lähestymistapa.</p>

  <p>Metodissa <code>pakkaaEsineet</code> pakataan muuttolaatikoita niin pitkään kun <code>esineet</code>-listalla on esineitä. Muuttolaatikkoa pakattaessa algoritmi lisää laukkuun ensiksi niin paljon suurimpia esineitä kuin laatikkoon mahtuu. Kun laatikkoon ei enää mahdu suurimpia esineitä, aletaan täyttämään sitä pienimmillä esineillä.</p>

  <p>Toteutuksesta: Kun esineesi ovat järjestyksessä, suurin tavara löytyy indeksistä <code>esinelistan koko - 1</code>, pienin tavara löytyy indeksistä <code>0</code>. Älä käytä tässä <code>Collections.min</code> ja <code>Collections.max</code>-metodeja, sillä ne eivät osaa arvata että <code>ArrayList</code>-lista on jo järjestyksessä.</p>

  <p>Poista esineitä <code>esineet</code>-listalta sitä mukaa kun niitä on lisätty muuttolaatikoihin. Sinun ei tarvitse varautua tilanteisiin joissa esineet ovat suurempia kuin muuttolaatikko.</p>

  <p><em>Huom!</em> Saadaksesi pisteen tästä viimeisestä tehtävästä algoritmisi tulee toimia <em>vähintään</em> yhtä hyvin kuin yllä kuvattu algoritmi. Hyvyydellä tarkoitetaan sitä, että pakkaukseen kulunut aika tulee olla vähintään yhtä pieni kuin pseudokoodiratkaisun. Muuttolaatikkojen määrän tulee myös olla vähintään yhtä pieni.</p>

  <p>Voit käyttää seuraavaa metodia satunnaisten esineiden luomiseen.</p>

<pre class="sh_java">
    public static List&lt;Esine&gt; luoEsineet(int kpl, int maxTilavuus) {
        Random rand = new Random();

        List&lt;Esine&gt; esineet = new ArrayList&lt;Esine&gt;();
        for (int i = 0; i &lt; kpl; i++) {
            esineet.add(new Esine("hammasharja", 1 + rand.nextInt(maxTilavuus)));
        }

        return esineet;
    }
</pre>

  <p>Yllä kuvatulla algoritmilla pakkaamisen pitäisi toimia nopeasti jopa 100000 esinettä sisältävillä listoilla. Voit testata pakkaajasi nopeutta esimerkiksi seuraavasti:</p>

<pre class="sh_java">
        List&lt;Esine&gt; esineet = luoEsineet(100000, 10);
        Pakkaaja pakkaaja = new Pakkaaja(50);

        long start = System.nanoTime();
        List&lt;Muuttolaatikko&gt; laatikot = pakkaaja.pakkaaEsineet(esineet);
        long kulunutAika = ((System.nanoTime() - start) / 1000000);

        System.out.println("Pakkaukseen kului " + kulunutAika + " ms.");
        System.out.println("Tarvittiin " + laatikot.size() + " laatikkoa.");
</pre>

-->
    </div>
  </div>

  <h2>Poikkeustilanteet</h2>

  <p>Poikkeustilanteet ovat tilanteita joissa ohjelman suoritus ei ole edennyt toivotusti. Ohjelma on saattanut esimerkiksi kutsua <em>null</em>-viitteeseen liittyvää metodia, jolloin käyttäjälle <em>heitetään</em> poikkeus <code>NullPointerException</code>. Jos yritämme hakea taulukon ulkopuolella olevaa indeksiä, käyttäjälle heitetään poikkeus <code>IndexOutOfBoundsException</code>. Kaikki poikkeukset ovat tyyppiä <code>Exception</code>.</p>

  <p>Poikkeukset käsitellään <code>try { } catch (Exception e) { }</code> -lohkorakenteella. Avainsanan <code>try</code> aloittaman lohkon sisällä on <em>mahdollisesti</em> poikkeuksen heittävä ohjelmakoodi. Avainsanan <code>catch</code> aloittaman lohkon sisällä taas määritellään mitä tehdään jos try-lohkossa suoritettavassa koodissa tapahtuu poikkeus. Catch-lauseelle määritellään kiinniotettavan poikkeuksen tyyppi (<code>catch (Exception e)</code>).</p>

  <pre class="sh_java">
    try {
        // poikkeuksen mahdollisesti heittävä ohjelmakoodi
    } catch (Exception e) {
        // lohko johon päädytään poikkeustilanteessa
    }
  </pre>

  <p>Merkkijonon numeroksi muuttava <code>Integer</code>-luokan <code><a href="http://docs.oracle.com/javase/6/docs/api/java/lang/Integer.html#parseInt(java.lang.String)" target="_blank">parseInt</a></code>-metodi heittää poikkeuksen <code>NumberFormatException</code> jos sille parametrina annettu merkkijono ei ole muunnettavissa numeroksi. Toteutetaan ohjelma, joka yrittää muuntaa käyttäjän syöttämän merkkijonon numeroksi.</p>

  <pre class="sh_java">
    Scanner lukija = new Scanner(System.in);
    System.out.print("Syötä numero: ");

    int numero = Integer.parseInt(lukija.nextLine());
  </pre>

  <pre>
Syötä numero: <font color="red">tatti</font>
<font color="red">Exception in thread "..." java.lang.NumberFormatException: For input string: "tatti"</font>
  </pre>

  <p>Yllä oleva ohjelma heittää poikkeuksen kun käyttäjä syöttää virheellisen numeron. Ohjelman suoritus päättyy virhetilanteeseen, eikä suoritusta voi enää jatkaa. Lisätään ohjelmaan poikkeuskäsittely. Kutsu, joka saattaa heittää poikkeuksen asetetaan <code>try</code>-lohkon sisään, ja virhetilanteessa tapahtuva toiminta <code>catch</code>-lohkon sisään. </p>

  <pre class="sh_java">
    Scanner lukija = new Scanner(System.in);

    System.out.print("Syötä numero: ");

    try {
        int numero = Integer.parseInt(lukija.nextLine());
    } catch (Exception e) {
        System.out.println("Et syöttänyt kunnollista numeroa.");
    }
  </pre>

  <pre>
Syötä numero: <font color="red">5</font>
  </pre>

  <pre>
Syötä numero: <font color="red">enpäs!</font>
Et syöttänyt kunnollista numeroa.
  </pre>

  <p>Avainsanan <code>try</code> määrittelemän lohkon sisältä siirrytään <code>catch</code>-lohkoon heti poikkeuksen tapahtuessa.  Visualisoidaan tätä lisäämällä tulostuslause <code>try</code>-lohkossa metodia <code>Integer.parseInt</code> kutsuvan rivin jälkeen.</p>

  <pre class="sh_java">
    Scanner lukija = new Scanner(System.in);

    System.out.print("Syötä numero: ");

    try {
        int numero = Integer.parseInt(lukija.nextLine());
        System.out.println("Hienosti syötetty!");
    } catch (Exception e) {
        System.out.println("Et syöttänyt kunnollista numeroa.");
    }
  </pre>


  <pre>
Syötä numero: <font color="red">5</font>
Hienosti syötetty!
  </pre>

  <pre>
Syötä numero: <font color="red">enpäs!</font>
Et syöttänyt kunnollista numeroa.
  </pre>

  <p>Ohjelmalle syötetty merkkijono <code>enpäs!</code> annetaan parametrina <code>Integer.parseInt</code>-metodille, joka heittää poikkeuksen jos parametrina saadun merkkijonon muuntaminen luvuksi epäonnistuu. Huomaa että <code>catch</code>-lohkossa oleva koodi suoritetaan <em>vain</em> poikkeustapauksissa -- muulloin ohjelma ei pääse sinne.</p>

  <p>Tehdään luvun muuntajasta hieman hyödyllisempi: Tehdään siitä metodi, joka kysyy numeroa yhä uudestaan kunnes käyttäjä syöttää oikean numeron. Metodista pääsee pois <em>vain</em> jos käyttäjä syöttää oikean luvun.</p>

  <pre class="sh_java">
public int lueLuku(Scanner lukija) {
    while (true) {
        System.out.print("Syötä numero: ");

        try {
            int numero = Integer.parseInt(lukija.nextLine());
            return numero;
        } catch (Exception e) {
            System.out.println("Et syöttänyt kunnollista numeroa.");
        }
    }
}
  </pre>

  <p>Metodin <code>lueLuku</code> kutsuminen voisi toimia esimerkiksi seuraavasti</p>

  <pre>
Syötä numero: <font color="red">enpäs!</font>
Et syöttänyt kunnollista numeroa.
Syötä numero: <font color="red">Matilla on ovessa tatti.</font>
Et syöttänyt kunnollista numeroa.
Syötä numero: <font color="red">43</font>

  </pre>


  <h3>Poikkeusten heittäminen</h3>

  <p>Metodit ja konstruktorit voivat <em>heittää</em> poikkeuksia. Heitettäviä poikkeuksia on karkeasti ottaen kahdenlaisia. On poikkeuksia jotka on pakko käsitellä, ja on poikkeuksia joita ei ole pakko käsitellä. Pakosti käsiteltävät poikkeukset käsitellään joko <code>try-catch</code> -lohkossa, tai <em>heittämällä ne ulos metodista</em>. </p>

  <p>
  Ohjelmoinnin perusteiden tehtävän <em>kellosta olio</em> bonusversiossa kerrottiin, että ohjelma saadaan viivyttämään itseään sekunnin verran kutsumalla komentoa <code>Thread.sleep(1000)</code>. Komento saattaa heittää poikkeuksen, joka on <em>pakko</em> käsitellä. Poikkeuksen käsittely siis tapahtuu  <code>try-catch</code> -lauseella, seuraavassa esimerkissä olemme välittämättä mahdollisista poikkeustilanteista ja jätimme <code>catch</code>-lohkon tyhjäksi:</p>

  <pre class="sh_java">
    try {
        // nukutaan 1000 millisekuntia
        Thread.sleep(1000);
    } catch (Exception e) {
        // ei tehdä mitään poikkeustilanteessa
    }
  </pre>

  <p>Metodeissa on myös mahdollista jättää poikkeus itse käsittelemättä ja <em>siirtää vastuu</em> poikkeuksen käsittelystä metodin kutsujalle. Vastuun siirto tapahtuu heittämällä poikkeus metodista eteenpäin sanomalla <code>throws Exception</code>.</p>

  <pre class="sh_java">
    public void nuku(int sekuntia) <strong>throws Exception</strong> {
        Thread.sleep(sekuntia * 1000);   // nyt try-catchia ei tarvita!
    }
  </pre>

  <p>Nyt metodia <code>nuku</code>-kutsuvan metodin tulee joko käsitellä poikkeus <code>try-catch</code> -lohkossa, tai siirtää poikkeuksen käsittelyn vastuuta eteenpäin heittää poikkeus eteenpäin. Joskus poikkeuksen käsittelyä pakoillaan viimeiseen asti, ja <code>main</code>-metodikin heittää poikkeuksen käsiteltäväksi eteenpäin:</p>
  <pre class="sh_java">
public class Paaohjelma {
   public static void main(String[] args) throws Exception {
       // ...
   }
}
  </pre>

  <p>Tällöin poikkeus päätyy Javan virtuaalikoneelle, joka keskeyttää ohjelman suorituksen poikkeukseen johtavan virheen tapahtuessa.</p>

  <p>Osa poikkeuksista, kuten <code>Integer.parseInt</code>-metodin heittämä <code>NumberFormatException</code>, on sellaisia joihin ohjelmoijan ei ole pakko varautua. Poikkeukset, joihin käyttäjän ei tarvitse varautua ovat aina myös tyyppiä <code>RuntimeException</code>, palaamme siihen <em>miksi</em> muuttujilla voi olla useita eri tyyppejä tarkemmin ensi viikolla.</p>

  <p>Voimme itse heittää poikkeuksen lähdekoodista <code>throw</code>-komennolla. Esimerkiksi <code>NumberFormatException</code>-luokasta luodun poikkeuksen heittäminen tapahtuisi komennolla <code>throw new NumberFormatException()</code>.</p>

  <p>Eräs poikkeus johon käyttäjän ei ole pakko varautua on <code>IllegalArgumentException</code>. Poikkeuksella <code>IllegalArgumentException</code> kerrotaan että metodille tai konstruktorille annettujen parametrien arvot ovat <em>vääränlaiset</em>. IllegalArgumentException-poikkeusta käytetään esimerkiksi silloin kun halutaan varmistaa että parametreilla on tietyt arvot. Luodaan luokka <code>Arvosana</code>, joka saa konstruktorin parametrina kokonaislukutyyppisen arvosanan.</p>

  <pre class="sh_java">
public class Arvosana {
    private int arvosana;

    public Arvosana(int arvosana) {
        this.arvosana = arvosana;
    }

    public int getArvosana() {
        return this.arvosana;
    }
}
  </pre>

  <p>Haluamme seuraavaksi <em>validoida</em> Arvosana-luokan konstruktorin parametrina saadun arvon. Arvosanan tulee olla aina välillä 0-5. Jos arvosana on jotain muuta, haluamme <em>heittää poikkeuksen</em>. Lisätään <code>Arvosana</code>-luokan konstruktoriin ehtolause, joka tarkistaa onko arvosana arvovälin 0-5 ulkopuolella. Jos on, heitetään poikkeus <code>IllegalArgumentException</code> sanomalla <code>throw new IllegalArgumentException("Arvosanan tulee olla välillä 0-5");</code>.</p>

  <pre class="sh_java">
public class Arvosana {
    private int arvosana;

    public Arvosana(int arvosana) {
        if (arvosana &lt; 0 || arvosana &gt; 5) {
            throw new IllegalArgumentException("Arvosanan tulee olla välillä 0-5");
        }
        this.arvosana = arvosana;
    }

    public int getArvosana() {
        return this.arvosana;
    }
}
  </pre>

  <pre class="sh_java">
    Arvosana arvosana = new Arvosana(3);
    System.out.println(arvosana.getArvosana());

    Arvosana virheellinenArvo = new Arvosana(22);
    // tapahtuu poikkeus, tästä ei jatketa eteenpäin
  </pre>

  <pre>
3
Exception in thread "..." java.lang.IllegalArgumentException: Arvosanan tulee olla välillä 0-5
  </pre>


  <div class="tehtavat">
    <div class="tehtava">
      <h3>Parametrien validointi</h3>

      <p>Harjoitellaan hieman parametrien validointia <code>IllegalArgumentException</code>-poikkeuksen avulla. Tehtäväpohjassa tulee kaksi luokkaa, <code>Henkilo</code> ja <code>Laskin</code>. Muuta luokkia seuraavasti:</p>

      <h4>Henkilön validointi</h4>

      <p>Luokan <code>Henkilo</code> konstruktorin tulee varmistaa että parametrina annettu nimi ei ole null, tyhjä tai yli 40 merkkiä pitkä. Myös iän tulee olla väliltä 0-120. Jos joku edelläolevista ehdoista ei päde, tulee konstruktorin heittää <code>IllegalArgumentException</code>-poikkeus.</p>

      <h4>Laskimen validointi</h4>

      <p>Luokan <code>Laskin</code> metodeja tulee muuttaa seuraavasti: Metodin <code>kertoma</code> tulee toimia vain jos parametrina annetaan ei-negatiivinen luku (0 tai suurempi). Metodin <code>binomikerroin</code> tulee toimia vain jos parametrit ovat ei-negatiivisia ja osajoukon koko on pienempi kuin joukon koko. Jos jompikumpi metodeista saa epäkelpoja arvoja metodikutsujen yhteydessä, tulee metodien heittää poikkeus <code>IllegalArgumentException</code>.</p>
    </div>
    <div class="tehtava">

      <h3>Sensorit ja lämpötilan mittausta</h3>

      <p>Kaikki sovelluksessa oleva koodi tulee sijoittaa pakkaukseen <code>sovellus</code>.</p>

      <p>Käytössämme on seuraava rajapinta:</p>

      <pre class="sh_java">
public interface Sensori {
    boolean onPaalla();  // palauttaa true jos sensori on päällä
    void paalle();       // käynnistä sensorin
    void poisPaalta();   // sulkee sensorin
    int mittaa();        // palauttaa sensorin lukeman jos sensori on päällä
                         // jos sensori ei päällä heittää poikkeuksen IllegalStateException
}
      </pre>

      <h4>Vakiosensori</h4>

      <p>Tee luokka <code>Vakiosensori</code> joka toteuttaa rajapinnan <code>Sensori</code>.</p>

      <p>Vakiosensori on koko ajan päällä. Metodien paalle ja poisPaalta kutsuminen ei tee mitään. Vakiosensorilla tulee olla konstruktori, jonka parametrina on kokonaisluku. Metodikutsu <code>mittaa</code> palauttaa aina konstruktorille parametrina annetun luvun.
      </p>

      <p>Esimerkki:</p>

      <pre class="sh_java">
public static void main(String[] args) {
  Vakiosensori kymppi = new Vakiosensori(10);
  Vakiosensori miinusViis = new Vakiosensori(-5);

  System.out.println( kymppi.mittaa() );
  System.out.println( miinusViis.mittaa() );

  System.out.println( kymppi.onPaalla() );
  kymppi.poisPaalta();
  System.out.println( kymppi.onPaalla() );
}
      </pre>

      <p>Tulostuu:</p>

      <pre>
10
-5
true
true
      </pre>

      <h4>Lampomittari</h4>

      <p>Tee luokka <code>Lampomittari</code> joka toteuttaa rajapinnan <code>Sensori</code>.</p>

      <p>
      Aluksi lämpömittari on poissa päältä. Kutsuttaessa metodia <code>mittaa</code> kun mittari on päällä mittari arpoo luvun väliltä -30...30 ja palauttaa sen kutsujalle. Jos mittari ei ole päällä, heitetään poikkeus </code>IllegalStateException</code>.
  </p>

  <h4>Keskiarvosensori</h4>

  <p>Tee luokka <code>Keskiarvosensori</code> joka toteuttaa rajapinnan </code>Sensori</code>.</p>

<p>
Keskiarvosensori sisältää useita sensoreita. Rajapinnan <code>Sensori</code> määrittelemien metodien lisäksi keskiarvosensorilla on metodi
<code>public void lisaaSensori(Sensori lisattava)</code> jonka avulla keskiarvosensorin hallintaan lisätään uusi sensori.
</p>

<p>
Keskiarvosensori on päällä silloin kuin <em>kaikki</em> sen sisältävät sensorit ovat päällä. Kun keskiarvosensori käynnistetään, täytyy kaikkien sen sisältävien sensorien käynnistyä jos ne eivät ole käynnissä. Kun keskiarvosensori suljetaan, täytyy ainakin yhden sen sisältävän sensorin mennä pois päältä. Saa myös käydä niin että kaikki sen sisältävät sensorit menevät pois päältä.
</p>

<p>
Keskiarvosensorin metodi <code>mittaa</code> palauttaa sen sisältämien sensoreiden lukemien keskiarvon (koska paluuarvo on <code>int</code>, pyöristyy lukema alaspäin kuten kokonaisluvuilla tehdyissä jakolaskuissa). Jos keskiarvosensorin metodia <code>mittaa</code> kutsutaan sensorin ollessa poissa päältä, tai jos keskiarvosensorille ei vielä ole lisätty yhtään sensoria heitetään poikkeus <code>IllegalStateException</code>.
</p>

<p>Seuraavassa sensoreja käyttävä esimerkkiohjelma (huomaa, että sekä Lämpömittarin että Keskiarvosensorin konstruktorit ovat parametrittomia):</p>

<pre class="sh_java">
public static void main(String[] args) {
    Sensori kumpula = new Lampomittari();
    kumpula.paalle();
    System.out.println("lämpötila Kumpulassa "+kumpula.mittaa() + " astetta");

    Sensori kaisaniemi = new Lampomittari();
    Sensori helsinkiVantaa = new Lampomittari();

    Keskiarvosensori paakaupunki = new Keskiarvosensori();
    paakaupunki.lisaaSensori(kumpula);
    paakaupunki.lisaaSensori(kaisaniemi);
    paakaupunki.lisaaSensori(helsinkiVantaa);

    paakaupunki.paalle();
    System.out.println("lämpötila Pääkaupunkiseudulla "+paakaupunki.mittaa() + " astetta");
}
</pre>

<p>tulostuu (tulostetut lukuarvot riippuvat tietenkin arvotuista lämpötiloista):</p>

<pre class="sh_java">
lämpötila Kumpulassa -7 astetta
lämpötila Pääkaupunkiseudulla -10 astetta
</pre>

<p><b>Huom:</b> kannatata käyttää Vakiosensori-oliota keskiarvosensorin testaamiseen!</p>

<h4>Kaikki mittaukset</h4>

<p>Lisää luokalle Keskiarvosensori metodi <code>public List&lt;Integer&gt; mittaukset()</code>, joka palauttaa listana kaikkien keskiarvosensorin avulla suoritettujen mittausten tulokset. Seuraavassa esimerkki metodin toiminnasta: </p>

<pre class="sh_java">
public static void main(String[] args) {
    Sensori kumpula = new Lampomittari();
    Sensori kaisaniemi = new Lampomittari();
    Sensori helsinkiVantaa = new Lampomittari();

    Keskiarvosensori paakaupunki = new Keskiarvosensori();
    paakaupunki.lisaaSensori(kumpula);
    paakaupunki.lisaaSensori(kaisaniemi);
    paakaupunki.lisaaSensori(helsinkiVantaa);

    paakaupunki.paalle();
    System.out.println("lämpötila Pääkaupunkiseudulla "+paakaupunki.mittaa() + " astetta");
    System.out.println("lämpötila Pääkaupunkiseudulla "+paakaupunki.mittaa() + " astetta");
    System.out.println("lämpötila Pääkaupunkiseudulla "+paakaupunki.mittaa() + " astetta");

    System.out.println("mittaukset: "+paakaupunki.mittaukset());
}
</pre>

<p>tulostuu (tulostetut lukuarvot riippuvat jälleen arvotuista lämpötiloista):</p>

<pre class="sh_java">
lämpötila Pääkaupunkiseudulla -10 astetta
lämpötila Pääkaupunkiseudulla -4 astetta
lämpötila Pääkaupunkiseudulla 5 astetta

mittaukset: [-10, -4, 5]
</pre>

</div>
</div>

<h3>Poikkeukset ja rajapinnat</h3>

    <p>Rajapintaluokilla ei ole metodirunkoa, mutta metodimäärittely on vapaasti rajapinnan suunnittelijan toteutettavissa. Rajapintaluokat voivat määritellä myös poikkeusten heiton. Esimerkiksi seuraavan rajapinnan <code>Tiedostopalvelin</code> toteuttavat luokat heittävät <em>mahdollisesti</em> poikkeuksen <code>lataa</code>- ja <code>tallenna</code>-metodissa.</p>

<pre class="sh_java">
public interface Tiedostopalvelin {
    String lataa(String tiedosto) throws Exception;
    void tallenna(String tiedosto, String merkkijono) throws Exception;
}
</pre>

    <p>Jos rajapinta määrittelee metodeille <code>throws Exception</code>-määreet, eli että metodit heittävät mahdollisesti poikkeuksen, tulee samat määreet olla myös rajapinnan toteuttavassa luokassa. Luokan ei kuitenkaan ole pakko heittää poikkeusta kuten alla olevasta esimerkistä näkee.</p>

<pre class="sh_java">
public class Tekstipalvelin implements Tiedostopalvelin {

    private Map&lt;String, String&gt; data;

    public Tekstipalvelin() {
        this.data = new HashMap&lt;String, String&gt;();
    }

    @Override
    public String lataa(String tiedosto) throws Exception {
        return this.data.get(tiedosto);
    }

    @Override
    public void tallenna(String tiedosto, String merkkijono) throws Exception {
        this.data.put(tiedosto, merkkijono);
    }
}
</pre>

<h3>Poikkeuksen tiedot</h3>

    <p>Poikkeusten käsittelytoiminnallisuuden sisältämä <code>catch</code>-lohko määrittelee catch-osion sisällä poikkeuksen johon varaudutaan <code>catch (<em>Exception e</em>)</code>. Poikkeuksen tiedot tallennetaan <code>e</code>-muuttujaan.</p>

<pre class="sh_java">
    try {
        // ohjelmakoodi, joka saattaa heittää poikkeuksen
    } catch (Exception e) {
        // poikkeuksen tiedot ovat tallessa muuttujassa e
    }
</pre>

    <p>Luokka <code>Exception</code> tarjoaa hyödyllisiä metodeja. Esimerkiksi metodi <code>printStackTrace()</code> tulostaa <em>polun</em>, joka kertoo mistä päädyttiin poikkeukseen. Tutkitaan seuraavaa metodin <code>printStackTrace()</code> tulostamaa virhettä.</p>

<pre>
Exception in thread "main" java.lang.NullPointerException
  at pakkaus.Luokka.tulosta(Luokka.java:43)
  at pakkaus.Luokka.main(Luokka.java:29)
</pre>

    <p>Poikkeuspolun lukeminen tapahtuu alhaalta ylöspäin. Alimpana on ensimmäinen kutsu, eli ohjelman suoritus on alkanut luokan <code>Luokka</code> metodista <code>main()</code>. Luokan <code>Luokka</code> main-metodin rivillä 29 on kutsuttu metodia <code>tulosta()</code>. Metodin <code>tulosta</code> rivillä 43 on tapahtunut poikkeus <code>NullPointerException</code>. Poikkeuksen tiedot ovatkin hyvin hyödyllisiä virhekohdan selvittämisessä.</p>


<h2>Tiedoston lukeminen</h2>

    <p>Huomattava osa ohjelmista käsittelee jollain tavalla tallennettua tietoa. Otetaan ensiaskeleet tiedostojen käsittelyyn Javassa. Javan API tarjoaa luokan <a href="http://docs.oracle.com/javase/6/docs/api/java/io/File.html" target="_blank">File</a>, jonka sisältö voidaan lukea kurssilla jo tutuksi tulleen <a href="http://docs.oracle.com/javase/6/docs/api/java/util/Scanner.html" target="_blank">Scanner</a>-luokan avulla.</p>

    <p>Luokan <code>File</code> <a href="http://docs.oracle.com/javase/6/docs/api/java/io/File.html" target="_blank">API-kuvausta</a> lukiessamme huomaamme <code>File</code>-luokalla on konstruktori <code>File(String pathname)</code> (<em>Creates a new File instance by converting the given pathname string into an abstract pathname</em>). Voimme siis antaa avattavan tiedoston polun <code>File</code>-luokan konstruktorille.</p>

    <p><em>NetBeans-ohjelmointiympäristössä tiedostoille on oma välilehti nimeltä <em>Files</em>. Files-välilehdellä on määritelty kaikki projektiin liittyvät tiedostot. Jos projektin <em>juureen</em>, eli ei yhdenkään hakemiston sisälle, lisätään tiedosto, voidaan siihen viitata projektin sisältä suoraan tiedoston nimellä. Tiedosto-olion luominen tapahtuu antamalla sille parametrina polku tiedostoon, esimerkiksi seuraavasti</em></p>

<pre class="sh_java">
    File tiedosto = new File("tiedoston-nimi.txt");
</pre>

    <p>Scanner-luokan konstruktorille voi antaa myös muita lukemislähteitä kuin <code>System.in</code>-syöttövirran. Lukemislähteenä voi olla näppäimistön lisäksi muun muassa tiedosto. Scanner tarjoaa tiedoston lukemiseen samat metodit kuin näppäimistöltä syötetyn syötteen lukemiseen. Seuraavassa esimerkissä avataan tiedosto ja tulostetaan kaikki tiedoston sisältämän tekstit <code>System.out.println</code>-komennolla Lopuksi tiedosto suljetaan komennolla <code>close</code>.</p>

<pre class="sh_java">
        // tiedosto mistä luetaan
        File tiedosto = new File("tiedosto.txt");

        Scanner lukija = new Scanner(tiedosto);
        while (lukija.hasNextLine()) {
            String rivi = lukija.nextLine();
            System.out.println(rivi);
        }

        lukija.close();
</pre>

    <p>Scanner-luokan konstruktori <code><a href="http://docs.oracle.com/javase/6/docs/api/java/util/Scanner.html#Scanner(java.io.File)" target="_blank">public Scanner(File source)</a></code> (<em>Constructs a new Scanner that produces values scanned from the specified file.</em>) heittää <code><a href="http://docs.oracle.com/javase/6/docs/api/java/io/FileNotFoundException.html" target="_blank">FileNotFoundException</a></code>-poikkeuksen jos luettavaa tiedostoa ei löydy. Poikkeus <code>FileNotFoundException</code> ei ole tyyppiä <code>RuntimeException</code>, joten se tulee joko käsitellä tai heittää eteenpäin. Tässä vaiheessa riittää tietää että ohjelmointiympäristö kertoo jos sinun tulee käsitellä poikkeus erikseen. Luodaan ensin vaihtoehto, jossa poikkeus käsitellään tiedostoa avattaessa.</p>

<pre class="sh_java">
    public void lueTiedosto(File tiedosto) {
        // tiedosto mistä luetaan
        Scanner lukija = null;

        try {
            lukija = new Scanner(tiedosto);
        } catch (Exception e) {
            System.out.println("Tiedoston lukeminen epäonnistui. Virhe: " + e.getMessage());
            return; // poistutaan metodista
        }

        while (lukija.hasNextLine()) {
            String rivi = lukija.nextLine();
            System.out.println(rivi);
        }

        lukija.close();
    }
</pre>

    <p>Toinen vaihtoehto poikkeuksen käsittelyyn on poikkeuksen käsittelyvastuun siirtäminen metodin kutsujalle. Poikkeuksen käsittelyvastuu siirretään metodin kutsujalle lisäämällä metodiin määre <code>throws <em>PoikkeuksenTyyppi</em></code>, eli esimerkiksi <code>throws Exception</code> sillä kaikki poikkeukset ovat tyyppiä <code>Exception</code>. Kun metodilla on määre <code>throws Exception</code>, tietävät kaikki sitä kutsuvat että se saattaa heittää poikkeuksen johon tulee varautua.</p>

<pre class="sh_java">
    public void lueTiedosto(File tiedosto) throws Exception {
        // tiedosto mistä luetaan
        Scanner lukija = new Scanner(tiedosto);

        while (lukija.hasNextLine()) {
            String rivi = lukija.nextLine();
            System.out.println(rivi);
        }

        lukija.close();
    }
</pre>

    <p>Esimerkki avaa tiedoston <code>tiedosto.txt</code> projektin juuripolusta ja tulostaa sen rivi riviltä käyttäjälle näkyville. Lopuksi lukija suljetaan, jolloin tiedosto myös suljetaan. Määre <code>throws Exception</code> kertoo että metodi saattaa heittää poikkeuksen. Samanlaisen määreen voi laittaa kaikkiin metodeihin jotka käsittelevät tiedostoja.</p>

    <p>Huomaa että <code>Scanner</code>-olio ei liitä rivinvaihtomerkkejä osaksi <code>nextLine</code>-metodin palauttamaa merkkijonoa. Yksi vaihtoehto tiedoston lukemiseen siten, että rivinvaihdot säilyvät, on lisätä jokaisen rivin jälkeen rivinvaihtomerkki:</p>

<pre class="sh_java">
    public String lueTiedostoMerkkijonoon(File tiedosto) throws Exception {
        // tiedosto mistä luetaan
        Scanner lukija = new Scanner(tiedosto);

        String merkkijono = "";

        while (lukija.hasNextLine()) {
            String rivi = lukija.nextLine();
            merkkijono += rivi;
            merkkijono += "\n";
        }

        lukija.close();
        return merkkijono;
    }
</pre>

    <p>Koska käytämme tiedoston lukemiseen <code>Scanner</code>-luokkaa, käytössämme on kaikki Scanner-luokan tarjoamat metodit. Esimerkiksi metodi <code>hasNext()</code> palauttaa totuusarvon <code>true</code>, jos luettavassa tiedostossa on vielä luettavaa jäljellä, ja metodi <code>next()</code> lukee seuraavan sanan metodin palauttamaan <code>String</code>-olioon. </p>

    <p>Seuraava ohjelma luo <code>Scanner</code>-olion, joka avaa tiedoston <code>tiedosto.txt</code>. Sen jälkeen se tulostaa joka viidennen sanan tiedostosta.</p>

<pre class="sh_java">
        File tiedosto = new File("tiedosto.txt");
        Scanner lukija = new Scanner(tiedosto);

        int monesko = 0;
        while (lukija.hasNext()) {
            monesko++;
            String sana = lukija.next();

            if (monesko % 5 == 0) {
                System.out.println(sana);
            }
        }
</pre>

    <p>Alla on ensin luetun tiedoston sisältämä teksti ja sitten ohjelman tulostus</p>

<pre>
Poikkeukset (exceptions) ovat &quot;poikkeuksellisia tilanteita&quot; kesken normaalin ohjelmansuorituksen:
tiedosto loppuu, merkkijono ei kelpaa kokonaisluvuksi, odotetun olion tilalla onkin null-arvo,
taulukon indeksi menee ohjelmointivirheen takia sopimattomaksi, ...
</pre>

<pre>
tilanteita&quot;
loppuu,
odotetun
taulukon
sopimattomaksi,
</pre>

<h3>Merkistöongelmista</h3>

    <p>Tekstiä tiedostosta luettaessa (tai tiedostoon tallennettaessa) Java joutuu päättelemään käyttöjärjestelmän käyttämän merkistön. Merkistön tuntemusta tarvitaan sekä tekstin tallentamiseen tietokoneen kovalevylle binäärimuotoiseksi että binäärimuotoisen datan tekstiksi kääntämiseksi.</p>

    <p>Merkistöihin on kehitetty standardeja, joista "UTF-8" on nykyään yleisin. UTF-8 -merkistö sisältää sekä jokapäiväisessä käytössä olevien aakkosten että erikoisempien merkkien kuten Japanin kanji-merkistön tai shakkipelin nappuloiden tallentamiseen ja lukemiseen tarvittavat tiedot. Ohjelmointimielessä merkistöä voi hieman yksinkertaistaen ajatella hajautustauluna merkistä numeroon ja numerosta merkkiin. Merkistä numeroon oleva hajautustaulu kuvaa minkälaisena binäärilukuna kukin merkki tallennetaan tiedostoon. Numerosta merkkiin oleva hajautustaulu taas kuvaa miten tiedostoa luettaessa saadut luvut muunnetaan merkeiksi.</p>

    <p>Lähes jokaisella käyttöjärjestelmävalmistajalla on myös omat standardinsa. Osa tukee ja haluaa osallistua avoimien standardien käyttöön, osa ei. Mikäli sinulla on ongelmia ääkkösellisten sanojen kanssa (eritoten mac ja windows käyttäjät) voit kertoa <code>Scanner</code>-oliota luodessa käytettävän merkistön. Tällä kurssilla käytämme aina merkistöä "UTF-8".</p>

    <p>UTF-8 -merkistöä käyttävän tiedostoa lukevan Scanner-olion voi luoda seuraavasti:</p>

<pre class="sh_java">
    File tiedosto = new File("esimerkkitiedosto.txt");
    Scanner lukija = new Scanner(tiedosto, "UTF-8");
</pre>

    <p>Toinen vaihtoehto merkistön asettamiseksi on ympäristömuuttujan käyttäminen. Macintosh ja Windows-käyttäjät voivat asettaa ympäristömuuttujan <code>JAVA_TOOL_OPTIONS</code> arvoksi merkkijonon <code>-Dfile.encoding=UTF8</code>. Tällöin Java käyttää oletuksena aina UTF-8-merkistöä.</p>

<div class="tehtavat">
<div class="tehtava">
  <h3>Rivit joilla sana</h3>

<p>Tee luokka <code>Tulostaja</code> ja sille konstruktori <code>public Tulostaja(String tiedostonNimi)</code>, joka saa parametrinaan tiedoston nimeä vastaavan merkkijonon sekä metodi <code>public void tulostaRivitJoilla(String sana)</code> tulostaa tiedostosta ne rivit, joilla esiintyy parametrina oleva sana (<em>pienet ja isot kirjaimet erotellaan tehtävässä, eli esim. "koe" ja "Koe" eivät ole sama sana</em>), rivit tulostetaan samassa järjestyksessä missä ne ovat tiedostossa. </p>

<p>Jos parametri on tyhjä merkkijono, tulostuu koko tiedosto.</p>

<p>Jos tiedostoa ei ole olemassa, heittää konstruktori aiheutuvan poikkeuksen eteenpäin, eli try-catch-komentoa ei tarvita, riittää määritellä konstruktori seuraavasti:</p>

<pre class="sh_java">
public Tulostaja {

   public Tulostaja(String tiedostonNimi) throws Exception {
      // ...
   }

   // ...
}
</pre>

<p>Projektisi default-pakkauksessa on testausta varten tiedosto <em>testitiedosto.txt</em>. Ohjelmasta avatessa tiedoston nimeksi tulee antaa <code>src/testitiedosto.txt</code>. Tiedoston sisältö on seuraava:</p>

<pre>
Siinä vanha Väinämöinen
katseleikse käänteleikse
Niin tuli kevätkäkönen
näki koivun kasvavaksi
Miksipä on tuo jätetty
koivahainen kaatamatta
Sanoi vanha Väinämöinen
</pre>

<p>Seuraavassa esimerkki ohjelman toiminnasta testitiedostolla:</p>

<pre class="sh_java">
    Tulostaja tulostaja = new Tulostaja("src/testitiedosto.txt");

    tulostaja.tulostaRivitJoilla("Väinämöinen");
    System.out.println("-----");
    tulostaja.tulostaRivitJoilla("Frank Zappa");
    System.out.println("-----");
    tulostaja.tulostaRivitJoilla("");
    System.out.println("-----");
</pre>

<p>Tulostuu:</p>

<pre>
Siinä vanha Väinämöinen
Sanoi vanha Väinämöinen
-----
-----
Siinä vanha Väinämöinen
katseleikse käänteleikse
Niin tuli kevätkäkönen
näki koivun kasvavaksi
Miksipä on tuo jätetty
koivahainen kaatamatta
Sanoi vanha Väinämöinen
</pre>

<p>Projektipohjasta löytyy myös koko Kalevala, tiedoston nimi on <code>src/kalevala.txt</code></p>
</div>
<div class="tehtava">
  <h3>Tiedoston analyysi</h3>

  <p>Tässä tehtävässä tehdään sovellus tiedoston rivi- ja merkkimäärän laskemiseen.</p>

  <h4>Rivien laskeminen</h4>


  <p>Tee pakkaukseen <code>tiedosto</code> luokka <code>Analyysi</code>, jolla on konstruktori <code>public Analyysi(File tiedosto)</code>. Toteuta luokalle metodi <code>public int rivimaara()</code>, joka palauttaa konstruktorille annetun tiedoston rivimäärän.</p>

<p>Metodi ei saa olla "kertakäyttöinen", eli sen pitää tuottaa oikea tulos myös usealla peräkkäisellä kutsulla. Huomaa, että kun teet tiedostoa vastaavan Scanner-olion, ja luet tiedoston koko sisällön <code>nextLine</code>-komennoilla, et voi käyttää enää <em>samaa</em> skanneria tiedoston uudelleenlukemiseen!</p>

<p><strong>Huom:</strong> jos testit sanovat <em>timeout</em>, et todennäköisesti muista lukea tiedostoa ollenkaan, eli <code>nextLine</code>-kutsut puuttuvat!</p>

  <h4>Merkkien laskeminen</h4>

  <p>Toteuta luokkaan <code>Analyysi</code> metodi <code>public int merkkeja()</code>, joka palauttaa luokan konstruktorille annetun tiedoston merkkien määrän.</p>

<p>Metodi ei saa olla "kertakäyttöinen", eli sen pitää tuottaa oikea tulos myös usealla peräkkäisellä kutsulla.</p>

  <p>Voit itse päättää miten reagoidaan jos konstruktorin parametrina saatua tiedostoa ei ole olemassa.</p>

<p>Projektisi testipakkauksessa on testausta varten tiedosto <em>testitiedosto.txt</em>. Ohjelmasta avatessa tiedoston nimeksi tulee antaa <code>test/testitiedosto.txt</code>. Tiedoston sisältö on seuraava:</p>

<pre>
rivejä tässä on 3 ja merkkejä
koska rivinvaihdotkin ovat
merkkejä
</pre>

<p>Ohjelman toiminta testaustiedostolla:</p>

<pre class="sh_java">
    File tiedosto = new File("src/testitiedosto.txt");
    Analyysi analyysi = new Analyysi(tiedosto);
    System.out.println("Rivejä: " + analyysi.rivimaara());
    System.out.println("Merkkejä: " + analyysi.merkkeja());
</pre>

<pre>
Rivejä: 3
Merkkejä: 67
</pre>
</div>
<div class="tehtava">
  <h3>Sanatutkimus</h3>

  <p>Tee luokka Sanatutkimus, jolla voi tehdä erilaisia tutkimuksia tiedoston sisältämille sanoille. Toteuta luokka pakkaukseen <code>sanatutkimus</code>.</p>

  <p>Kotimaisten kielten tutkimuskeskus (Kotus) on julkaissut netissä suomen kielen sanalistan. Tässä tehtävässä käytetään listan muokattua versiota, joka löytyy tehtäväpohjasta <code>src</code>-hakemistosta nimellä <code>sanalista.txt</code>, eli suhteellisesta polusta <code>"src/sanalista.txt"</code>.
Koska sanalista on varsin pitkä, on projektissa testausta varten myös <code>pienilista.txt</code> joka löytyy polusta <code>"src/pienilista.txt"</code>.
</p>

  <p><strong>Mikäli sinulla on ongelmia ääkkösellisten sanojen kanssa</strong> (mac ja windows käyttäjät) luo <code>Scanner</code>-olio antaen sille parametrina merkistö "UTF-8" seuraavasti: <code> Scanner lukija = new Scanner(tiedosto, "UTF-8");</code> Ongelmat liittyvät erityisesti testien suoritukseen.</p>

  <h4  >Sanojen määrä</h4>

  <p>Luo Sanatutkimus-luokalle konstruktori <code>public Sanatutkimus(File tiedosto)</code> joka luo uuden Sanatutkimus-olion, joka tutkii parametrina annettavaa tiedostoa.</p>

  <p>Tee luokkaan metodi <code>public int sanojenMaara()</code>, joka lukee tiedostossa olevat sanat ja tulostaa niiden määrän. Tässä vaiheessa sanoilla ei tarvitse tehdä mitään, riittää laskea niiden määrä. Voit olettaa tässä tehtävässä, että tiedostossa on vain yksi sana riviä kohti.</p>


  <h4>z-kirjain</h4>

  <p>Tee luokkaan metodi <code>public List&lt;String&gt; kirjaimenZSisaltavatSanat()</code>, joka palauttaa tiedoston kaikki sanat, joissa on z-kirjain. Tällaisia sanoja ovat esimerkiksi jazz ja zombi.</p>

  <h4  >l-pääte</h4>

  <p>Tee luokkaan metodi <code>public List&lt;String&gt; kirjaimeenLPaattyvatSanat()</code>, joka palauttaa tiedoston kaikki sanat, jotka päättyvät l-kirjaimeen. Tällaisia sanoja ovat esimerkiksi kannel ja sammal.</p>

  <p><em>Huom! Jos luet tiedoston uudestaan ja uudestaan jokaisessa metodissa huomaat viimeistään tässä vaiheessa copy-paste koodia. Kannattaa miettiä olisiko tiedoston lukeminen helpompi tehdä osana konstruktoria tai metodina, jota konstruktori kutsuu. Metodeissa voitaisiin käyttää tällöin jo luettua listaa ja luoda siitä aina uusi, hakuehtoihin sopiva lista. Viikolla 12 on tulossa oikeaoppinen tapa copypasten eliminointiin.</em></p>

  <h4>Palindromit</h4>

  <p>Tee luokkaan metodi <code>public List&lt;String&gt; palindromit()</code>, joka palauttaa tiedoston kaikki sanat, jotka ovat palindromeja. Tällaisia sanoja ovat esimerkiksi ala ja enne.</p>

  <h4  >Kaikki vokaalit</h4>

  <p>Tee luokkaan metodi <code>public List&lt;String&gt; kaikkiVokaalitSisaltavatSanat()</code>, joka palauttaa tiedoston kaikki sanat, jotka sisältävät kaikki suomen kielen vokaalit (aeiouyäö). Tällaisia sanoja ovat esimerkiksi myöhäiselokuva ja ympäristönsuojelija.</p>
</div>
</div>






<h2>Hajautustauluista ja joukoista</h2>

<h3>Monta arvoa yhtä avainta kohti</h3>

<p>Kuten muistamme, voi HashMapiin tallettaa tiettyä avainta kohti vaan yhden arvon. Seuraavassa esimerkissä tallennamme henkilöiden puhelinnumeroita HashMap:iin.</p>

<pre class="sh_java">
  Map&lt;String, String&gt; puhelinnumerot = new HashMap&lt;String, String&gt;();

  puhelinnumerot.put("Pekka", "040-12348765");

  System.out.println( "Pekan numero: "+ puhelinnumerot.get("Pekka") );

  puhelinnumerot.put("Pekka", "09-111333");

  System.out.println( "Pekan numero: "+ puhelinnumerot.get("Pekka") );
</pre>

<p>Kuten odotettua, tulostus kertoo, että</p>

<pre>
Pekan numero: 040-12348765
Pekan numero: 09-111333
</pre>

<p>Entä jos haluaisimmekin tallettaa yhtä avainta kohti useita arvoja, eli esim yhtä henkilöä kohti monta puhelinnumeroa? Onnistuuko se HashMap:in avulla? Kyllä, esim. tallettamalla HashMap:iin Stringien sijaan esim. ArrayList:eja arvoiksi, voidaan yhteen avaimeen "liittää" useampia oliota. Muutetaan puhelinnumeroiden talletustapaa seuraavasti:</p>

<pre class="sh_java">
  Map&lt;String, ArrayList&lt;String&gt;&gt; puhelinnumerot = new HashMap&lt;String, ArrayList&lt;String&gt;&gt;();
</pre>

<p>Nyt siis HashMapissa jokaiseen avaimeen littyy lista. Vaikka new-komento luokin HashMapin, on mapin sisälle talletettavat listat luotava erikseen. Seuraavassa lisätään HashMapiin Pekalle kaksi numeroa ja tulostetaan ne:</p>

<pre class="sh_java">
  Map&lt;String, ArrayList&lt;String&gt;&gt; puhelinnumerot = new HashMap&lt;String, ArrayList&lt;String&gt;&gt;();

  // liitetään Pekka-nimeen ensin tyhjä ArrayList
  puhelinnumerot.put( "Pekka", new  ArrayList&lt;String&gt;() );

  // ja lisätään Pekkaa vastaavalle listalle puhelinnumero
  puhelinnumerot.get("Pekka").add("040-12348765");

  // ja lisätään toinenkin puhelinnumero
  puhelinnumerot.get("Pekka").add("09-111333");

  System.out.println( "Pekan numerot: "+ puhelinnumerot.get("Pekka") );
</pre>

<p>Tulostuu</p>

<pre>
Pekan numero: [040-12348765, 09-111333]
</pre>

<p>Määrittelimme muuttujan puhelinnumero tyypiksi <code>Map&lt;String, ArrayList&lt;String&gt;&gt;</code> eli Map jonka avaimena on merkkijono ja arvona merkkijonoja sisältävä lista. Konkreettinen toteutus, eli luotu olio oli HasMap. Olisimme voineet määritellä muuttujan myös seuraavasti:
</p>

<pre class="sh_java">
Map&lt;String, List&lt;String&gt;&gt; puhelinnumero = new HashMap&lt;String, List&lt;String&gt;&gt;();
</pre>

<p>
Eli nyt muuttujan tyyppi on Map, jonka avaimena on merkkijono ja arvona merkkijonoja sisältävä <code>List</code>, joka siis on rajapinta joka määrittelee listatoiminnallisuuden, esim. ArrayList toteuttaa tämän rajapinnan. Konkreettinen olio on HashMap.
</p>

<p>HashMap:iin talletettavat arvot siis ovat <code>List&lt;String&gt;</code>-rajapinnan toteuttavia konkreettisia olioita, esim. ArrayListeja. Eli lisäys HashMapiin tapahtuu edelleen seuraavasti:</p>

<pre class="sh_java">
  // liitetään Pekka-nimeen ensin tyhjä ArrayList
  puhelinnumerot.put( "Pekka", new  ArrayList&lt;String&gt;() );

  // ...
</pre>

<p>Jatkossa pyrkimyksemme on käyttää tyyppimäärittelyissä konkreettisten luokkien, esim. <code>HashMap</code> ja <code>ArrayList</code> sijaan niitä vastaavia rajapintoja <code>Map</code> ja <code>List</code>.</p>

<h3>Joukoista</h3>

    <p>Rajapinta <code><a href="http://docs.oracle.com/javase/6/docs/api/java/util/Set.html" target="_blank">Set</a></code> kuvaa joukon toiminnallisuutta. Toisin kuin listalla, on joukossa kutakin alkioita korkeintaan yksi kappale, eli yhtään samanlaista oliota ei ole kahdesti. Olioiden samankaltaisuuden tarkistaminen toteutetaan <code>equals</code> ja <code>hashCode</code> -metodeja käyttämällä. </p>

<p>Yksi rajapinnan <code>Set</code> toteuttava luokka on  <code><a href="http://docs.oracle.com/javase/6/docs/api/java/util/HashSet.html" target="_blank">HashSet</a></code>. Toteutetaan sen avulla luokka <code>Tehtavakirjanpito</code>, joka tarjoaa mahdollisuuden tehtävien kirjanpitoon ja tehtyjen tehtävien tulostamiseen. Oletetaan että tehtävät ovat aina kokonaislukuja.</p>

<pre class="sh_java">
public class Tehtavakirjanpito {
    private Set&lt;Integer&gt; tehdytTehtavat;

    public Tehtavakirjanpito() {
        this.tehdytTehtavat = new HashSet&lt;Integer&gt;();
    }

    public void lisaa(int tehtava) {
        this.tehdytTehtavat.add(tehtava);
    }

    public void tulosta() {
        for (int tehtava: this.tehdytTehtavat) {
            System.out.println(tehtava);
        }
    }
}
</pre>

<pre class="sh_java">
        Tehtavakirjanpito kirjanpito = new Tehtavakirjanpito();
        kirjanpito.lisaa(1);
        kirjanpito.lisaa(1);
        kirjanpito.lisaa(2);
        kirjanpito.lisaa(3);

        kirjanpito.tulosta();
</pre>

<pre>
1
2
3
</pre>

    <p>Yllä oleva ratkaisu toimii tilanteessa, jossa emme tarvitse tietoa käyttäjistä eri käyttäjien tekemistä tehtävistä. Muutetaan tehtävien tallennuslogiikkaa siten, että tehtävät tallennetaan <em>käyttäjäkohtaisesti</em> hajautustaulua hyödyntäen. Käyttäjät tunnistetaan käyttäjän yksilöivällä merkkijonolla (esimerkiksi opiskelijanumero), ja jokaiselle käyttäjälle on oma joukko tehdyistä tehtävistä.</p>

<pre class="sh_java">
public class Tehtavakirjanpito {
    private Map&lt;String, Set&lt;Integer&gt;&gt; tehdytTehtavat;

    public Tehtavakirjanpito() {
        this.tehdytTehtavat = new HashMap&lt;String, Set&lt;Integer&gt;&gt;();
    }

    public void lisaa(String kayttaja, int tehtava) {
        // huomaa miten uudelle käyttäjälle on lisättävä HashMapiin ensin tyhjä tehtäväjoukko
        if (!this.tehdytTehtavat.containsKey(kayttaja)) {
            this.tehdytTehtavat.put(kayttaja, new HashSet&lt;Integer&gt;());
        }

        // haetaan ensin käyttäjän tehtävät sisältävä joukko ja tehdään siihen lisäys
        Set&lt;Integer&gt; tehdyt = this.tehdytTehtavat.get(kayttaja);
        tehdyt.add(tehtava);

        // edellinen olisi onnitunut myös ilman apumuuttujaa seuraavasti
        //  this.tehdytTehtavat.get(kayttaja).add(tehtava);
    }

    public void tulosta() {
        for (String kayttaja: this.tehdytTehtavat.keySet()) {
            System.out.println(kayttaja + ": " + this.tehdytTehtavat.get(kayttaja));
        }
    }
}
</pre>

<pre class="sh_java">
        Tehtavakirjanpito kirjanpito = new Tehtavakirjanpito();
        kirjanpito.lisaa("Mikael", 3);
        kirjanpito.lisaa("Mikael", 4);
        kirjanpito.lisaa("Mikael", 3);
        kirjanpito.lisaa("Mikael", 3);

        kirjanpito.lisaa("Pekka", 4);
        kirjanpito.lisaa("Pekka", 4);

        kirjanpito.lisaa("Matti", 1);
        kirjanpito.lisaa("Matti", 2);

        kirjanpito.tulosta();
</pre>

<pre>
Matti: [1, 2]
Pekka: [4]
Mikael: [3, 4]
</pre>


    <p>Huomaamme että käyttäjien nimet eivät tulostu esimerkissä	 järjestyksessä. Tämä selittyy sillä että <code>HashMap</code>-tyyppisessä hajautustaulussa alkioiden tallennus tapahtuu <code>hashCode</code>-metodin palauttaman hajautusarvon perusteella, eikä se liity millään tavalla alkioiden järjestykseen.</p>

<div class="tehtavat">
<div class="tehtava">
<h3>Sanakirja usealle käännökselle</h3>

<p>Tehdään hieman laajennettu versio viikolla <span class="ahy">1</span><span class="amooc">7</span> tehdystä sanakirjasta. Tehtävänäsi on toteuttaa pakkaukseen <code>sanakirja</code> luokka <code>OmaUseanKaannoksenSanakirja</code>, joka voi tallettaa yhden tai useamman käännöksen jokaiselle sanalle. Luokan tulee toteuttaa tehtäväpohjassa annettu rajapinta <code>UseanKaannoksenSanakirja</code>, jossa on seuraavat toiminnot:</p>

<p>
  <ul>
<li><code>public void lisaa(String sana, String kaannos)</code></li>lisää käännöksen sanalle säilyttäen vanhat käännökset<br/>
<li><code>public Set&lt;String&gt; kaanna(String sana)</code></li>palauttaa <code>Set</code>-olion, jossa on kaikki käännökset sanalle, tai <code>null</code>-viitteen, jos sanaa ei ole sanakirjassa<br/>
<li><code>public void poista(String sana)</code></li>poistaa sanan ja sen kaikki käännökset sanakirjasta<br/>
  </ul>
</p>

<p>Käännökset kannattanee tallentaa yllä olevan esimerkin Tehtavakirjanpito tapaan <code>Map&lt;String, Set&lt;String&gt;&gt;</code>-tyyppiseen oliomuuttujaan.</p>

<p>Rajapinnan koodi:</p>

<pre class="sh_java">
package sanakirja;

import java.util.Set;

public interface UseanKaannoksenSanakirja {
    void lisaa(String sana, String kaannos);
    Set&lt;String&gt; kaanna(String sana);
    void poista(String sana);
}
</pre>

<p>Esimerkkiohjelma:</p>

<pre class="sh_java">
    UseanKaannoksenSanakirja sanakirja = new OmaUseanKaannoksenSanakirja();
    sanakirja.lisaa("kuusi", "six");
    sanakirja.lisaa("kuusi", "spruce");

    sanakirja.lisaa("pii", "silicon");
    sanakirja.lisaa("pii", "pi");

    System.out.println(sanakirja.kaanna("kuusi"));
    sanakirja.poista("pii");
    System.out.println(sanakirja.kaanna("pii"));
</pre>

<p>Tulostuu:</p>

<pre>
[six, spruce]
null
</pre>

</div>



<div class="tehtava">
  <h3>Duplikaattien poistaja</h3>

  <p>Tehtävänäsi on toteuttaa pakkaukseen <code>tyokalut</code> luokka <code>OmaDuplikaattienPoistaja</code>, joka tallettaa annetut merkkijonot siten, että annetuista merkkijonoista poistetaan samanlaiset merkkijonot (eli duplikaatit). Lisäksi luokka pitää kirjaa duplikaattien määrästä. Luokan tulee toteuttaa tehtäväpohjassa annettu rajapinta <code>DuplikaattienPoistaja</code>, jossa on seuraavat toiminnot:</p>

  <p>
    <ul>
<li><code>public void lisaa(String merkkijono)</code></li> tallettaa merkkijonon, jos se ei ole duplikaatti<br/>
<li><code>public int getHavaittujenDuplikaattienMaara()</code></li> palauttaa tähän mennessä havaittujen duplikaattien määrän<br/>
<li><code>public Set&lt;String&gt; getUniikitMerkkijonot()</code></li> palauttaa <code>Set&lt;String&gt;</code>-rajapinnan toteuttavan olion, jossa on kaikki uniikit lisätyt merkkijonot (ei siis duplikaatteja!). Jos merkkijonoja ei ole, palautetaan tyhjä joukko-olio.<br/>
<li><code>public void tyhjenna()</code></li> poistaa talletetut merkkijonot ja nollaa havaittujen duplikaattien määrän<br/>
    </ul>
  </p>

  <p>Rajapinnan koodi:</p>

<pre class="sh_java">
package tyokalut;

import java.util.Set;

public interface DuplikaattienPoistaja {
    void lisaa(String merkkijono);
    int getHavaittujenDuplikaattienMaara();
    Set&lt;String&gt; getUniikitMerkkijonot();
    void tyhjenna();
}
</pre>

  <p>Rajapintaa voi käyttää esimerkiksi näin:</p>

<pre class="sh_java">
    public static void main(String[] args) {
        DuplikaattienPoistaja poistaja = new OmaDuplikaattienPoistaja();
        poistaja.lisaa("eka");
        poistaja.lisaa("toka");
        poistaja.lisaa("eka");

        System.out.println("Duplikaattien määrä nyt: " +
            poistaja.getHavaittujenDuplikaattienMaara());

        poistaja.lisaa("vika");
        poistaja.lisaa("vika");
        poistaja.lisaa("uusi");

        System.out.println("Duplikaattien määrä nyt: " +
            poistaja.getHavaittujenDuplikaattienMaara());

        System.out.println("Uniikit merkkijonot: " +
            poistaja.getUniikitMerkkijonot());

        poistaja.tyhjenna();

        System.out.println("Duplikaattien määrä nyt: " +
            poistaja.getHavaittujenDuplikaattienMaara());

        System.out.println("Uniikit merkkijonot: " +
            poistaja.getUniikitMerkkijonot());
    }
</pre>

  <p>Yllä oleva ohjelma tulostaisi: (merkkijonojen järjestys saa vaihdella, sillä ei ole merkitystä)</p>

<pre>
Duplikaattien määrä nyt: 1
Duplikaattien määrä nyt: 2
Uniikit merkkijonot: [eka, toka, vika, uusi]
Duplikaattien määrä nyt: 0
Uniikit merkkijonot: []
</pre>

</div>
</div>

<h3>Yksi olio useammassa eri listassa, Map-rakenteessa tai joukossa</h3>

<p>Kuten muistamme, oliomuuttujat ovat viitetyyppisiä, eli muuttuja ei tallenna olioa itseään vaan viitteen olioon. Vastaavasti jos olio laitetaan esim. ArrayListiin, ei listalle talleteta olioa itseään vaan <em>viite</em> olioon. Mikään ei estäkään tallentamasta samaan olioon viitettä esim. useaan listaan tai HashMapiin. </p>

<p>Tarkastellaan esimerkkinä kirjastoa joka tallettaa kirjat hashMapeihin sekä kirjailijan että kirjan isbn-numeron perusteella. Tämän lisäksi kirjasto pitää kaikkia lainassa olevia sekä hyllyssä olevia kirjoja omalla listallaan.</p>

<pre class="sh_java">
public class Kirja {
    private String ISBN;
    private String kirjailija;
    private String nimi;
    private int vuosi;
    // ...
}

public class Kirjasto {
    private Map&lt; String, Kirja&gt; kirjaIsbnNumeronPerusteella;
    private Map&lt; String, List&lt;String&gt;&gt; kirjatKirjailijanPerusteella;
    private List&lt;Kirja&gt; lainassaOlevatKirjat;
    private List&lt;Kirja&gt; hyllyssaOlevatKirjat;

    public void lisaaKirjaKokoelmaan(Kirja uusiKirja){
        kirjaIsbnNumeronPerusteella.put(uusiKirja.getIsbn(), uusiKirja);
        kirjatKirjailijanPerusteella.get(uusikirja.getKirjailija()).add(uusiKirja);
        hyllyssaOlevatKirjat.add(uusiKirja);
    }

    public Kirja haeKirjaIsbnNumeronPerusteella(String isbn){
        return kirjaIsbnNumeronPerusteella.get(isbn);
    }

    // ...
}
</pre>

<p>Jos olio on yhtäaikaa useassa kokoelmassa (listalla, joukossa tai map-rakenteessa), on kiinnitettävä erityistä huomiota, että kokoelmien tila on konsistentti. Jos esim. kirja päätetään poistaa, on se poistettava molemmista mapeista sekä lainassa/hyllyssä olevia kuvaavalta listalta.</p>

<div class="tehtavat">
    <p class="mooc-pakollinen"></p>
<div class="tehtava pakollinen-hakuun " >
  <h3>Numerotiedustelu</h3>

<p><b>Huom: jotta testit toimisivat, ohjelmasi saa luoda vain yhden Scanner-olion. Älä myöskään käytä staattisia muuttujia, testit suorittavat ohjelman useita kertoja joten staattisiin muuttujiin edellisillä suorituskerroilla jääneet arvot todennäköisesti häiritsevät testien toimintaa!</b></p>


<p>Tehdään sovellus jonka avulla on mahdollista hallinnoida ihmisten puhelinnumeroita ja osoitteita.</p>

<p>Tehtävän voi suorittaa 1-5 pisteen laajuisena. Yhden pisteen laajuuteen on toteutettava seuraavat toiminnot:</p>

<ul>
<li>1 puhelinnumeron lisäys henkilölle</li>
<li>2 henkilön puhelinnumeroiden haku</li>
</ul>

<p>kahteen pisteeseen vaaditaan edellisten lisäksi</p>

<ul>
<li>3 numeroa vastaavan henkilön nimen haku</li>
</ul>

<p>kolmeen pisteeseen vaaditaan edellisten lisäksi</p>

<ul>
<li>4 osoitteen lisäys henkilölle</li>
<li>5 henkilön tietojen (osoite ja puhelinnumero) haku</li>
</ul>

<p>neljään pisteeseen vaaditaan toiminto</p>

<ul>
<li>6 henkilön tietojen poisto</li>
</ul>

<p>ja täysiin pisteeseen vaaditaan vielä</p>

<ul>
<li>7 hakusanalla filtteröity listaus (nimen mukaan aakkostettuna), hakusana voi esiintyä henkilön nimessä tai osoitteessa</li>
</ul>

<p>Esimerkki ohjelman toiminnasta:</p>

<pre>
numerotiedustelu
käytettävissä olevat komennot:
 1 lisää numero
 2 hae numerot
 3 hae puhelinnumeroa vastaava henkilö
 4 lisää osoite
 5 hae henkilön tiedot
 6 poista henkilön tiedot
 7 filtteröity listaus
 x lopeta

komento: <font color="red">1</font>
kenelle: <font color="red">pekka</font>
numero: <font color="red">040-123456</font>

komento: <font color="red">2</font>
kenen: <font color="red">jukka</font>
  ei löytynyt

komento: <font color="red">2</font>
kenen: <font color="red">pekka</font>
 <font color="red">040-123456</font>

komento: <font color="red">1</font>
kenelle: <font color="red">pekka</font>
numero: <font color="red">09-222333</font>

komento: <font color="red">2</font>
kenen: <font color="red">pekka</font>
 040-123456
 09-222333

komento: <font color="red">3</font>
numero: <font color="red">02-444123</font>
 ei löytynyt

komento: <font color="red">3</font>
numero: <font color="red">09-222333</font>
 pekka

komento: <font color="red">5</font>
kenen: <font color="red">pekka</font>
  osoite ei tiedossa
  puhelinnumerot:
   040-123456
   09-222333

komento: <font color="red">4</font>
kenelle: <font color="red">pekka</font>
katu: <font color="red">ida ekmanintie</font>
kaupunki: <font color="red">helsinki</font>

komento: <font color="red">5</font>
kenen: <font color="red">pekka</font>
  osoite: ida ekmanintie helsinki
  puhelinnumerot:
   040-123456
   09-222333

komento: <font color="red">4</font>
kenelle: <font color="red">jukka</font>
katu: <font color="red">korsontie</font>
kaupunki: <font color="red">vantaa</font>

komento: <font color="red">5</font>
kenen: <font color="red">jukka</font>
  osoite: korsontie vantaa
  ei puhelinta

komento: <font color="red">7</font>
hakusana (jos tyhjä, listataan kaikki): <font color="red">kk</font>

 jukka
  osoite: korsontie vantaa
  ei puhelinta

 pekka
  osoite: ida ekmanintie helsinki
  puhelinnumerot:
   040-123456
   09-222333

komento: <font color="red">7</font>
hakusana (jos tyhjä, listataan kaikki): <font color="red">vantaa</font>

 jukka
  osoite: korsontie vantaa
  ei puhelinta

komento: <font color="red">7</font>
hakusana (jos tyhjä, listataan kaikki): <font color="red">seppo</font>
 ei löytynyt

komento: <font color="red">6</font>
kenet: <font color="red">jukka</font>

komento: <font color="red">5</font>
kenen: <font color="red">jukka</font>
  ei löytynyt

komento: <font color="red">x</font>
</pre>

<p>Huomioita:</p>
<ul>
<li> Testien kannalta on oleellista että <em>käyttöliittymä</em> toimii kuten yllä olevassa esimerkissä. Sovellus voi itse päättää kuinka epäkelvot syötteet käsitellään. Testit sisältävät vaan kelvollisia syötteitä.</li>
<li><em><strong>Ohjelman tulee käynnistyä kun tehtäväpohjassa oleva main-metodi suoritetaan, tehtävässä saa luoda vain yhden Scanner-olion.</strong></em></li>
<li> Älä käytä staattisia muuttujia, testit suorittavat ohjelman useita kertoja joten staattisiin muuttujiin edellisillä suorituskerroilla jääneet arvot todennäköisesti häiritsevät testien toimintaa!</li>
<li>Älä käytä luokkein nimissä skandeja, ne saattavat aiheuttaa ongelmia testeihin!</li>
<li>Yksinkertaisuuden vuoksi oletetaan että nimi on yksittäinen merkkijono, eli jos halutaan sukunimen mukaan järjestetyn tulostus viimeiseen toimintoon, nimi on annettava muodossa <em>mikkola pekka</em>.</li>
<li>Henkilöllä voi olla useita puhelinnumeroja sekä osoite. Henkilöllä ei kuitenkaan ole välttämättä yhtään puhelinnumeroa tai osoite ei ole tiedossa.</li>
<li>Jos henkilö poistetaan, ei mikään haku saa enää palauttaa henkilön tietoja.</li>
</ul>
</div>
</div>
</div>
</section>


<section class="viikkoraja" id="4" >
  <div class="viikkoraja"></div>
  <div class="viikkoraja-mooc" id="Viikko 10" deadline="avautuu kun 85 % viikosta 9 tehty" data-first-chapter-index="48" data-first-exercise-index="134" data-first-week-index="10"  data-first-chapter-index-mooc="48" data-first-exercise-index-mooc="134" data-first-week-index-mooc="10" tekija="Arto Vihavainen, Matti Luukkainen">
<div class="tehtavat">
    <div class="tehtava">
<h3>Rengastustoimisto</h3>

<p><span class="ahy">Ohjelmoinnin perusteiden kuudennella</span><span class="amooc">Kuudennella</span>  viikolla teimme lintubongaria varten havaintotietokannan. Jatkamme hieman samasta teemasta, tällä kertaa teemme rengastustoimistolle ohjelman, jonka avulla pidetään kirjaa tiettynä vuotena rengastettujen lintujen havaintopaikoista.</p>

<big>
<p><strong>HUOM:</strong> saatat törmätä tehtävässä kummalliseen virheilmoitukseen <code>NoSuchMethodError: Lintu.equals(LLintu;)Z</code>, jos näin käy suorita <strong>clean and build</strong> eli paina harja ja vasara -kuvakkeesta.</p>
</big>

<h4>Linnun equals ja toString</h4>

<p>Rengastustoimisto tallettaa tiettynä vuotena rengastettettujen lintujen tiedot <code>Lintu</code>-olioihin:</p>

<pre class="sh_java">
public class Lintu {

    private String nimi;
    private String latinankielinenNimi;
    private int rengastusvuosi;

    public Lintu(String nimi, String latinankielinenNimi, int rengastusvuosi) {
        this.nimi = nimi;
        this.latinankielinenNimi = latinankielinenNimi;
        this.rengastusvuosi = rengastusvuosi;
    }

    @Override
    public String toString() {
        return this.latinankielinenNimi + "(" + this.rengastusvuosi + ")";
    }
}

</pre>

<p>Ideana on toteuttaa rengastustoimistoon toiminnallisuus jonka avulla voidaan pitää kirjaa tiettynä vuotena rengastettujen lintujen havaintojen lukumääristä ja havaintopaikoista. Havaintomääriä ja -paikkoja ei kuitenkaan talleteta Lintu-olioihin, vaan erilliseen HashMap:iin jonka avaimena käytetään Lintu-olioita. Kuten muistamme viikolta 8, on tälläisessä tapauksessa toteutettava luokalle <code>Lintu</code> metodit <code>equals(Object t)</code> ja <code>hashCode()</code>.</p>

<p>Joillain linnuilla on useita suomenkielisä nimiä (esim. punakottaraisesta käytetään edelleen joskus sen vanhaa nimitystä rusokottarainen), latinankielinen nimi on kuitenkin aina yksikäsitteinen. Tee luokalle <code>Lintu</code> <code>equals-</code> ja <code>hashCode-</code>metodit jotka toimivat siten, että lintu-oliot tulkitaan samoiksi jos niiden latinankielinen nimi ja rengastusvuosi ovat samat.</p>

<p>Esimerkki:</code>

<pre>
    Lintu lintu1 = new Lintu("punakottarainen", "Sturnus roseus", 2012);
    Lintu lintu2 = new Lintu("rusokottarainen", "Sturnus roseus", 2012);
    Lintu lintu3 = new Lintu("varis", "Corvus corone cornix", 2012);
    Lintu lintu4 = new Lintu("punakottarainen", "Sturnus roseus", 2000);

    System.out.println( lintu1.equals(lintu2));   // ovat sama koska sama latinankielinen nimi ja rengastusvuosi
    System.out.println( lintu1.equals(lintu3));   // eivät ole sama koska latinankielinen nimi eri
    System.out.println( lintu1.equals(lintu4));   // eivät ole sama koska eri rengastusvuosi
    System.out.println( lintu1.hashCode()==lintu2.hashCode() );
</pre>

<p>tulostuu:</p>

<pre>
true
false
false
true
</pre>

<h4>Rengastustoimisto</h4>

<p>Rengastustoimistolla on kaksi metodia: <code>public void havaitse(Lintu lintu, String paikka)</code> lisää linnulle havainnon ja havaintopaikan ja metodi <code>public void havainnot(Lintu lintu)</code> tulostaa alla olevan esimerkin mukaisesti parametrina olevan linnun havaintojen määrän ja havaintopaikat. Havaintopaikkojen tulostusjärjestyksellä ei ole testien läpimenon kannalta merkitystä.</p>

<p>Rengastustoimisto tallettaa havaintopaikat <code>Map&lt;Lintu, List&lt;String&gt;&gt;</code>-tyyppiseen oliomuuttujaan. Havaintojen lukumäärä selviää havaintopaikkojen listan pituudesta. Tarvittaessa voit ottaa tehtävään mallia luvusta 50.</p>

<p>Esimerkki rengastustoimiston käytöstä:</p>

<pre class="sh_java">
    Rengastustoimisto kumpulanRengas = new Rengastustoimisto();

    kumpulanRengas.havaitse( new Lintu("punakottarainen", "Sturnus roseus", 2012), "Arabia" );
    kumpulanRengas.havaitse( new Lintu("rusokottarainen", "Sturnus roseus", 2012), "Vallila" );
    kumpulanRengas.havaitse( new Lintu("harmaalokki", "Larus argentatus", 2008), "Kumpulanmäki" );
    kumpulanRengas.havaitse( new Lintu("punakottarainen", "Sturnus roseus", 2008), "Mannerheimintie" );

    kumpulanRengas.havainnot( new Lintu("rusokottarainen", "Sturnus roseus", 2012 ) );
    System.out.println("--");
    kumpulanRengas.havainnot( new Lintu("harmaalokki", "Larus argentatus", 2008 ) );
    System.out.println("--");
    kumpulanRengas.havainnot( new Lintu("harmaalokki", "Larus argentatus", 1980 ) );
</pre>

<p>tulostuu:</p>

<pre>
Sturnus roseus (2012) havaintoja: 2
Arabia
Vallila
--
Larus argentatus (2008) havaintoja: 1
Kumpulanmäki
--
Larus argentatus (1980) havaintoja: 0
</pre>

</div>
</div>

<h2>Olioiden monimuotoisuus</h2>

    <p>Olemme aiemmissa kappaleissa törmänneet tilanteisiin, joissa muuttujilla on oman tyyppinsä lisäksi muita tyyppejä. Esimerkiksi kappaleessa <a href="#45">45</a> huomasimme että <em>kaikki</em> oliot ovat tyyppiä <code>Object</code>. Jos olio on jotain tiettyä tyyppiä, voidaan se myös esittää <code>Object</code>-tyyppisenä muuttujana. Esimerkiksi <code><a href="http://docs.oracle.com/javase/6/docs/api/java/lang/String.html" target="_blank">String</a></code> on myös tyyppiä <code>Object</code>, joten kaikki <code>String</code>-tyyppiset muuttujat voidaan esitellä <code>Object</code> tyypin avulla.</p>

<pre class="sh_java">
    String merkkijono = "merkkijono";
    Object merkkijonoString = "toinen merkkijono";
</pre>

    <p>Merkkijono-olion asettaminen <code>Object</code>-tyyppiseen viitteeseen onnistuu.</p>

<pre class="sh_java">
    String merkkijono = "merkkijono";
    Object merkkijonoString = merkkijono;
</pre>

    <p>Toiseen suuntaan asettaminen ei onnistu. Koska <code>Object</code>-tyyppiset muuttujat eivät ole tyyppiä <code>String</code>, ei object-tyyppistä muuttujaa voi asettaa <code>String</code>-tyyppiseen muuttujaan.</p>

<pre class="sh_java">
    Object merkkijonoString = "toinen merkkijono";
    String merkkijono = merkkijonoString; // EI ONNISTU!
</pre>

    <p>Mistä tässä oikein on kyse?</p>

    <p>Muuttujilla on oman tyyppinsä lisäksi aina perimiensä luokkien ja toteuttamiensa rajapintojen tyypit. Luokka <code>String</code> perii <code>Object</code>-luokan, joten <code>String</code>-oliot ovat aina myös tyyppiä <code>Object</code>. Luokka <code>Object</code> ei peri <code>String</code>-luokkaa, joten <code>Object</code>-tyyppiset muuttujat eivät ole automaattisesti tyyppiä <code>String</code>. Tutustutaan tarkemmin <code><a href="http://docs.oracle.com/javase/6/docs/api/java/lang/String.html">String</a></code>-luokan API-dokumentaatioon, erityisesti HTML-sivun yläosaan.</p>

    <p><img src="https://www.cs.helsinki.fi/group/java/k13/ohja/img-ohja/perinta/string-api.png"/></p>

    <p>String-luokan API-dokumentaatio alkaa yleisellä otsakkeella jota seuraa luokan pakkaus (<code>java.lang</code>). Pakkauksen jälkeen tulee luokan nimi (<code>Class String</code>), jota seuraa luokan <em>perintähierarkia</em>.</p>

<pre>
<a href="http://docs.oracle.com/javase/6/docs/api/java/lang/Object.html">java.lang.Object</a>
  <img src="https://www.cs.helsinki.fi/group/java/k13/ohja/img-ohja/perinta/perinta.gif"/><strong>java.lang.String</strong>
</pre>

    <p>Perintähierarkia listaa luokat, jotka luokka on perinyt. Perityt luokat listataan perimisjärjestyksessä, tarkasteltava luokka aina alimpana. String-luokan perintähierarkiasta näemme, että <code>String</code>-luokka perii luokan <code>Object</code>. <em>Javassa jokainen luokka voi periä korkeintaan yhden luokan</em>, mutta välillisesti niitä voi periä useampia.</p>
    <p>Perintähierarkiaa voi ajatella myös listana tyypeistä, joita olio toteuttaa.</p>

    <p>Se, että kaikki oliot ovat tyyppiä <code>Object</code> helpottaa ohjelmointia. Jos tarvitsemme metodissa vain <code>Object</code>-luokassa määriteltyjä toimintoja, voimme käyttää metodin parametrina tyyppiä <code>Object</code>. Koska kaikki oliot ovat myös tyyppiä object, voi metodille antaa <em>minkä tahansa</em> olion parametrina. Luodaan metodi <code>tulostaMonesti</code>, joka saa parametrinaan <code>Object</code>-tyyppisen muuttujan ja tulostusten lukumäärän.</p>

<pre class="sh_java">
public class Tulostin {
    ...
    public void tulostaMonesti(Object object, int kertaa) {
        for (int i = 0; i &lt; kertaa; i++) {
            System.out.println(object.toString());
        }
    }
    ...
}
</pre>

    <p>Metodille <code>tulostaMonesti</code> voi antaa parametrina minkä tahansa olion. Metodin <code>tulostaMonesti</code> sisässä oliolla on käytössään vain <code>Object</code>-luokassa määritellyt metodit koska olio <em>esitellään</em> metodissa <code>Object</code>-tyyppisenä.</p>

<pre class="sh_java">
    Tulostin tulostin = new Tulostin();

    String merkkijono = " o ";
    List&lt;String&gt; sanat = new ArrayList&lt;String&gt;();
    sanat.add("polymorfismi");
    sanat.add("perintä");
    sanat.add("kapselointi");
    sanat.add("abstrahointi");

    tulostin.tulostaMonesti(merkkijono, 2);
    tulostin.tulostaMonesti(sanat, 3);
</pre>

<pre>
 o
 o
[polymorfismi, perintä, kapselointi, abstrahointi]
[polymorfismi, perintä, kapselointi, abstrahointi]
[polymorfismi, perintä, kapselointi, abstrahointi]
</pre>


    <p>Jatketaan <code>String</code>-luokan API-kuvauksen tarkastelua. Kuvauksessa olevaa perintähierarkiaa seuraa listaus luokan toteuttamista rajapinnoista.</p>

<pre>
<strong>All Implemented Interfaces:</strong>
  <A HREF="http://docs.oracle.com/javase/6/docs/api/java/io/Serializable.html" title="interface in java.io">Serializable</A>, <A HREF="http://docs.oracle.com/javase/6/docs/api/java/lang/CharSequence.html" title="interface in java.lang">CharSequence</A>, <A HREF="http://docs.oracle.com/javase/6/docs/api/java/lang/Comparable.html" title="interface in java.lang">Comparable</A>&lt;<A HREF="http://docs.oracle.com/javase/6/docs/api/java/lang/String.html" title="class in java.lang">String</A>&gt;
</pre>

    <p>Luokka <code>String</code> toteuttaa rajapinnat <code>Serializable</code>, <code>CharSequence</code>, ja <code>Comparable&lt;String&gt;</code>. Myös rajapinta on tyyppi. Luokan String API-kuvauksen mukaan String-olion tyypiksi voi asettaa seuraavat rajapinnat.</p>

<pre class="sh_java">
    Serializable serializableString = "merkkijono";
    CharSequence charSequenceString = "merkkijono";
    Comparable&lt;String&gt; comparableString = "merkkijono";
</pre>

    <p>Koska metodeille voidaan määritellä metodin parametrin tyyppi, voimme määritellä metodeja jotka vastaanottavat <em>tietyn rajapinnan toteuttavan</em> olion. Kun metodille määritellään parametrina rajapinta, sille voidaan antaa parametrina mikä tahansa olio joka toteuttaa kyseisen rajapinnan, metodi ei välitä olion oikeasta tyypistä.</p>

    <p>Täydennetään <code>Tulostin</code>-luokkaa siten, että sillä on metodi <code>CharSequence</code>-rajapinnan toteuttavien olioiden merkkien tulostamiseen. Rajapinta <code>CharSequence</code> tarjoaa muunmuassa metodit <code>int length()</code>, jolla saa merkkijonon pituuden, ja <code>char charAt(int index)</code>, jolla saa merkin tietyssä indeksissä.</p>

<pre class="sh_java">
public class Tulostin {
    ...
    public void tulostaMonesti(Object object, int kertaa) {
        for (int i = 0; i &lt; kertaa; i++) {
            System.out.println(object.toString());
        }
    }

    public void tulostaMerkit(CharSequence charSequence) {
        for (int i = 0; i &lt; charSequence.length(); i++) {
            System.out.println(charSequence.charAt(i);
        }
    }
    ...
}
</pre>

    <p>Metodille <code>tulostaMerkit</code> voi antaa minkä tahansa <code>CharSequence</code>-rajapinnan toteuttavan olion. Näitä on muunmuassa <code>String</code> ja merkkijonojen rakentamisessa usein Stringiä tehokkaampi <code>StringBuilder</code>. Metodi <code>tulostaMerkit</code> tulostaa annetun olion jokaisen merkin omalle rivilleen.</p>

<pre class="sh_java">
    Tulostin tulostin = new Tulostin();

    String mjono = "toimii";

    tulostin.tulostaMerkit(mjono);
</pre>

<pre>
t
o
i
m
i
i
</pre>

<div class="tehtavat">
<div class="tehtava">
<h3>Joukkoja</h3>

<p>Tässä tehtävässä teemme eliöita ja eliöistä koostuvia laumoja jotka liikkuvat ympäriinsä. Eliöiden sijaintien ilmoittamiseen käytetään  <em>kaksiulotteista koordinaatistoa</em>. Jokaiseen sijaintiin liittyy kaksi lukua, <code>x</code>- ja <code>y</code>-koordinaatti. Koordinaatti <code>x</code> kertoo, kuinka pitkällä "nollapisteestä" mitattuna sijainti on vaakasuunnassa, ja koordinaatti <code>y</code> vastaavasti kuinka pitkällä sijainti on pystysuunnassa. Jos koordinaatiston käsite ei ole tuttu, voit lukea siitä lisää esimerkiksi <a href="http://fi.wikipedia.org/wiki/Koordinaatisto">wikipediasta</a>.</p>

<p>Tehtävän mukana tulee rajapinta <code>Siirrettava</code>, joka kuvaa asiaa jota voidaan siirtää paikasta toiseen. Rajapinta sisältää metodin <code>void siirra(int dx, int dy)</code>. Parametri <code>dx</code> kertoo, paljonko asia siirtyy x-akselilla ja <code>dy</code> y-akselilla.</p>

<p>Tehtävässä toteutat luokat <code>Elio</code> ja <code>Lauma</code>, jotka molemmat ovat siirrettäviä. Toteuta kaikki toiminnallisuus pakkaukseen <code>siirrettava</code>.</p>

<h4>Elio-luokan toteuttaminen</h4>

<p>Luo pakkaukseen <code>siirrettava</code> luokka <code>Elio</code>, joka toteuttaa rajapinnan <code>Siirrettava</code>. Eliön tulee tietää oma sijaintinsa (x, y -koordinaatteina). Luokan <code>Elio</code> APIn tulee olla seuraava:</p>

  <ul>
    <li><strong>public Elio(int x, int y)</strong><br/>Luokan konstruktori, joka saa olion aloitussijainnin x- ja y-koordinaatit parametrina</li>
    <li><strong>public String toString()</strong><br/> Luo ja palauttaa oliosta merkkijonoesityksen. Eliön merkkijonoesityksen tulee olla seuraavanlainen <code>"x: 3; y: 6"</code>. Huomaa että koordinaatit on erotettu puolipisteellä (<code>;</code>)</li>
    <li><strong>public void siirra(int dx, int dy)</strong><br/> Siirtää oliota parametrina saatujen arvojen verran. Muuttuja <code>dx</code> sisältää muutoksen koordinaattiin <code>x</code>, muuttuja <code>dy</code> sisältää muutoksen koordinaattiin <code>y</code>. Esimerkiksi jos muuttujan <code>dx</code> arvo on 5, tulee oliomuuttujan <code>x</code> arvoa kasvattaa viidellä</li>
  </ul>

<p>Kokeile luokan <code>Elio</code> toimintaa seuraavalla esimerkkikoodilla. </p>

<pre class="sh_java">
     Elio elio = new Elio(20, 30);
     System.out.println(elio);
     elio.siirra(-10, 5);
     System.out.println(elio);
     elio.siirra(50, 20);
     System.out.println(elio);
</pre>

<pre>
x: 20; y: 30
x: 10; y: 35
x: 60; y: 55
</pre>

<h4>Lauman toteutus</h4>

<p>Luo seuraavaksi pakkaukseen <code>siirrettava</code> luokka <code>Lauma</code>, joka toteuttaa rajapinnan <code>Siirrettava</code>. Lauma koostuu useasta <code>Siirrettava</code>-rajapinnan toteutavasta oliosta, jotka tulee tallettaa esimerkiksi listarakenteeseen.</p>

<p>Luokalla <code>Lauma</code> tulee olla seuraavanlainen API.</p>

  <ul>
    <li><strong>public String toString()</strong><br/> Palauttaa merkkijonoesityksen lauman jäsenten sijainnista rivin vaihdolla erotettuna.</li>
    <li><strong>public void lisaaLaumaan(Siirrettava siirrettava)</strong><br/> Lisää laumaan uuden <code>Siirrettava</code>-rajapinnan toteuttavan olion</li>
    <li><strong>public void siirra(int dx, int dy)</strong><br/> Siirtää laumaa parametrina saatujen arvojen verran. Huomaa että tässä sinun tulee siirtää jokaista lauman jäsentä.</li>
  </ul>

<p>Kokeile ohjelmasi toimintaa alla olevalla esimerkkikoodilla.</p>

<pre class="sh_java">
    Lauma lauma = new Lauma();
    lauma.lisaaLaumaan(new Elio(73, 56));
    lauma.lisaaLaumaan(new Elio(57, 66));
    lauma.lisaaLaumaan(new Elio(46, 52));
    lauma.lisaaLaumaan(new Elio(19, 107));
    System.out.println(lauma);
</pre>

<pre>
x: 73; y: 56
x: 57; y: 66
x: 46; y: 52
x: 19; y: 107
</pre>
</div>
</div>

<h2>Luokan ominaisuuksien periminen</h2>

    <p>Luokat ovat ohjelmoijan tapa ratkaistavan ongelma-alueen käsitteiden selkeyttämiseen. Lisäämme jokaisella luomallamme luokalla uutta toiminnallisuutta ohjelmointikieleen. Toiminnallisuutta tarvitaan kohtaamiemme ongelmien ratkomiseen, ratkaisut syntyvät luokista luotujen olioiden välisen interaktion avulla. Olio-ohjelmoinnissa olio on itsenäinen kokonaisuus, jolla on olion tarjoamien metodien avulla muutettava tila. Olioita käytetään yhteistyössä; jokaisella oliolla on oma vastuualue. Esimerkiksi käyttöliittymäluokkamme ovat tähän mennessä hyödyntäneet <code>Scanner</code>-olioita.</p>

    <p>Jokainen Javan luokka perii luokan <code>Object</code>, eli jokainen luomamme luokka saa käyttöönsä kaikki <code>Object</code>-luokassa määritellyt metodit. Jos haluamme muuttaa <code>Object</code>-luokassa määriteltyjen metodien toiminnallisuutta tulee ne korvata (<code>Override</code>) määrittelemällä niille uusi toteutus luodussa luokassa.</p>

<p>Luokan <code>Object</code> perimisen lisäksi myös muiden luokkien periminen on mahdollista. Javan <code><a href="http://docs.oracle.com/javase/6/docs/api/java/util/ArrayList.html" target="_blank">ArrayList</a></code>-luokan APIa tarkasteltaessa huomaamme että <code>ArrayList</code> perii luokan <code>AbstractList</code>. Luokka <code>AbstractList</code> perii luokan <code>AbstractCollection</code>, joka perii luokan <code>Object</code>.</p>

<pre>
<a href="http://docs.oracle.com/javase/6/docs/api/java/lang/Object.html" target="_blank">java.lang.Object</a>
  <img src="https://www.cs.helsinki.fi/group/java/k13/ohja/img-ohja/perinta/perinta.gif" /><a href="http://docs.oracle.com/javase/6/docs/api/java/util/AbstractCollection.html" target="_blank">java.util.AbstractCollection</a>&lt;E&gt;
      <img src="https://www.cs.helsinki.fi/group/java/k13/ohja/img-ohja/perinta/perinta.gif" /><a href="http://docs.oracle.com/javase/6/docs/api/java/AbstractList.html" target="_blank">java.util.AbstractList</a>&lt;E&gt;
          <img src="https://www.cs.helsinki.fi/group/java/k13/ohja/img-ohja/perinta/perinta.gif" /><strong>java.util.ArrayList&lt;E&gt;</strong>
</pre>

        <p>Kukin luokka voi periä suoranaisesti yhden luokan. Välillisesti luokka kuitenkin perii kaikki perimänsä luokan ominaisuudet. Luokka <code>ArrayList</code> perii suoranaisesti luokan <code>AbstractList</code>, ja välillisesti luokat <code>AbstractCollection</code> ja <code>Object</code>. Luokalla <code>ArrayList</code> on siis käytössään luokkien <code>AbstractList</code>, <code>AbstractCollection</code> ja <code>Object</code> muuttujat, metodit <em>ja</em> rajapinnat.</p>

        <p>Luokan ominaisuudet peritään avainsanalla <code>extends</code>. Luokan perivää luokkaa kutsutaan aliluokaksi (<em>subclass</em>), perittävää luokkaa yliluokaksi (<em>superclass</em>). Tutustutaan erään autonvalmistajan järjestelmään, joka hallinnoi auton osia. Osien hallinan peruskomponentti on luokka <code>Osa</code>, joka määrittelee tunnuksen, valmistajan ja kuvauksen.</p>

<pre class="sh_java">
public class Osa {

    private String tunnus;
    private String valmistaja;
    private String kuvaus;

    public Osa(String tunnus, String valmistaja, String kuvaus) {
        this.tunnus = tunnus;
        this.valmistaja = valmistaja;
        this.kuvaus = kuvaus;
    }

    public String getTunnus() {
        return tunnus;
    }

    public String getKuvaus() {
        return kuvaus;
    }

    public String getValmistaja() {
        return valmistaja;
    }
}
</pre>

        <p>Yksi osa autoa on moottori. Kuten kaikilla osilla, myös moottorilla on valmistaja, tunnus ja kuvaus. Näiden lisäksi moottoriin liittyy moottorityyppi: esimerkiksi polttomoottori, sähkömoottori tai hybridi. Luodaan luokan <code>Osa</code> perivä luokka <code>Moottori</code>: moottori on osan erikoistapaus.</p>

<pre class="sh_java">
public class Moottori extends Osa {

    private String moottorityyppi;

    public Moottori(String moottorityyppi, String tunnus, String valmistaja, String kuvaus) {
        super(tunnus, valmistaja, kuvaus);
        this.moottorityyppi = moottorityyppi;
    }

    public String getMoottorityyppi() {
        return moottorityyppi;
    }
}
</pre>

        <p>Luokkamäärittely <code>public class Moottori extends Osa</code> kertoo että luokka <code>Moottori</code> perii luokan <code>Osa</code> toiminnallisuuden. Luokassa <code>Moottori</code> määritellään oliomuuttuja <code>moottorityyppi</code>.</p>

        <p>Moottori-luokan konstruktori on mielenkiintoinen. Konstruktorin ensimmäisellä rivillä on avainsana <code>super</code>, jolla kutsutaan yliluokan konstruktoria. Kutsu <code>super(tunnus, valmistaja, kuaus)</code> kutsuu luokassa <code>Osa</code> määriteltyä konstruktoria <code>public Osa(String tunnus, String valmistaja, String kuvaus</code>, jolloin yliluokassa määritellyt oliomuuttujat saavat arvonsa. Tämän jälkeen oliomuuttujalle <code>moottorityyppi</code> asetetaan siihen liittyvä arvo.</p>

        <p>Kun luokka <code>Moottori</code> perii luokan <code>Osa</code>, saa se käyttöönsä kaikki luokan <code>Osa</code> tarjoamat metodit. Luokasta <code>Moottori</code> voi tehdä ilmentymän aivan kuten mistä tahansa muustakin luokasta.</p>

<pre class="sh_java">
        Moottori moottori = new Moottori("polttomoottori", "hz", "volkswagen", "VW GOLF 1L 86-91");
        System.out.println(moottori.getMoottorityyppi());
        System.out.println(moottori.getValmistaja());
</pre>

<pre>
polttomoottori
volkswagen
</pre>

        <p>Kuten huomaat, luokalla <code>Moottori</code> on käytössä luokassa <code>Osa</code> määritellyt metodit.</p>

        <h3>Private, protected ja public</h3>

<p>Jos metodilla tai muuttujalla on näkyvyysmääre <code>private</code>, ei se näy aliluokille eikä aliluokalla ole mitään suoraa tapaa päästä käsiksi yliluokan siihen. Edellisessä esimerkissä Moottori ei siis pääse suoraan käsiksi yliluokassa Osa määriteltyihin ominaisuuksiinsa (tunnus, valmistaja, kuvaus). Aliluokka näkee luonnollisesti kaiken yliluokan julkisen eli <code>public</code>-määreellä varustetun kaluston. Jos halutaan määritellä yliluokkaan joitain muuttujia tai metodeja joiden näkeminen halutaan sallia aliluokille, mutta estää muilta voidaan käyttää näkyvyysmäärettä <code>protected</code>.</p>

        <h3>Yliluokka super</h3>

        <p>Yliluokan konstruktoria kutsutaan avainsanalla <code>super</code>. Kutsu <code>super</code> on käytännössä samanlainen kuin <code>this</code>-konstruktorikutsu. Kutsulle annetaan parametrina yliluokan konstruktorin vaatiman tyyppiset arvot.</p>

        <p>Konstruktoria kutsuttaessa yliluokassa määritellyt muuttujat alustetaan. Konstruktorikutsussa tapahtuu käytännössä täysin samat asiat kuin normaalissa konstruktorikutsussa. Jos yliluokassa ei ole määritelty parametritonta konstruktoria, tulee aliluokan konstruktorikutsuissa olla aina mukana yliluokan konstruktorikutsu.</p>

        <p>Huom! Kutsun <code>super</code> tulee olla aina konstruktorin ensimmäisellä rivillä!</p>

<h3>Yliluokan metodin kutsuminen</h3>

        <p>Yliluokassa määriteltyjä metodeja voi kutsua <code>super</code>-etuliitteen avulla, aivan kuten tässä luokassa määriteltyjä metodeja voi kutsua <code>this</code>-etuliitteellä. Esimerkiksi yliluokassa määriteltyä <code>toString</code>-metodia voi hyödyntää sen korvaavassa metodissa seuraavasti:</p>

<pre class="sh_java">
    @Override
    public String toString() {
        return super.toString() + "\n  Ja oma viestini vielä!";
    }
</pre>

<div class="tehtavat">
    <div class="tehtava">
  <h3>Henkilö ja sen perilliset</h3>

  <h4>Henkilo</h4>

  <p>Tee pakkaus <code>henkilot</code> ja sinne luokka <code>Henkilo</code>, joka toimii seuraavan pääohjelman yhteydessä</p>

<pre class="sh_java">
    public static void main(String[] args) {
        Henkilo pekka = new Henkilo("Pekka Mikkola", "Korsontie 1 03100 Vantaa");
        Henkilo esko = new Henkilo("Esko Ukkonen", "Mannerheimintie 15 00100 Helsinki");
        System.out.println(pekka);
        System.out.println(esko);
    }
</pre>

  <p>siten että tulostuu</p>

<pre>
Pekka Mikkola
  Korsontie 1 03100 Vantaa
Esko Ukkonen
  Mannerheimintie 15 00100 Helsinki
</pre>

<h4  >Opiskelija</h4>

  <p>Tee pakkaukseen luokka <code>Opiskelija</code> joka <i>perii</i> luokan <code>Henkilo</code>.

  <p>Opiskelijalla on aluksi 0 opintopistettä. Aina kun opiskelija opiskelee, kasvaa opintopistemäärä. Toteuta luokka siten, että seuraava pääohjelma:</p>

<pre class="sh_java">
    public static void main(String[] args) {
        Opiskelija olli = new Opiskelija("Olli", "Ida Albergintie 1 00400 Helsinki");
        System.out.println(olli );
        System.out.println("opintopisteitä " + olli.opintopisteita());
        olli.opiskele();
        System.out.println("opintopisteitä "+ olli.opintopisteita());
    }
</pre>

  <p>tuottaa tulostuksen:</p>

<pre>
Olli
  Ida Albergintie 1 00400 Helsinki
opintopisteitä 0
opintopisteitä 1
</pre>

<h4  >Opiskelijalle toString</h4>

  <p>Edellisessä tehtävässä <code>Opiskelija</code> perii toString-metodin luokalta <code>Henkilo</code>. Perityn metodin voi myös ylikirjoittaa, eli korvata omalla versiolla. Tee nyt <code>Opiskelija</code>:lle oma versio toString:istä joka toimii seuraavan esimerkin mukaan:</p>

<pre class="sh_java">
    public static void main(String[] args) {
        Opiskelija olli = new Opiskelija("Olli", "Ida Albergintie 1 00400 Helsinki");
        System.out.println( olli );
        olli.opiskele();
        System.out.println( olli );
    }
</pre>

  <p>Tulostuu:</p>

<pre>
Olli
  Ida Albergintie 1 00400 Helsinki
  opintopisteitä 0
Olli
  Ida Albergintie 1 00400 Helsinki
  opintopisteitä 1
</pre>

  <h4  >Opettaja</h4>

  <p>Tee pakkaukseen luokka <code>Henkilo</code>:n perivä luokka <code>Opettaja</code>. Opettajalla on palkka joka tulostuu opettajan merkkijonoesityksessä. </p>

  <p>Testaa, että seuraava pääohjelma</p>

<pre class="sh_java">
    public static void main(String[] args) {
        Opettaja pekka = new Opettaja("Pekka Mikkola", "Korsontie 1 03100 Vantaa", 1200);
        Opettaja esko = new Opettaja("Esko Ukkonen", "Mannerheimintie 15 00100 Helsinki", 5400);
        System.out.println( pekka );
        System.out.println( esko );

        Opiskelija olli = new Opiskelija("Olli", "Ida Albergintie 1 00400 Helsinki");
        for ( int i=0; i &lt; 25; i++ ) {
            olli.opiskele();
        }
        System.out.println( olli );
    }
</pre>

  <p>Aikaansaa tulostuksen</p>

<pre>
Pekka Mikkola
  Korsontie 1 03100 Vantaa
  palkka 1200 euroa/kk
Esko Ukkonen
  Mannerheimintie 15 00100 Helsinki
  palkka 5400 euroa/kk
Olli
  Ida Albergintie 1 00400 Helsinki
  opintopisteitä 25
</pre>

<h4  >Kaikki Henkilot listalle</h4>

  <p>Toteuta oletuspakkauksessa olevaan <code>Main</code>-luokkaan luokkametodi <code>public static void tulostaLaitoksenHenkilot(List&lt;Henkilo&gt; henkilot)</code>, joka tulostaa kaikki metodille parametrina annetussa listassa olevat henkilöt. Metodin tulee toimia seuraavasti <code>main</code>-metodista kutsuttaessa.</p>

<pre class="sh_java">
    public static void tulostaLaitoksenHenkilot(List&lt;Henkilo&gt; henkilot) {
       // tulostetaan kaikki listan henkilöt
    }

    public static void main(String[] args) {
        List&lt;Henkilo&gt; henkilot = new ArrayList&lt;Henkilo&gt;();
        henkilot.add( new Opettaja("Pekka Mikkola", "Korsontie 1 03100 Vantaa", 1200) );
        henkilot.add( new Opiskelija("Olli", "Ida Albergintie 1 00400 Helsinki") );

        tulostaLaitoksenHenkilot(henkilot);
    }
</pre>

<pre>
Pekka Mikkola
  Korsontie 1 03100 Vantaa
  palkka 1200 euroa/kk
Olli
  Ida Albergintie 1 00400 Helsinki
  opintopisteitä 0
</pre>

</div>
</div>

   <h3>Olion tyyppi määrää kutsutun metodin: Polymorfismi</h3>

    <p>Olion kutsuttavissa olevat metodit määrittyvät muuttujan tyypin kautta. Esimerkiksi jos <code>Opiskelija</code>-tyyppisen olion viite on talletettu  <code>Henkilo</code>-tyyppiseen muuttujaan, on oliosta käytössä vain <code>Henkilo</code>-luokassa määritellyt metodit:</p>

<pre class="sh_java">
   Henkilo olli = new Opiskelija("Olli", "Ida Albergintie 1 00400 Helsinki");
   olli.opintopisteita();        // EI TOIMI!
   olli.opiskele();              // EI TOIMI!
   String.out.println( olli );   // olli.toString() TOIMII
</pre>

<p>Jos oliolla on monta eri tyyppiä, on sillä käytössä <em>jokaisen</em> tyypin määrittelemät metodit. Esimerkiksi <code>Opiskelija</code>-tyyppisellä oliolla on käytössä <code>Henkilo</code>-luokassa määritellyt metodit sekä <code>Object</code>-luokassa määritellyt metodit.</p>

<p>Edellisessä tehtävässä korvasimme Opiskelijan luokalta Henkilö perimän <code>toString</code> uudella versiolla. Myös luokka Henkilö oli jo korvannut Object-luokalta perimänsä toStringin. Jos käsittelemme olioa jonkin muun kuin sen todellisen tyypin omaavan muuttujan kautta, mitä versiota olion metodista kutsutaan? Esim. seuraavassa on kaksi opiskelijaa joiden viitteet on talletettu Henkilo- ja Object-tyyppisiin muuttujiin. Molemmille kutsutaan metodia <code>toString</code>. Mikä versio metodista suoritetaan, luokassa Object, Henkilo vai Opiskelija määritelty?</p>

<pre class="sh_java">
   Henkilo olli = new Opiskelija("Olli", "Ida Albergintie 1 00400 Helsinki");
   String.out.println( olli );

   Object liisa = new Opiskelija("Liisa", "Väinö Auerin katu 20 00500 Helsinki");
   String.out.println( liisa );
</pre>

<p>Tulostuu:</p>

<pre>
Olli
  Ida Albergintie 1 00400 Helsinki
  opintopisteitä 0
Liisa
  Väinö Auerin katu 20 00500 Helsinki
  opintopisteitä 0
</pre>

<p>Eli suoritettava metodi valitaan olion todellisen tyypin perusteella, ei viitteen tallettavan muuttujan tyypin perusteella!</p>

    <p>Hieman yleisemmin: <b>Suoritettava metodi valitaan aina olion todellisen tyypin perusteella riippumatta käytetyn muuttujan tyypistä. Oliot ovat monimuotoisia, eli olioita voi käyttää usean eri muuttujatyypin kautta. Suoritettava metodi liittyy aina olion todelliseen tyyppiin.</b> Tätä monimuotoisuutta kutsutaan polymorfismiksi.</p>

<h3>Toinen esimerkki: pisteitä</h3>

<p>Kaksiulotteisessa koordinaatiostossa sijaitsevaa pistettä voisi kuvata seuraavan luokan avulla:</p>

<pre class="sh_java">
public class Piste {

    private int x;
    private int y;

    public Piste(int x, int y) {
        this.x = x;
        this.y = y;
    }

    public int manhattanEtaisyysOrigosta(){
        return Math.abs(x)+Math.abs(y);
    }

    protected String sijainti(){
        return x+", "+y;
    }

    @Override
    public String toString() {
        return "("+this.sijainti()+") etäisyys "+this.manhattanEtaisyysOrigosta();
    }
}
</pre>

<p>Metodi <code>sijainti</code> ei ole tarkoitettu ulkoiseen käyttöön, joten se on näkyvyysmääreeltään protected, eli aliluokat pääsevät siihen käsiksi. Esim. <a href="http://wiki.gamegardens.com/Path_Finding_Tutorial">reitinhakualgoritmien</a> hyödyntämässä <a href="http://en.wiktionary.org/wiki/Manhattan_distance">Manhattan-etäisyydellä</a> tarkoitetaan pisteiden etäisyyttä, jos niiden välin voi kulkea ainoastaan koordinaattiakselien suuntaisesti. </p>

<p>Värillinen piste on muuten samanlainen kuin piste, mutta se sisältää merkkijonona ilmaistavan värin. Luokka voidaan siis tehdä perimällä Piste:</p>

<pre class="sh_java">
public class VariPiste extends Piste {

    private String vari;

    public VariPiste(int x, int y, String vari) {
        super(x, y);
        this.vari = vari;
    }

    @Override
    public String toString() {
        return super.toString()+" väri: "+vari;
    }
}
</pre>

<p>Luokka määrittelee oliomuuttujan värin talletusta varten. Koordinaatit talletetaan yliluokkaan. Merkkijonoesityksestä halutaan muuten samanlainen kuin pisteellä, mutta väri tulee myös ilmaista. Ylikirjoitettu metodi <code>toString</code> kutsuukin yliluokan toStringiä ja lisää sen tulokseen pisteen värin.</p>

<p>Seuraavassa esimerkki, jossa listalle laitetaan muutama piste, osa normaaleja ja osa väripisteitä ja tulostetaan listalla olevat pisteet. Polymorfismin ansioista kaikille tulee kutsutuksi olion todellisen tyypin toString-metodi vaikka lista tuntee kaikki pisteet <code>Piste</code>-tyyppisinä:</p>

<pre class="sh_java">
public class Main {
    public static void main(String[] args) {
        List&lt;Piste&gt; pisteet = new ArrayList&lt;Piste&gt;();
        pisteet.add(new Piste(4, 8));
        pisteet.add(new VariPiste(1, 1, "vihreä"));
        pisteet.add(new VariPiste(2, 5, "sininen"));
        pisteet.add(new Piste(0, 0));

        for (Piste piste : pisteet) {
            System.out.println(piste);
        }
    }
}
</pre>

<p>Tulostuu:</p>

<pre>
(4, 8) etäisyys 12
(1, 1) etäisyys 2 väri: vihreä
(2, 5) etäisyys 7 väri: sininen
(0, 0) etäisyys 0
</pre>

<p>Haluamme ohjelmaamme myös kolmiulotteisen pisteen. Koska kyseessä ei ole värillinen versio, periytetään se pisteestä:</p>

<pre class="sh_java">
public class Piste3D extends Piste {

    private int z;

    public Piste3D(int x, int y, int z) {
        super(x, y);
        this.z = z;
    }

    @Override
    protected String sijainti() {
        return super.sijainti()+", "+z;    // tulos merkkijono muotoa "x, y, z"
    }

    @Override
    public int manhattanEtaisyysOrigosta() {
        // kysytään ensin yliluokalta x:n ja y:n perusteella laskettua etäisyyttä
        // ja lisätään tulokseen z-koordinaatin vaikutus
        return super.manhattanEtaisyysOrigosta()+Math.abs(z);
    }

    @Override
    public String toString() {
        return "("+this.sijainti()+") etäisyys "+this.manhattanEtaisyysOrigosta();
    }
}
</pre>

<p>Kolmiulotteinen piste siis määrittelee kolmatta koordinaattia vastaavan oliomuuttujan ja ylikirjoittaa metodit <code>sijainti</code>,
  <code>manhattanEtaisyysOrigosta</code> ja <code>toString</code> siten, että ne huomioivat kolmannen ulottuvuuden. Voimme nyt laajentaa edellistä esimerkkiä ja lisätä listalle myös kolmiulotteisia pisteitä:</p>

<pre class="sh_java">
public class Main {

    public static void main(String[] args) {
        List<Piste> pisteet = new ArrayList<Piste>();
        pisteet.add(new Piste(4, 8));
        pisteet.add(new VariPiste(1, 1, "vihreä"));
        pisteet.add(new VariPiste(2, 5, "sininen"));
        pisteet.add(new Piste3D(5, 2, 8));
        pisteet.add(new Piste(0, 0));

        for (Piste piste : pisteet) {
            System.out.println(piste);
        }
    }
}
</pre>

<p>Tulostus on odotusten mukainen</p>

<pre>
(4, 8) etäisyys 12
(1, 1) etäisyys 2 väri: vihreä
(2, 5) etäisyys 7 väri: sininen
(5, 2, 8) etäisyys 15
(0, 0) etäisyys 0
</pre>

<p>Huomamme, että kolmiulotteisen pisteen metodi <code>toString</code> on täsmälleen sama kuin pisteen toString. Voisimmeko jättää toStringin ylikirjoittamatta? Vastaus on kyllä! Kolmiulotteinen piste pelkistyy seuraavanlaiseksi:</p>

<pre class="sh_java">
public class Piste3D extends Piste {

    private int z;

    public Piste3D(int x, int y, int z) {
        super(x, y);
        this.z = z;
    }

    @Override
    protected String sijainti() {
        return super.sijainti()+", "+z;
    }

    @Override
    public int manhattanEtaisyysOrigosta() {
        return super.manhattanEtaisyysOrigosta()+Math.abs(z);
    }
}
</pre>

<p>Mitä tarkalleenottaen tapahtuu kuin kolmiulotteiselle pisteelle kutsutaan toString-metodia? Suoritus etenee seuraavasti:</p>
<ol>
<li>etsitään toString:in määrittelyä luokasta Piste3D, sitä ei löydy joten mennään yliluokkaan</li>
<li>etsitään toString:in määrittelyä yliluokasta Piste, metodi löytyy, joten suoritetaan sen koodi</li>
<ul>
<li>suoritettava koodi siis on <code>return "("+this.sijainti()+") etäisyys "+this.manhattanEtaisyysOrigosta();</code></li>
<li>esimmäisenä suoritetaan metodi sijainti</li>
<li>etsitään metodin sijainti määrittelyä luokasta Piste3D, metodi löytyy ja suoritetaan sen koodi</li>
<li>metodin sijainti laskee oman tuloksensa kutsumalla yliluokassa olevaa metodia sijainti</li>
<li>seuraavaksi etsitään metodin manhattanEtaisyysOrigosta määrittelyä luokasta Piste3D, metodi löytyy ja suoritetaan sen koodi</li>
<li>jälleen metodi laskee tuloksensa kutsuen ensin yliluokassa olevaa samannimistä metodia</li>
</ul>
</ol>

<p>Metodikutsun aikaansaama toimintoketju siis on varsin monivaiheinen. Periaate on kuitenkin selkeä: suoritettavan metodin määrittelyä etsitään ensin olion todellisen tyypin määrittelystä ja jos sitä ei löydy edetään yliluokkaan. Ja jos yliluokastakaan ei löydy metodin toteutusta siirrytään etsimään yliluokan yliluokasta jne...</p>

          <h3>Milloin perintää tulee käyttää?</h3>

          <p>Perintä on väline käsitehierarkioiden rakentamiseen ja erikoistamiseen; aliluokka on aina yliluokan erikoistapaus. Jos luotava luokka on olemassaolevan luokan erikoistapaus, voidaan uusi luokka luoda perimällä olemassaoleva luokka. Esimerkiksi auton osiin liittyvässä esimerkissä moottori <em>on</em> osa, mutta moottoriin liittyy lisätoiminnallisuutta mitä jokaisella osalla ei ole.</p>

          <p>Perittäessä aliluokka saa käyttöönsä yliluokan toiminnallisuudet. Jos aliluokka ei tarvitse tai käytä perittyä toiminnallisuutta, ei perintä ole perusteltua. Perityt luokat perivät yliluokkiensa metodit ja rajapinnat, eli aliluokkia voidaan käyttää missä tahansa missä yliluokkaa on käytetty. Perintähierarkia kannattaa pitää matalana, sillä hierarkian ylläpito ja jatkokehitys vaikeutuu perintöhierarkian kasvaessa. Yleisesti ottaen, jos perintähierarkian korkeus on yli 2 tai 3, ohjelman rakenteessa on todennäköisesti parannettavaa.</p>

          <p>Perinnän käyttöä tulee miettiä. Esimerkiksi luokan <code>Auto</code> periminen luokasta <code>Osa</code> (tai <code>Moottori</code>) on väärin. Auto <em>sisältää</em> moottorin ja osia, mutta auto ei ole moottori tai osa. Voimme yleisemmin ajatella että jos olio omistaa tai koostuu toisista olioista, ei perintää tule käyttää.</p>

          <p>Perintää käytettäessä tulee varmistaa että Single Responsibility Principle pätee myös perittäessä. Jokaisella luokalla tulee olla vain yksi syy muuttua. Jos huomaat että perintä lisää luokan vastuita, tulee luokka pilkkoa useammaksi luokaksi.</p>

          <h4>Esimerkki: perinnän väärinkäyttö</h4>

          <p>Pohditaan postituspalveluun liittyviä luokkia <code>Asiakas</code>, joka sisältää asiakkaan tiedot, ja <code>Tilaus</code>, joka perii asiakkaan tiedot ja sisältää tilattavan tavaran tiedot. Luokassa <code>Tilaus</code> on myös metodi <code>postitusOsoite</code>, joka kertoo tilauksen postitusosoitteen.</p>

<pre class="sh_java">
public class Asiakas {

    private String nimi;
    private String osoite;

    public Asiakas(String nimi, String osoite) {
        this.nimi = nimi;
        this.osoite = osoite;
    }

    public String getNimi() {
        return nimi;
    }

    public String getOsoite() {
        return osoite;
    }

    public void setOsoite(String osoite) {
        this.osoite = osoite;
    }
}
</pre>

<pre class="sh_java">
public class Tilaus extends Asiakas {

    private String tuote;
    private String lukumaara;

    public Tilaus(String tuote, String lukumaara, String nimi, String osoite) {
        super(nimi, osoite);
        this.tuote = tuote;
        this.lukumaara = lukumaara;
    }

    public String getTuote() {
        return tuote;
    }

    public String getLukumaara() {
        return lukumaara;
    }

    public String postitusOsoite() {
        return this.getNimi() + "\n" + this.getOsoite();
    }
}
</pre>

  <p>Yllä perintää on käytetty väärin. Luokkaa perittäessä aliluokan tulee olla yliluokan erikoistapaus; tilaus ei ole asiakkaan erikoistapaus. Väärinkäyttö ilmenee single responsibility principlen rikkomisena: luokalla <code>Tilaus</code> on vastuu sekä asiakkaan tietojen ylläpidosta, että tilauksen tietojen ylläpidosta.</p>

  <p>Ratkaisussa piilevä ongelma tulee esiin kun mietimme mitä käy asiakkaan osoitteen muuttuessa.</p>

  <p>Osoitteen muuttuessa joudumme muuttamaan <em>jokaista</em> kyseiseen asiakkaaseen liittyvää tilausoliota, mikä kertoo huonosta tilanteesta. Parempi ratkaisu olisi kapseloida <code>Asiakas</code> <code>Tilaus</code>-luokan oliomuuttujaksi. Jos ajattelemme tarkemmin tilauksen semantiikkaa, tämä on selvää. <em>Tilauksella on asiakas</em>. Muutetaan luokkaa <code>Tilaus</code> siten, että se sisältää <code>Asiakas</code>-viitteen.</p>

<pre class="sh_java">
public class Tilaus {

    private Asiakas asiakas;
    private String tuote;
    private String lukumaara;

    public Tilaus(Asiakas asiakas, String tuote, String lukumaara) {
        this.asiakas = asiakas;
        this.tuote = tuote;
        this.lukumaara = lukumaara;
    }

    public String getTuote() {
        return tuote;
    }

    public String getLukumaara() {
        return lukumaara;
    }

    public String postitusOsoite() {
        return this.asiakas.getNimi() + "\n" + this.asiakas.getOsoite();
    }
}
</pre>

    <p>Yllä oleva luokka <code>Tilaus</code> on nyt parempi. Metodi <code>postitusosoite</code> käyttää <em>asiakas</em>-viitettä postitusosoitteen saamiseen sen sijaan että luokka perisi luokan <code>Asiakas</code>. Tämä helpottaa sekä ohjelman ylläpitoa, että sen konkreettista toiminnallisuutta. </p>

    <p>Nyt asiakkaan muuttaessa tarvitsee muuttaa vain asiakkaan tietoja, tilauksiin ei tarvitse tehdä muutoksia.</p>

<div class="tehtavat">
<div class="tehtava">
<h3>Varastointia</h3>

<p>Tehtäväpohjassa tulee mukana luokka <code>Varasto</code>, jonka tarjoamat konstruktorit ja metodit ovat seuraavat:</p>

<ul>

<li><b>public Varasto(double tilavuus)</b><br/>
     Luo tyhjän varaston, jonka vetoisuus eli tilavuus annetaan parametrina;
     sopimaton tilavuus (&lt;=0) luo käyttökelvottoman varaston,
     jonka tilavuus on 0.</li>

<li><b>public double getSaldo()</b><br/>
     Palauttaa arvonaan varaston saldon, eli varastossa olevan tilavuuden.</li>


<li><b>public double getTilavuus()</b><br/>
     Palauttaa arvonaan varaston tilavuuden (eli sen, joka annettiin konstruktorille).</li>

<li><b>public double paljonkoMahtuu()</b><br/>
     Palauttaa arvonaan tiedon, paljonko varastoon vielä mahtuu.</li>

<li><b>public void lisaaVarastoon(double maara)</b><br/>
     Lisää varastoon pyydetyn määrän; jos määrä on negatiivinen, mikään ei muutu,
     jos kaikki pyydetty ei enää mahdu, varasto laitetaan
     täydeksi ja loput määräsätä "heitetään menemään", "vuotaa yli".</li>

<li><b>public double otaVarastosta(double maara)</b><br/>
    Otetaan varastosta pyydetty määrä, metodi palauttaa paljonko <b>saadaan</b>.
    Jos pyydetty määrä on negatiivinen, mikään ei muutu ja palautetaan nolla.
    Jos pyydetään enemmän kuin varastossa on, annetaan mitä voidaan ja varasto
    tyhjenee.</li>

<li><b>public String toString()</b><br/>
    Palauttaa olion tilan merkkijonoesityksenä tyyliin <tt>saldo = 64.5, tilaa 123.5</tt></li>
</ul>

        <p>Tehtävässä rakennetaan <code>Varasto</code>-luokasta useampia erilaisia varastoja. Huom! Toteuta kaikki luokat pakkaukseen <code>varastot</code>.</p>

        <h4  >Tuotevarasto, vaihe 1</h4>

        <p>Luokka <code>Varasto</code> hallitsee tuotteen määrään liittyvät toiminnot. Nyt tuotteelle halutaan lisäksi tuotenimi ja nimen käsittelyvälineet. <i>  <b>Ohjelmoidaan Tuotevarasto Varaston aliluokaksi!</b></i> Toteutetaan ensin pelkkä yksityinen oliomuuttuja tuotenimelle, konstruktori ja getteri nimikentälle:</p>


<ul>
<li><b>public Tuotevarasto(String tuotenimi, double tilavuus)</b><br/>
     Luo tyhjän tuotevaraston. Tuotenimi ja vetoisuus annetaan parametrina.</li>


<li><b>public String getNimi()</b><br/>
     Palauttaa arvonaan tuotteen nimen.</li>
</ul>


        <p><i>Muista millä tavoin konstruktori voi ensi toimenaan suorittaa yliluokan konstruktorin!</i></p>

        <p>Käyttöesimerkki:</p>

<pre class="sh_java">
        Tuotevarasto mehu = new Tuotevarasto("Juice", 1000.0);
        mehu.lisaaVarastoon(1000.0);
        mehu.otaVarastosta(11.3);
        System.out.println(mehu.getNimi()); // Juice
        System.out.println(mehu);           // saldo = 988.7, tilaa 11.3
</pre>

<pre>
Juice
saldo = 988.7, vielä tilaa 11.3
</pre>


<h4  >Tuotevarasto, vaihe 2</h4>


<p>Kuten edellisestä esimerkistä näkee, Tuotevarasto-olion perimä <code>toString()</code> ei tiedä (tietenkään!) mitään tuotteen nimestä. <i>Asialle on tehtävä jotain!</i> Lisätään samalla myös setteri tuotenimelle:</p>

<ul>
<li><b>public void setNimi(String uusiNimi)</b> asettaa tuotteelle
       uuden nimen.</li>

<li><b>public String toString()</b> palauttaa olion tilan merkkijonoesityksenä
       tyyliin <tt>Juice: saldo = 64.5, tilaa 123.5</tt></li>
</ul>

        <p>Uuden <code>toString()</code>-metodin voisi toki ohjelmoida käyttäen yliluokalta perittyjä gettereitä, joilla perittyjen, mutta piilossa pidettyjen kenttien arvoja saa käyttöönsä. Koska yliluokkaan on kuitenkin jo ohjelmoitu tarvittava taito varastotilanteen merkkiesityksen tuottamiseen, miksi nähdä vaivaa sen uudelleen ohjelmointiin. Käytä siis hyväksesi perittyä <code>toString</code>iä.</p>

        <p><i>Muista miten korvattua metodia voi kutsua aliluokassa!</i></p>

        <p>Käyttöesimerkki:</p>

<pre class="sh_java">
        Tuotevarasto mehu = new Tuotevarasto("Juice", 1000.0);
        mehu.lisaaVarastoon(1000.0);
        mehu.otaVarastosta(11.3);
        System.out.println(mehu.getNimi()); // Juice
        mehu.lisaaVarastoon(1.0);
        System.out.println(mehu);           // Juice: saldo = 989.7, tilaa 10.299999999999955
</pre>

<pre>
Juice
Juice: saldo = 989.7, tilaa 10.299999999999955
</pre>


<h4>Muutoshistoria</h4>

        <p>Toisinaan saattaa olla kiinnostavaa tietää, millä tavoin jonkin tuotteen varastotilanne muuttuu: onko varasto usein hyvin vajaa, ollaanko usein ylärajalla, onko vaihelu suurta vai pientä, jne. Varustetaan siksi <code>Tuotevarasto</code>-luokka taidolla muistaa tuotteen määrän muutoshistoriaa.</p>

        <p>Aloitetaan apuvälineen laadinnalla.</p>

        <p>Muutoshistorian muistamisen voisi toki toteuttaa suoraankin <code>ArrayList&lt;Double&gt;</code>-oliona luokassa <i>Tuotevarasto</i>, mutta nyt laaditaan kuitenkin oma <i>erikoistettu väline</i> tähän tarkoitukseen. Väline toteutetaan kapseloimalla <code>ArrayList&lt;Double&gt;</code>-olio.</p>

        <p><code>Muutoshistoria</code>-luokan julkiset konstruktorit ja metodit:</p>

<ul>
<li><b>public Muutoshistoria()</b> luo tyhjän <code>Muutoshistoria</code>-olion.</li>

<li><b>public void lisaa(double tilanne)</b> lisää muutoshistorian viimeisimmäksi muistettavaksi määräksi parametrina annetun tilanteen. </li>

<li><b>public void nollaa()</b> tyhjää muistin.</li>

<li><b>public String toString()</b> palauttaa muutoshistorian
    merkkijonoesityksen. <i>ArrayList-luokan antama merkkijonoesitys kelpaa sellaisenaan.</i> </li>

</ul>


<h4  >Muutoshistoria.java, vaihe 2</h4>

<p>
Täydennä <code>Muutoshistoria</code>-luokkaa analyysimetodein:</p>

<ul>

<li><b>public double maxArvo()</b> palauttaa muutoshistorian
   suurimman arvon. Jos historia on tyhjä, metodi palauttaa nollan.</li>


<li><b>public double minArvo()</b> palauttaa muutoshistorian
   pienimmän arvon. Jos historia on tyhjä, metodi palauttaa nollan.</li>

<li><b>public double keskiarvo()</b> palauttaa muutoshistorian
    arvojen keskiarvon. Jos historia on tyhjä, metodi palauttaa nollan.</li>

</ul>

<h4>Muutoshistoria.java, vaihe 3</h4>

<p>
Täydennä <code>Muutoshistoria</code>-luokkaa analyysimetodein:</p>

<ul>
<li><b>public double suurinMuutos()</b> palauttaa muutoshistorian isoimman (huom: -5:n kokoinen muutos on isompi kuin 4:n kokoinen muutos) yksittäisen muutoksen itseisarvon. Jos historia on tyhjä tai yhden arvon mittainen, metodi palauttaa nollan. Itseisarvo on luvun etäisyys nollasta. Esimerkiksi luvun -5.5 itseisarvo on 5.5, luvun 3.2 itseisarvo on 3.2. </li>

<li><b>public double varianssi()</b> palauttaa muutoshistorian arvojen varianssin (käytetään otosvarianssin kaavaa). Jos historia on tyhjä tai yhden arvon mittainen, metodi palauttaa nollan.</li>
</ul>

<p>Ohjeen varianssin laskemiseksi voit katsoa esimerkiksi <a href="http://fi.wikipedia.org/wiki/Varianssi#Populaatio-_ja_otosvarianssi">Wikipediasta</a> kohdasta populaatio- ja otosvarianssi. Esimerkiksi lukujen 3, 2, 7, 2 keskiarvo on 3.5, joten otosvarianssi on ((3 - 3.5)² + (2 - 3.5)² + (7 - 3.5)² + (2 - 3.5)²)/(4 - 1) ≈ 5,666667.)</p>




<h4  >MuistavaTuotevarasto, vaihe 1</h4>

<p>
Toteuta luokan <code>Tuotevarasto</code> aliluokkana <code>MuistavaTuotevarasto</code>.
Uusi versio tarjoaa vanhojen lisäksi varastotilanteen muutoshistoriaan liittyviä
palveluita. Historiaa hallitaan <code>Muutoshistoria</code>-oliolla.
</p>

<p>
Julkiset konstruktorit ja metodit:</p>

<ul>

<li><b>public MuistavaTuotevarasto(String tuotenimi, double tilavuus, double alkuSaldo)</b>
     luo tuotevaraston. Tuotenimi, vetoisuus ja alkusaldo annetaan parametrina.
     <i>Aseta alkusaldo sekä varaston alkusaldoksi että muutoshistorian ensimmäiseksi arvoksi.</i>

<li><b>public String historia()</b> palauttaa tuotehistorian tyyliin
       <tt>[0.0, 119.2, 21.2]</tt>.  <i>Käytä Muutoshistoria-olion merkkiesitystä sellaisenaan.</i>

</ul>
<p>
<b>Huomaa</b> että tässä esiversiossa historia ei vielä toimi kunnolla; nyt vasta vain aloitussaldo muistetaan.
</p>

<p>
Käyttöesimerkki:
</p>

<pre class="sh_java">
// tuttuun tapaan:
MuistavaTuotevarasto mehu = new MuistavaTuotevarasto("Juice", 1000.0, 1000.0);
mehu.otaVarastosta(11.3);
System.out.println(mehu.getNimi()); // Juice
mehu.lisaaVarastoon(1.0);
System.out.println(mehu);           // Juice: saldo = 989.7, vielä tilaa 10.3
...
<b>// mutta vielä historia() ei toimi kunnolla:</b>
System.out.println(mehu.historia()); // [1000.0]
   // saadaan siis vasta konstruktorin asettama historian alkupiste...
...
</pre>


<p>
Tulostus siis:
</p>
<pre>
Juice
Juice: saldo = 989.7, vielä tilaa 10.299999999999955
[1000.0]
</pre>

<h4  >MuistavaTuotevarasto, vaihe 2</h4>

<p>
<i>On aika aloittaa historia!</i> Ensimmäinen versio ei historiasta tiennyt kuin alkupisteen. Täydennä luokkaa metodein
</p>
<ul>

<li><b>public void lisaaVarastoon(double maara)</b>

    toimii kuin <i>Varasto</i>-luokan metodi, mutta muuttunut tilanne kirjataan historiaan.
<b>Huom: </b> historiaan tulee kirjata lisäyksen jälkeinen varastosaldo, ei lisättävää määrää!
</li>



<li><b>public double otaVarastosta(double maara)</b> toimii kuin <code>Varasto</code>-luokan metodi, mutta muuttunut tilanne kirjataan historiaan. <b>Huom: </b> historiaan tulee kirjata poiston jälkeinen varastosaldo, ei poistettavaa määrää!</li>

</ul>

<p>
Käyttöesimerkki:
</p>

<pre class="sh_java">
// tuttuun tapaan:
MuistavaTuotevarasto mehu = new MuistavaTuotevarasto("Juice", 1000.0, 1000.0);
mehu.otaVarastosta(11.3);
System.out.println(mehu.getNimi()); // Juice
mehu.lisaaVarastoon(1.0);
System.out.println(mehu);           // Juice: saldo = 989.7, vielä tilaa 10.3
...
// mutta nyt on historiaakin:
System.out.println(mehu.historia()); // [1000.0, 988.7, 989.7]
...
</pre>
<p>
Tulostus siis:
</p>
<pre>
Juice
Juice: saldo = 989.7, vielä tilaa 10.299999999999955
[1000.0, 988.7, 989.7]
</pre>
<p>

<p>
<i>Muista miten korvaava metodi voi käyttää hyväkseen korvattua metodia!</i>
</p>


<h4  >MuistavaTuotevarasto, vaihe 3</h4>
<p>
Täydennä luokkaa metodilla
</p>
<ul>

<li><b>public void tulostaAnalyysi()</b>, joka tulostaa
     tuotteeseen liittyviä historiatietoja esimerkin
     esittämään tapaan.</li>
</ul>

<p>
Käyttöesimerkki:
</p>
<pre class="sh_java">
MuistavaTuotevarasto mehu = new MuistavaTuotevarasto("Juice", 1000.0, 1000.0);
mehu.otaVarastosta(11.3);
mehu.lisaaVarastoon(1.0);
//System.out.println(mehu.historia()); // [1000.0, 988.7, 989.7]

mehu.tulostaAnalyysi();
</pre>
<p>
Metodi <i>tulostaAnalyysi</i> kirjoittaa ilmoituksen tyyliin:
</p>

<pre>
Tuote: Juice
Historia: [1000.0, 988.7, 989.7]
Suurin tuotemäärä: 1000.0
Pienin tuotemäärä: 988.7
Keskiarvo: 992.8
</pre>
<p>

<h4>MuistavaTuotevarasto, vaihe 4</h4>
<p>
Täydennä analyysin tulostus sellaiseksi, että mukana ovat myös muutoshistorian suurin muutos ja historian varianssi.
</p>
<!--Puuttu </p></p></p></p> -->
</div>
</div>


<h3>Perintä, rajapinnat, kumpikin, vai eikö kumpaakaan?</h3>

<p>Perintä ei sulje pois rajapintojen käyttöä, eikä rajapintojen käyttö sulje pois perinnän käyttöä. Rajapinnat toimivat sopimuksena luokan tarjoamasta toteutuksesta, ja mahdollistavat konkreettisen toteutuksen abstrahoinnin. Rajapinnan toteuttavan luokan vaihto on hyvin helppoa.</p>

        <p>Aivan kuten rajapintaa toteuttaessa, sitoudumme perittäessä siihen, että aliluokkamme tarjoaa kaikki yliluokan metodit. Monimuotoisuuden ja polymorfismin takia perintäkin toimii kuin rajapinnat. Voimme antaa yliluokkaa käyttävälle metodille sen aliluokan ilmentymän.</p>

        <p>Tehdään seuraavaksi maatilasimulaattori, jossa simuloidaan maatilan elämää. Huomaa että ohjelmassa ei käytetä perintää, ja rajapintojenkin käyttö on melko vähäistä. Usein ohjelmat tehdäänkin niin että ensin toteutetaan yksi versio, jota lähdetään parantamaan myöhemmin. Tyypillistä on että ensimmäistä versiota toteutettaessa ongelma-aluetta ei vielä ymmärretä kunnolla, jolloin rajapintojen ja käsitehierarkioiden suunnittelu ennalta on hyvin vaikeaa ja saattaa jopa hidastaa työskentelyä.</p>


<div class="tehtavat">
    <div class="tehtava">
<h3>Maatilasimulaattori</h3>

<p>
Maatiloilla on lypsäviä eläimiä, jotka tuottavat maitoa.  Maatilat
eivät itse käsittele maitoa, vaan se kuljetetaan Maitoautoilla
meijereille.  Meijerit ovat yleisiä maitotuotteita tuottavia
rakennuksia.  Jokainen meijeri erikoistuu yhteen tuotetyyppiin,
esimerkiksi Juustomeijeri tuottaa Juustoa, Voimeijeri tuottaa voita ja
Maitomeijeri tuottaa maitoa.
<p>

<p>
Rakennetaan maidon elämää kuvaava simulaattori. Toteuta kaikki luokat pakkaukseen <code>maatilasimulaattori</code>.
<p>


<h4>Maitosäiliö</h4>

<p>
Jotta maito pysyisi tuoreena, täytyy se säilöä sille tarkoitettuun säiliöön.
Säiliöitä valmistetaan sekä oletustilavuudella 2000 litraa, että
asiakkaalle räätälöidyllä tilavuudella.  Toteuta luokka Maitosailio
jolla on seuraavat konstruktorit ja metodit.
</p>

  <ul>
    <li><strong>public Maitosailio()</strong></li>
    <li><strong>public Maitosailio(double tilavuus)</strong></li>
    <li><strong>public double getTilavuus()</strong></li>
    <li><strong>public double getSaldo()</strong></li>
    <li><strong>public double paljonkoTilaaJaljella()</strong></li>
    <li><strong>public void lisaaSailioon(double maara)</strong>
      lisää säiliöön vain niin paljon maitoa kuin sinne mahtuu,
      ylimääräiset jäävät lisäämättä, maitosäiliön ei siis tarvitse huolehtia tilanteesta jossa maitoa valuu yli</li>
    <li><strong>public double otaSailiosta(double maara)</strong>
      ottaa säiliöstä pyydetyn määrän, tai niin paljon kuin siellä on jäljellä
    </li>
  </ul>

<p>
Toteuta <code>Maitosailio</code>-luokalle myös <code>toString()</code>-metodi, jolla kuvaat sen tilaa.
Ilmaistessasi säiliön tilaa <code>toString()</code>-metodissa, pyöristä litramäärät
ylöspäin käyttäen <code>Math</code>-luokan tarjoamaa <code>ceil()</code>-metodia.
</p>

<p>Testaa maitosailiötä seuraavalla ohjelmapätkällä:</p>

<pre class="sh_java">
        Maitosailio sailio = new Maitosailio();
        sailio.otaSailiosta(100);
        sailio.lisaaSailioon(25);
        sailio.otaSailiosta(5);
        System.out.println(sailio);

        sailio = new Maitosailio(50);
        sailio.lisaaSailioon(100);
        System.out.println(sailio);
</pre>


<p>Ohjelman tulostuksen tulee olla seuraavankaltainen:</p>

<pre>
20.0/2000.0
50.0/50.0
</pre>

<p>
Huomaa että kutsuttaessa <code>System</code>-luokan <code>out</code>-olioon liittyvää
<code>println()</code>-metodia, joka saa parametrikseen <code>Object</code>-tyyppisen
muuttujan, tulostus käyttää <code>Maitosailio</code>-luokassa korvattua
<code>toString()</code>-metodia! Tässä on kyse polymorfismista, eli
ajonaikaisesta käytettävien metodien päättelystä.
</p>

<h4>Lehmä</h4>

<p>Saadaksemme maitoa tarvitsemme myös lehmiä. Lehmällä on nimi ja utareet. Utareiden tilavuus on satunnainen luku väliltä 15 ja 40, luokkaa <code>Random</code> voi käyttäää satunnaislukujen arpomiseen, esimerkiksi  <code>int luku = 15 + new Random().nextInt(26);</code>. Luokalla <code>Lehma</code> on seuraavat toiminnot:</p>

  <ul>
    <li><strong>public Lehma()</strong> luo uuden lehmän satunnaisesti valitulla nimellä</li>
    <li><strong>public Lehma(String nimi)</strong> luo uuden lehmän annetulla nimellä</li>
    <li><strong>public String getNimi()</strong> palauttaa lehmän nimen</li>
    <li><strong>public double getTilavuus()</strong> palauttaa utareiden tilavuuden</li>
    <li><strong>public double getMaara()</strong> palauttaa utareissa olevan maidon määrän</li>
    <li><strong>public String toString()</strong> palauttaa lehmää kuvaavan merkkijonon (ks. esimerkki alla)</li>
  </ul>

<p><code>Lehma</code> toteuttaa myös rajapinnat: <code>Lypsava</code>, joka kuvaa lypsämiskäyttäytymistä, ja <code>Eleleva</code>, joka kuvaa elelemiskäyttäytymistä.</p>

<pre class="sh_java">
public interface Lypsava {
    public double lypsa();
}

public interface Eleleva {
    public void eleleTunti();
}
</pre>

<p>
Lehmää lypsettäessä sen koko maitovarasto tyhjennetään jatkokäsittelyä
varten.  Lehmän elellessä sen maitovarasto täyttyy hiljalleen.
Suomessa maidontuotannossa käytetyt lehmät tuottavat keskimäärin
noin 25-30 litraa maitoa päivässä.  Simuloidaan tätä tuotantoa
tuottamalla noin 0.7 - 2 litraa tunnissa.
</p>

<p>
Jos lehmälle ei anneta nimeä, valitse sille nimi satunnaisesti seuraavasta listasta.
</p>

<pre class="sh_java">
    private static final String[] NIMIA = new String[]{
        "Anu", "Arpa", "Essi", "Heluna", "Hely",
        "Hento", "Hilke", "Hilsu", "Hymy", "Ihq", "Ilme", "Ilo",
        "Jaana", "Jami", "Jatta", "Laku", "Liekki",
        "Mainikki", "Mella", "Mimmi", "Naatti",
        "Nina", "Nyytti", "Papu", "Pullukka", "Pulu",
        "Rima", "Soma", "Sylkki", "Valpu", "Virpi"};
</pre>

<p>Toteuta luokka Lehma ja testaa sen toimintaa seuraavan ohjelmapätkän avulla.</p>

<pre class="sh_java">
        Lehma lehma = new Lehma();
        System.out.println(lehma);


        Eleleva elelevaLehma = lehma;
        elelevaLehma.eleleTunti();
        elelevaLehma.eleleTunti();
        elelevaLehma.eleleTunti();
        elelevaLehma.eleleTunti();

        System.out.println(lehma);

        Lypsava lypsavaLehma = lehma;
        lypsavaLehma.lypsa();

        System.out.println(lehma);
        System.out.println("");

        lehma = new Lehma("Ammu");
        System.out.println(lehma);
        lehma.eleleTunti();
        lehma.eleleTunti();
        System.out.println(lehma);
        lehma.lypsa();
        System.out.println(lehma);

</pre>

<p>
Ohjelman tulostus on erimerkiksi seuraavanlainen.</p>

</p>

<pre>
Liekki 0.0/23.0
Liekki 7.0/23.0
Liekki 0.0/23.0
Ammu 0.0/35.0
Ammu 9.0/35.0
Ammu 0.0/35.0
</pre>


<h4>Lypsyrobotti</h4>
<p>
Nykyaikaisilla maatiloilla lypsyrobotit hoitavat lypsämisen.
Jotta lypsyrobotti voi lypsää lypsävää otusta, tulee lypsyrobotin
olla kiinnitetty maitosäiliöön:
</p>

  <ul>
    <li><strong>public Lypsyrobotti()</strong> luo uuden lypsyrobotin</li>
    <li><strong>public Maitosailio getMaitosailio()</strong> palauttaa kiinnitetyn maitosäiliö tai <code>null</code>-viitteen, jos säiliötä ei ole vielä kiinnitetty</li>
    <li><strong>public void setMaitosailio(Maitosailio maitosailio)</strong> kiinnittää annetun säiliön lypsyrobottiin</li>
    <li><strong>public void lypsa(Lypsava lypsava)</strong> lypsää lehmän robottiin kiinnitettyyn maitosäiliöön, metodi heittää poikkeuksen <code>IllegalStateException</code>, jos säiliötä ei ole kiinnitetty </li>
  </ul>

<p>Toteuta luokka Lypsyrobotti ja testaa sitä seuraavien ohjelmanpätkien avulla. Varmista että lypsyrobotti voi lypsää kaikkia Lypsava-rajapinnan toteuttavia olioita!</p>

<pre class="sh_java">
        Lypsyrobotti lypsyrobotti = new Lypsyrobotti();
        Lehma lehma = new Lehma();
        lypsyrobotti.lypsa(lehma);
</pre>

<pre>
Exception in thread "main" java.lang.IllegalStateException: Maitosäiliötä ei ole asennettu
        at maatilasimulaattori.Lypsyrobotti.lypsa(Lypsyrobotti.java:17)
        at maatilasimulaattori.Main.main(Main.java:9)
Java Result: 1
</pre>

<pre class="sh_java">
        Lypsyrobotti lypsyrobotti = new Lypsyrobotti();
        Lehma lehma = new Lehma();
        System.out.println("");

        Maitosailio sailio = new Maitosailio();
        lypsyrobotti.setMaitosailio(sailio);
        System.out.println("Säiliö: " + sailio);

        for(int i = 0; i &lt; 2; i++) {
            System.out.println(lehma);
            System.out.println("Elellään..");
            for(int j = 0; j &lt; 5; j++) {
                lehma.eleleTunti();
            }
            System.out.println(lehma);

            System.out.println("Lypsetään...");
            lypsyrobotti.lypsa(lehma);
            System.out.println("Säiliö: " + sailio);
            System.out.println("");
        }
</pre>

<p>Ohjelman tulostus on esimerkiksi seuraavanlainen.</p>

<pre>
Säiliö: 0.0/2000.0
Mella 0.0/23.0
Elellään..
Mella 6.2/23.0
Lypsetään...
Säiliö: 6.2/2000.0

Mella 0.0/23.0
Elellään..
Mella 7.8/23.0
Lypsetään...
Säiliö: 14.0/2000.0
</pre>

<h4>Navetta</h4>

<p>
Lehmät hoidetaan (eli tässä tapauksessa lypsetään) navetassa.
Alkukantaisissa navetoissa on maitosäiliö ja tilaa yhdelle
lypsyrobotille. Huomaa että lypsyrobottia asennettaessa se kytketään
juuri kyseisen navetan maitosäiliöön.  Jos navetassa ei ole
lypsyrobottia, ei siellä voida myöskään hoitaa lehmiä.
Toteuta luokka <code>Navetta</code> jolla on seuraavat konstruktorit ja metodit:
</p>

  <ul>
    <li><strong>public Navetta(Maitosailio maitosailio)</strong></li>
    <li><strong>public Maitosailio getMaitosailio()</strong> palauttaa navetan maitosailion</li>
    <li><strong>public void asennaLypsyrobotti(Lypsyrobotti lypsyrobotti)</strong> asentaa lypsyrobotin ja kiinnittää sen navetan maitosäiliöön</li>
    <li><strong>public void hoida(Lehma lehma)</strong> lypsää parametrina annetun lehmän lypsyrobotin avulla, metodi heittää poikkeuksen <code>IllegalStateException</code>, jos lypsyrobottia ei ole asennettu</li>
    <li><strong>public void hoida(Collection&lt;Lehma&gt; lehmat)</strong> lypsää parametrina annetut lehmät lypsyrobotin avulla, metodi heittää poikkeuksen <code>IllegalStateException</code>, jos lypsyrobottia ei ole asennettu</li>
    <li><strong>public String toString()</strong> palauttaa navetan sisältämän maitosäiliön tilan</li>
  </ul>

<p><code>Collection</code> on Javan oma rajapinta joka kuvaa kokoelmien käyttäytymistä.  Esimerkiksi luokat <code>ArrayList</code> ja <code>LinkedList</code> toteuttavat rajapinnan <code>Collection</code>. Jokaista <code>Collection</code>-rajapinnan toteuttavaa ilmentymää voi myös iteroida for-each-tyyppisesti.</p>

<p>
Testaa luokkaa <code>Navetta</code> seuraavan ohjelmapätkän avulla.
Älä hermoile luokasta <code>LinkedList</code>, se toimii ulkoapäin katsottuna
kuin <code>ArrayList</code>, mutta sen kapseloima toteutus on hieman erilainen.
Tästä lisää tietorakenteet-kurssilla!
</p>

<pre class="sh_java">
        Navetta navetta = new Navetta(new Maitosailio());
        System.out.println("Navetta: " + navetta);

        Lypsyrobotti robo = new Lypsyrobotti();
        navetta.asennaLypsyrobotti(robo);

        Lehma ammu = new Lehma();
        ammu.eleleTunti();
        ammu.eleleTunti();

        navetta.hoida(ammu);
        System.out.println("Navetta: " + navetta);

        LinkedList&lt;Lehma&gt; lehmaLista = new LinkedList();
        lehmaLista.add(ammu);
        lehmaLista.add(new Lehma());

        for(Lehma lehma: lehmaLista) {
            lehma.eleleTunti();
            lehma.eleleTunti();
        }

        navetta.hoida(lehmaLista);
        System.out.println("Navetta: " + navetta);
</pre>

<p>
Tulostuksen tulee olla esimerkiksi seuraavanlainen:
</p>

<pre>
Navetta: 0.0/2000.0
Navetta: 2.8/2000.0
Navetta: 9.6/2000.0
</pre>

<h4>Maatila</h4>

<p>
Maatilalla on omistaja ja siihen kuuluu navetta sekä joukko lehmiä.
Maatila toteuttaa myös aiemmin nähdyn rajapinnan <code>Eleleva</code>,
jonka metodia <code>eleleTunti()</code>-kutsumalla kaikki maatilaan
liittyvät lehmät elelevät tunnin.  Toteuta luokka maatila siten,
että se toimii seuraavien esimerkkiohjelmien mukaisesti.
</p>

<pre class="sh_java">
        Maatila maatila = new Maatila("Esko", new Navetta(new Maitosailio()));
        System.out.println(maatila);

        System.out.println(maatila.getOmistaja() + " on ahkera mies!");
</pre>

<p>
Odotettu tulostus:
</p>

<pre>
Maatilan omistaja: Esko
Navetan maitosäiliö: 0.0/2000.0
Ei lehmiä.
Esko on ahkera mies!
</pre>


<pre class="sh_java">
        Maatila maatila = new Maatila("Esko", new Navetta(new Maitosailio()));
        maatila.lisaaLehma(new Lehma());
        maatila.lisaaLehma(new Lehma());
        maatila.lisaaLehma(new Lehma());
        System.out.println(maatila);
</pre>


<p>
Odotettu tulostus:
</p>

<pre>
Maatilan omistaja: Esko
Navetan maitosäiliö: 0.0/2000.0
Lehmät:
        Naatti 0.0/19.0
        Hilke 0.0/30.0
        Sylkki 0.0/29.0
</pre>

<pre class="sh_java">
        Maatila maatila = new Maatila("Esko", new Navetta(new Maitosailio()));

        maatila.lisaaLehma(new Lehma());
        maatila.lisaaLehma(new Lehma());
        maatila.lisaaLehma(new Lehma());

        maatila.eleleTunti();
        maatila.eleleTunti();

        System.out.println(maatila);
</pre>

<p>
Odotettu tulostus:
</p>

<pre>
Maatilan omistaja: Esko
Navetan maitosäiliö: 0.0/2000.0
Lehmät:
        Heluna 2.0/17.0
        Rima 3.0/32.0
        Ilo 3.0/25.0
</pre>

<pre class="sh_java">
        Maatila maatila = new Maatila("Esko", new Navetta(new Maitosailio()));
        Lypsyrobotti robo = new Lypsyrobotti();
        maatila.asennaNavettaanLypsyrobotti(robo);

        maatila.lisaaLehma(new Lehma());
        maatila.lisaaLehma(new Lehma());
        maatila.lisaaLehma(new Lehma());

        maatila.eleleTunti();
        maatila.eleleTunti();

        maatila.hoidaLehmat();

        System.out.println(maatila);
</pre>

<p>
Odotettu tulostus:
</p>

<pre>
Maatilan omistaja: Esko
Navetan maitosäiliö: 18.0/2000.0
Lehmät:
        Hilke 0.0/30.0
        Sylkki 0.0/35.0
        Hento 0.0/34.0
</pre>
</div>
</div>

<h3>Abstrakti luokka</h3>

        <p>Abstrakti luokka yhdistää rajapintoja ja perintää. Niistä ei voi tehdä ilmentymiä, vaan ilmentymät tehdään tehdään abstraktin luokan aliluokista.  Abstrakti luokka voi sisältää sekä normaaleja metodeja, joissa on metodirunko, että abstrakteja metodeja, jotka sisältävät ainoastaan metodimäärittelyn. Abstraktien metodien toteutus jätetään perivän luokan vastuulle. Yleisesti ajatellen abstrakteja luokkia käytetään esimerkiksi kun abstraktin luokan kuvaama käsite ei ole selkeä itsenäinen käsite. Tällöin siitä ei tule pystyä tekemään ilmentymiä. </p>

        <p>Sekä abstraktin luokan että abstraktien metodien määrittelyssä käytetään avainsanaa <code>abstract</code>. Abstrakti luokka määritellään lauseella <code>public abstract class <em>LuokanNimi</em></code>, abstrakti metodi taas lauseella <code>public abstract <em>palautustyyppi</em> <em>metodinNimi</em></code>. Pohditaan seuraavaa abstraktia luokkaa <code>Toiminto</code>, joka tarjoaa rungon toiminnoille ja niiden suorittamiselle.</p>

<pre class="sh_java">
public abstract class Toiminto {

    private String nimi;

    public Toiminto(String nimi) {
        this.nimi = nimi;
    }

    public String getNimi() {
        return this.nimi;
    }

    public abstract void suorita(Scanner lukija);
}
</pre>

        <p>Abstrakti luokka <code>Toiminto</code> toimii runkona erilaisten toimintojen toteuttamiseen. Esimerkiksi pluslaskun voi toteuttaa perimällä luokka <code>Toiminto</code> seuraavasti.</p>

<pre class="sh_java">
public class Pluslasku extends Toiminto {

    public Pluslasku() {
        super("Pluslasku");
    }

    @Override
    public void suorita(Scanner lukija) {
        System.out.print("Anna ensimmäinen luku: ");
        int eka = Integer.parseInt(lukija.nextLine());
        System.out.print("Anna toinen luku: ");
        int toka = Integer.parseInt(lukija.nextLine());

        System.out.println("Lukujen summa on " + (eka + toka));
    }
}
</pre>

        <p>Koska kaikki <code>Toiminto</code>-luokan perivät luokat ovat myös tyyppiä toiminto, voimme rakentaa käyttöliittymän <code>Toiminto</code>-tyyppisten muuttujien varaan. Seuraava luokka <code>Kayttoliittyma</code> sisaltaa listan toimintoja ja lukijan. Toimintoja voi lisätä käyttöliittymään dynaamisesti.</p>

<pre class="sh_java">
public class Kayttoliittyma {

    private Scanner lukija;
    private List&lt;Toiminto&gt; toiminnot;

    public Kayttoliittyma(Scanner lukija) {
        this.lukija = lukija;
        this.toiminnot = new ArrayList&lt;Toiminto&gt;();
    }

    public void lisaaToiminto(Toiminto toiminto) {
        this.toiminnot.add(toiminto);
    }

    public void kaynnista() {
        while (true) {
            tulostaToiminnot();
            System.out.println("Valinta: ");

            String valinta = this.lukija.nextLine();
            if (valinta.equals("0")) {
                break;
            }

            suoritaToiminto(valinta);
            System.out.println();
        }
    }

    private void tulostaToiminnot() {
        System.out.println("\t0: Lopeta");
        for (int i = 0; i &lt; this.toiminnot.size(); i++) {
            String toiminnonNimi = this.toiminnot.get(i).getNimi();
            System.out.println("\t" + (i + 1) + ": " + toiminnonNimi);
        }
    }

    private void suoritaToiminto(String valinta) {
        int toiminto = Integer.parseInt(valinta);

        Toiminto valittu = this.toiminnot.get(toiminto - 1);
        valittu.suorita(lukija);
    }
}
</pre>

        <p>Käyttöliittymä toimii seuraavasti:</p>

<pre class="sh_java">
        Kayttoliittyma kayttolittyma = new Kayttoliittyma(new Scanner(System.in));
        kayttolittyma.lisaaToiminto(new Pluslasku());

        kayttolittyma.kaynnista();
</pre>

<pre>
Toiminnot:
        0: Lopeta
        1: Pluslasku
Valinta: <font color="red">1</font>
Anna ensimmäinen luku: <font color="red">8</font>
Anna toinen luku: <font color="red">12</font>
Lukujen summa on 20

Toiminnot:
        0: Lopeta
        1: Pluslasku
Valinta: <font color="red">0</font>
</pre>

        <p>Rajapintojen ja abstraktien luokkien ero on siinä, että abstraktit luokat tarjoavat enemmän rakennetta ohjelmaan. Koska abstrakteihin luokkiin voidaan määritellä toiminnallisuutta, voidaan niitä käyttää esimerkiksi oletustoiminnallisuuden määrittelyyn. Yllä käyttöliittymä käytti abstraktissa luokassa määriteltyä toiminnan nimen tallentamista.</p>


<div class="tehtavat">
    <div class="tehtava">
  <h3>Erilaisia laatikoita</h3>

  <p>Tehtäväpohjan mukana tulee luokat <code>Tavara</code> ja <code>Laatikko</code>. Luokka <code>Laatikko</code> on abstrakti luokka, jossa useamman tavaran lisääminen on toteutettu siten, että kutsutaan aina <code>lisaa</code>-metodia. Yhden tavaran lisäämiseen tarkoitettu metodi <code>lisaa</code> on abstrakti, joten jokaisen <code>Laatikko</code>-luokan perivän laatikon tulee toteuttaa se. Tehtävänäsi on muokata luokkaa <code>Tavara</code> ja toteuttaa muutamia erilaisia laatikoita luokan <code>Laatikko</code> pohjalta.</p>

  <p>Lisää kaikki uudet luokat pakkaukseen <code>laatikot</code>.</p>


<pre class="sh_java">
package laatikot;

import java.util.Collection;

public abstract class Laatikko {

    public abstract void lisaa(Tavara tavara);

    public void lisaa(Collection&lt;Tavara&gt; tavarat) {
        for (Tavara tavara : tavarat) {
            lisaa(tavara);
        }
    }

    public abstract boolean onkoLaatikossa(Tavara tavara);
}
</pre>

<h4>Tavaran muokkaus</h4>

  <p>Lisää <code>Tavara</code>-luokan konstruktoriin tarkistus, jossa tarkistetaan että tavaran paino ei ole koskaan negatiivinen (paino 0 hyväksytään). Jos paino on negatiivinen, tulee konstruktorin heittää <code>IllegalArgumentException</code>-poikkeus. Toteuta <code>Tavara</code>-luokalle myös metodit <code>equals</code> ja <code>hashCode</code>, joiden avulla  pääset hyödyntämään erilaisten listojen ja kokoelmien <code>contains</code>-metodia. Toteuta metodit siten, että Tavara-luokan oliomuuttujan <code>paino</code> arvolla ei ole väliä. <em>Voit hyvin hyödyntää NetBeansin tarjoamaa toiminnallisuutta equalsin ja hashCoden toteuttamiseen.</em></p>

<h4>Maksimipainollinen laatikko</h4>

  <p>Toteuta pakkaukseen <code>laatikot</code> luokka <code>MaksimipainollinenLaatikko</code>, joka perii luokan <code>Laatikko</code>. Maksimipainollisella laatikolla on konstruktori <code>public MaksimipainollinenLaatikko(int maksimipaino)</code>, joka määrittelee laatikon maksimipainon. Maksimipainolliseen laatikkoon voi lisätä tavaraa jos ja vain jos tavaran lisääminen ei ylitä laatikon maksimipainoa.</p>

<pre class="sh_java">
        MaksimipainollinenLaatikko kahviLaatikko = new MaksimipainollinenLaatikko(10);
        kahviLaatikko.lisaa(new Tavara("Saludo", 5));
        kahviLaatikko.lisaa(new Tavara("Pirkka", 5));
        kahviLaatikko.lisaa(new Tavara("Kopi Luwak", 5));

        System.out.println(kahviLaatikko.onkoLaatikossa(new Tavara("Saludo")));
        System.out.println(kahviLaatikko.onkoLaatikossa(new Tavara("Pirkka")));
        System.out.println(kahviLaatikko.onkoLaatikossa(new Tavara("Kopi Luwak")));
</pre>

<pre>
true
true
false
</pre>

<h4>Yhden tavaran laatikko ja Hukkaava laatikko</h4>

        <p>Toteuta seuraavaksi pakkaukseen <code>laatikot</code> luokka <code>YhdenTavaranLaatikko</code>, joka perii luokan <code>Laatikko</code>. Yhden tavaran laatikolla on konstruktori <code>public YhdenTavaranLaatikko()</code>, ja siihen mahtuu tasan yksi tavara. Jos tavara on jo laatikossa sitä ei tule vaihtaa. Laatikkoon lisättävän tavaran painolla ei ole väliä.</p>

<pre class="sh_java">
        YhdenTavaranLaatikko laatikko = new YhdenTavaranLaatikko();
        laatikko.lisaa(new Tavara("Saludo", 5));
        laatikko.lisaa(new Tavara("Pirkka", 5));

        System.out.println(laatikko.onkoLaatikossa(new Tavara("Saludo")));
        System.out.println(laatikko.onkoLaatikossa(new Tavara("Pirkka")));
</pre>

<pre>
true
false
</pre>


        <p>Toteuta seuraavaksi pakkaukseen <code>laatikot</code> luokka <code>HukkaavaLaatikko</code>, joka perii luokan <code>Laatikko</code>. Hukkaavalla laatikolla on konstruktori <code>public HukkaavaLaatikko()</code>. Hukkaavaan laatikkoon voi lisätä kaikki tavarat, mutta tavaroita ei löydy niitä etsittäessä. Laatikkoon lisäämisen tulee siis aina onnistua, mutta metodin <code>onkoLaatikossa</code> kutsumisen tulee aina palauttaa false.</p>

<pre class="sh_java">
        HukkaavaLaatikko laatikko = new HukkaavaLaatikko();
        laatikko.lisaa(new Tavara("Saludo", 5));
        laatikko.lisaa(new Tavara("Pirkka", 5));

        System.out.println(laatikko.onkoLaatikossa(new Tavara("Saludo")));
        System.out.println(laatikko.onkoLaatikossa(new Tavara("Pirkka")));
</pre>

<pre>
false
false
</pre>


</div>
</div>

<h3>Huomio olioiden poistamisesta ArrayListista</h3>

<p>Seuraavassa tehtävässä saatat joutua tilanteeseen, jossa haluat poistaa ArrayListiä läpikäydessäsi osan listan olioista:</p>

<pre class="sh_java">
   // joissain määritelty seuraavasti:
   // ArrayList&lt;Olio&gt; lista = new ...

   for ( Olio olio : lista ) {
      if ( tarvitseePoistaa(olio) ) {
         lista.remove(olio);
      }
   }
</pre>

<p>Ratkaisu ei toimi ja aiheuttaa poikkeuksen <code>ConcurrentModificationException</code>, sillä listaa <em>foreach</em>-tyylillä läpikäydessä listaa ei saa muokata. Palaamme aiheeseen hieman tarkemmin viikolla <span class="ahy">6</span><span class="amooc">12</span>. Jos törmäät tilanteeseen, voit hoitaa sen esim. seuraavasti:</p>

<pre class="sh_java">
   // joissain määritelty seuraavasti:
   // ArrayList&lt;Olio&gt; lista = new ...

   ArrayList&lt;Olio&gt; poistettavat = new ArrayList&lt;Olio&gt;();

   for ( Olio olio : lista ) {
      if ( tarvitseePoistaa(olio) ) {
         poistattavat.add(olio);
      }
   }

   lista.removeAll(poistettavat);
</pre>

<p>Eli poistettavat oliot kerätään listan läpikäyntinä erilliselle listalle ja poisto-operaatio suoritetaan vasta listan läpikäynnin jälkeen.</p>

<div class="tehtavat">
    <p class="mooc-pakollinen"></p>
<div class="tehtava pakollinen-hakuun">

<h3>Luola</h3>


  <p><em>Tämä tehtävä on neljän tehtäväpisteen arvoinen.</em> Huom! Toteuta kaikki toiminnallisuus pakkaukseen <code>luola</code>.</p>

<p><b>Huom: jotta testit toimisivat, ohjelmasi saa luoda vain yhden Scanner-olion. Älä käytä luokkien nimissä skandeja. Älä myöskään käytä staattisia muuttujia, testit suorittavat ohjelman useita kertoja joten staattisiin muuttujiin edellisillä suorituskerroilla jääneet arvot todennäköisesti häiritsevät testien toimintaa!</b></p>


<p>Tässä tehtävässä pääset toteuttamaan luolapelin. Pelissä pelaaja on luolassa hirviöitten kanssa. Pelaajan tehtävänä on ehtiä tallata kaikki hirviöt ennen kuin hänen lampustaan loppuu virta ja hirviöt pääsevät pimeän turvin syömään hänet. Pelaaja voi nähdä hirviöiden sijainnit välkäyttämällä lamppua, jonka jälkeen hänen on liikuttava sokkona ennen seuraavaa välkäytystä. Pelaaja voi kulkea monta askelta yhden siirron aikana.</p>

<p>Pelitilanne eli luola, pelaaja ja hirviöt esitetään pelaajalle tekstimuotoisesti. Tulostuksen ensimmäinen rivi kertoo jäljellä olevien siirtojen (eli lampun jäljellä olevan virran) määrän. Virran määrää seuraa pelaajan ja hirviöitten sijainnit, joiden jälkeen on pelitilanteesta piirretty kartta. Alla olevassa esimerkissä näet pelaajan (<code>@</code>) ja kolme hirviötä (<code>h</code>).  Alla olevassa esimerkissä pelaajalla on virtaa neljääntoista siirtoon.</p>

<pre>
14

@ 1 2
h 6 1
h 7 3
h 12 2

.................
......h..........
.@.........h.....
.......h.........
</pre>

<p>Yllä olevassa esimerkissä virtaa on 14 välkäytykseen. Pelaaja <code>@</code> sijatsee koordinaatissa <code>1 2</code>. Huomaa että koordinaatit lasketaan aina pelialueen vasemmasta ylälaidasta lähtien. Alla olevassa kartassa merkki <code>X</code> on koordinaatissa <code>0 0</code>, <code>Y</code> koordinaatissa <code>2 0</code> ja <code>Z</code> koordinaatissa <code>0 2</code>.</p>

<pre>
X.Y..............
.................
Z................
.................
</pre>



<p>Käyttäjä voi liikkua antamalla sarjan komentoja ja painamalla rivinvaihtoa. Komennot ovat:</p>
<ul>
  <li><code>w</code> liiku ylöspäin</li>
  <li><code>s</code> liiku alaspäin</li>
  <li><code>a</code> liiku vasemmalle</li>
  <li><code>d</code> liiku oikealle</li>
</ul>

<p>Kun käyttäjän antamat komennot on suoritettu (niitä voi olla useampi), piirretään uusi pelitilanne. Lampun virta vähenee yhdellä aina kun uusi pelitilanne piirretään. Jos virta menee nollaan, peli loppuu ja ruudulle tulostetaan teksti <code>HÄVISIT</code></p>

<p>Hirviöt liikkuvat pelissä satunnaisesti, yhden askeleen jokaista pelaajan askelta kohti. Jos pelaaja ja hirviö osuvat samaan ruutuun (vaikka vain tilapäisesti), hirviö tuhoutuu. Jos hirviö yrittää siirtyä pelilaudalta ulos tai ruutuun jossa on jo hirviö, jätetään siirto suorittamatta. Kun kaikki hirviöt on tuhottu, peli loppuu ja tulostetaan <code>VOITIT</code>.</p>

<p>Testaamisen helpottamiseksi tee peliisi luokka <code>Luola</code>, jolla on  :</p>

<p>
  <ul>
    <li>konstruktori <strong><code>public Luola(int leveys, int korkeus, int hirvioita, int siirtoja, boolean hirviotLiikkuvat)</code></strong>
      <p>Luvut <code>leveys</code> ja <code>korkeus</code> antavat luolan koon (se on aina neliskulmainen), <code>hirvioita</code> antaa hirviöiden lukumäärän alussa (hirviöiden sijainnin voi arpoa), <code>siirtoja</code> antaa siirtojen lukumäärän alussa ja jos <code>hirviotLiikkuvat</code> on <code>false</code>, hirviöt eivät liiku.</p></li>
    <li>metodi <strong><code>public void run()</code></strong> joka käynnistää pelin</li>
  </ul>
</p>

<p><em>Huom!</em> pelaajan tulee aloittaa sijainnista 0,0!</p>
<p><em>Huom!</em> jos pelaaja tai hirviö koittaa liikkua ulos luolasta
  tai kaksi hirviötä koittaa liikkua samaan ruutuun, ei liikettä tule
  tapahtua!</p>
</ul>

  <p>Alla vielä selkeyden vuoksi vielä esimerkkipeli:</p>

<pre>
14

@ 0 0
h 1 2
h 7 8
h 7 5
h 8 0
h 2 9

@.......h.
..........
.h........
..........
..........
.......h..
..........
..........
.......h..
..h.......

<font color="red">ssd</font>
13

@ 1 2
h 8 8
h 7 4
h 8 3
h 1 8

..........
..........
.@........
........h.
.......h..
..........
..........
..........
.h......h.
..........

<font color="red">ssss</font>
12

@ 1 6
h 6 9
h 6 5
h 8 3

..........
..........
..........
........h.
..........
......h...
.@........
..........
..........
......h...

<font color="red">dd</font>
11

@ 3 6
h 5 9
h 6 7
h 8 1

..........
........h.
..........
..........
..........
..........
...@......
......h...
..........
.....h....

<font color="red">ddds</font>
10

@ 6 7
h 6 6
h 5 0

.....h....
..........
..........
..........
..........
..........
......h...
......@...
..........
..........

<font color="red">w</font>
9

@ 6 6
h 4 0

....h.....
..........
..........
..........
..........
..........
......@...
..........
..........
..........

<font color="red">www</font>
8

@ 6 3
h 4 0

....h.....
..........
..........
......@...
..........
..........
..........
..........
..........
..........

<font color="red">aa</font>
7

@ 4 3
h 4 2

..........
..........
....h.....
....@.....
..........
..........
..........
..........
..........
..........

<font color="red">w</font>
VOITIT
</pre>


</div>
</div>
</div>
</section>

<section class="viikkoraja" id="5" >
  <div class="viikkoraja"></div>
  <div class="viikkoraja-mooc" id="Viikko 11" deadline="avautuu kun 85 % viikosta 10 tehty" data-first-chapter-index="50" data-first-exercise-index="141" data-first-week-index="11"  data-first-chapter-index-mooc="50" data-first-exercise-index-mooc="141" data-first-week-index-mooc="11" tekija="Arto Vihavainen, Matti Luukkainen">

<h2 id="tiedostostoon_kirjoitus">Tiedostoon kirjoittaminen</h3>

<p>Luvussa <span class="ahy">15</span><span class="amooc">49</span> opimme, että tekstitiedostojen lukeminen onnistuu <code>Scanner</code>- ja <code>File</code>-luokkien avulla.
Luokka <code><a href="http://docs.oracle.com/javase/6/docs/api/java/io/FileWriter.html">FileWriter</a></code> tarjoaa toiminnallisuuden tiedostoon kirjoittamiseen. Luokan <code>FileWriter</code> konstruktorille annetaan parametrina kohdetiedoston sijaintia kuvaava merkkijono.</p>

<pre class="sh_java">
        FileWriter kirjoittaja = new FileWriter("tiedosto.txt");
        kirjoittaja.write("Hei tiedosto!\n"); // rivinvaihto tulee myös kirjoittaa tiedostoon!
        kirjoittaja.write("Lisää tekstiä\n");
        kirjoittaja.write("Ja vielä lisää");
        kirjoittaja.close(); // sulkemiskutsu sulkee tiedoston ja varmistaa että kirjoitettu teksti menee tiedostoon
</pre>

    <p>Esimerkissä kirjoitetaan tiedostoon "tiedosto.txt" merkkijono "Hei tiedosto!", jota seuraa rivinvaihto, ja vielä hieman lisää tekstiä. Huomaa että tiedostoon kirjoitettaessa metodi <code>write</code> ei lisää rivinvaihtoja, vaan ne tulee lisätä itse.</p>

    <p>Sekä <code>FileWriter</code>-luokan konstruktori että <code>write</code>-metodi heittää mahdollisesti poikkeuksen, joka tulee joko käsitellä tai siirtää kutsuvan metodin vastuulle. Metodi, jolle annetaan parametrina kirjoitettavan tiedoston nimi ja kirjoitettava sisältö voisi näyttää seuraavalta.</p>

<pre class="sh_java">
public class Tallentaja {

    public void kirjoitaTiedostoon(String tiedostonNimi, String teksti) throws Exception {
        FileWriter kirjoittaja = new FileWriter(tiedostonNimi);
        kirjoittaja.write(teksti);
        kirjoittaja.close();
    }
}
</pre>

<p>Yllä olevassa <code>kirjoitaTiedostoon</code>-metodissa luodaan ensin <code>FileWriter</code>-olio, joka kirjoittaa parametrina annetussa sijainnissa sijaitsevaan tiedostoon <code>tiedostonNimi</code>. Tämän jälkeen kirjoitetaan tiedostoon <code>write</code>-metodilla. Konstruktorin ja <code>write</code>-metodin mahdollisesti heittämä poikkeus tulee käsitellä joko <code>try-catch</code>-lohkolla tai siirtämällä poikkeuksen käsittelyvastuuta eteenpäin. Metodissa <code>kirjoitaTiedostoon</code> käsittelyvastuu on siirretty eteenpäin.</p>

    <p>Luodaan <code>main</code>-metodi jossa kutsutaan <code>Tallentaja</code>-olion <code>kirjoitaTiedostoon</code>-metodia. Poikkeusta ei ole pakko käsitellä <code>main</code>-metodissakaan, vaan se voi ilmoittaa heittävänsä mahdollisesti poikkeuksen määrittelyllä <code>throws Exception</code>.</p>

<pre class="sh_java">
    public static void main(String[] args) throws Exception {
        Tallentaja tallentaja = new Tallentaja();
        tallentaja.kirjoitaTiedostoon("paivakirja.txt", "Rakas päiväkirja, tänään oli kiva päivä.");
    }
</pre>

    <p>Yllä olevaa metodia kutsuttaessa luodaan tiedosto "paivakirja.txt" johon kirjoitetaan teksti "Rakas päiväkirja, tänään oli kiva päivä.". Jos tiedosto on jo olemassa, pyyhkiytyy vanhan tiedoston sisältö uutta kirjoittaessa. Metodilla <code>append()</code> voidaan lisätä olemassaolevan tiedoston perään tekstiä, jolloin olemassaolevaa  tekstiä ei poisteta. Lisätään <code>Tallentaja</code>-luokalle metodi <code>lisaaTiedostoon()</code>, joka lisää parametrina annetun tekstin tiedoston loppuun.</p>

<pre class="sh_java">
public class Tallentaja {
    public void kirjoitaTiedostoon(String tiedostonNimi, String teksti) throws Exception {
        FileWriter kirjoittaja = new FileWriter(tiedostonNimi);
        kirjoittaja.write(teksti);
        kirjoittaja.close();
    }

    public void lisaaTiedostoon(String tiedostonNimi, String teksti) throws Exception {
        FileWriter kirjoittaja = new FileWriter(tiedostonNimi);
        kirjoittaja.append(teksti);
        kirjoittaja.close();
    }
}
</pre>

    <p>Useimmiten tiedoston perään metodilla <code>append</code> kirjoittamisen sijasta on helpompi kirjoittaa koko tiedosto uudelleen.</p>

<div class="tehtavat">
<div class="tehtava">
<h3>Tiedostonkäsittelijä</h3>

<p>Saat tehtävärungon mukana luokan <code>Tiedostonkasittelija</code> joka sisältää metodirungot tiedoston lukemista ja tiedostoon kirjoittamista varten.</p>

<h4>Tiedoston lukeminen</h4>

<p>Täydennä metodi <code>public ArrayList&lt;String&gt; lue(String tiedosto)</code> sellaiseksi, että se palauttaa parametrina annetun tekstitiedoston sisältämät rivit ArrayList:ina siten, että tiedoston jokainen rivi on omana merkkijononaan listalla.
</p>

<p>Projektissa on testaamista varten kaksi tekstitiedostoa <code>src/koesyote1.txt</code> ja <code>src/koesyote2.txt</code>. Metodia on tarkoitus käyttää seuraavalla tavalla:
</p>

<pre class="sh_java">
    public static void main(String[] args) throws FileNotFoundException, IOException {
        TiedostonKasittelija t = new TiedostonKasittelija();

        for (String rivi : t.lue("src/koesyote1.txt")) {
            System.out.println(rivi);
        }
    }
</pre>

<p>Tulostuksen pitäisi olla</p>

<pre>
eka
toka
</pre>


<h4>Rivin kirjoittaminen tiedostoon</h4>

<p>Täydennä projektipohjan mukana tuleva metodi <code>public void tallenna(String tiedosto, String teksti)</code>  sellaiseksi, että se tallentaa ensimmäisen parametrin määrittelemään tiedostoon toisena parametrina annetun merkkijonon. Jos tiedosto on jo olemassa, kirjoitetaan vanhan version päälle.
</p>


<h4>Rivin kirjoittaminen tiedostoon</h4>

<p>Täydennä projektipohjan mukana tuleva metodi <code>public void tallenna(String tiedosto, ArrayList&lt;String&gt; tekstit)</code> sellaiseksi, että se tallentaa ensimmäisen parametrin määrittelemään tiedostoon toisena parametrina annetun listan siten, että jokainen merkkijono tulee omalle rivilleen.  Jos tiedosto on jo olemassa, kirjoitetaan vanhan version päälle.
</p>
</div>
<div class="tehtava">
    <h3>Muistava kahteen suuntaan kääntävä sanakirja</h3>

    <p>Tässä tehtävässä laajennetaan aiemmin toteutettua sanakirjaa siten, että sanat voidaan lukea tiedostosta ja kirjoittaa tiedostoon. Sanakirjan tulee myös osata kääntää molempiin suuntiin, suomesta vieraaseen kieleen sekä toiseen suuntaan (tehtävässä oletetaan hieman epärealistisesti, että suomen kielessä ja vieraassa kielessä ei ole yhtään samalla tavalla kirjoitettavaa sanaa). Tehtävänäsi on luoda sanakirja luokkaan <code>MuistavaSanakirja</code>. Toteuta luokka pakkaukseen <code>sanakirja</code>.</p>

<h4>Muistiton perustoiminnallisuus</h4>

<p>Tee sanakirjalle parametriton konstruktori sekä metodit:</p>

 <ul>
 <li><code>public void lisaa(String sana, String kaannos)</code></li>lisää sanan sanakirjaan. Jokaisella sanalla on vain yksi käännös ja jos sama sana lisätään uudelleen, ei tapahdu mitään.<br/>

<li><code>public String kaanna(String sana)</code></li> palauttaa käännöksen annetulle sanalle. Jos sanaa ei tunneta, palautetaan null.<br/>
 </ul>

<p>Sanakirjan tulee tässä vaiheessa toimia seuraavasti:</p>

<pre class="sh_java">
MuistavaSanakirja sanakirja = new MuistavaSanakirja();
sanakirja.lisaa("apina", "monkey");
sanakirja.lisaa("banaani", "banana");
sanakirja.lisaa("apina", "apfe");

System.out.println( sanakirja.kaanna("apina") );
System.out.println( sanakirja.kaanna("monkey") );
System.out.println( sanakirja.kaanna("ohjelmointi") );
System.out.println( sanakirja.kaanna("banana") );
</pre>

<p>Tulostuu</p>

<pre>
monkey
apina
null
banaani
</pre>

<p>Kuten tulostuksesta ilmenee, käännöksen lisäämisen jälkeen sanakirja osaa tehdä käännöksen molempiin suuntiin.</p>

<p><b>Huom:</b> metodit <code>lisaa</code> ja <code>kaanna</code> eivät lue tiedostoa tai kirjoita tiedostoon! Myöskään konstruktori ei koske tiedostoon.</p>

<h4>Sanojen poistaminen</h4>

<p>Lisää sanakirjalle metodi <code>public void poista(String sana)</code></li> joka poistaa annetun sanan ja sen käännöksen sanakirjasta.</p>

<p><strong>HUOM: </strong> kannattaa ehkä kerrata luku <em><span class="ahy">49.9</span><span class="amooc"></span>Huomio olioiden poistamisesta ArrayListista</em>.</p>

<p><b>HUOM2:</b> metodi <code>poista</code> ei kirjoita tiedostoon.</p>

<p>Sanakirjan tulee tässä vaiheessa toimia seuraavasti:</p>

<pre class="sh_java">
MuistavaSanakirja sanakirja = new MuistavaSanakirja();
sanakirja.lisaa("apina", "monkey");
sanakirja.lisaa("banaani", "banana");
sanakirja.lisaa("ohjelmointi", "programming");
sanakirja.poista("apina");
sanakirja.poista("banana");

System.out.println( sanakirja.kaanna("apina") );
System.out.println( sanakirja.kaanna("monkey") );
System.out.println( sanakirja.kaanna("banana") );
System.out.println( sanakirja.kaanna("banaani") );
System.out.println( sanakirja.kaanna("ohjelmointi") );
</pre>

<p>Tulostuu</p>

<pre>
null
null
null
null
programming
</pre>

<p>Poisto siis toimii myös molemmin puolin, alkuperäisen sanan tai sen käännöksen poistamalla, poistuu sanakirjasta tieto molempien suuntien käännöksestä. </p>



<h4>Lataaminen tiedostosta</h4>

<p>Tee sanakirjalle konstruktori <code>public MuistavaSanakirja(String tiedosto)</code>  ja metodi <code>public boolean lataa()</code>, joka lataa sanakirjan konstruktorin parametrina annetun nimisestä tiedostosta. Jos tiedoston avaaminen tai lukeminen ei onnistu, palauttaa metodi false ja muuten true. </p>

<p><b>Huom: </b> parameterillinen konstruktori ainoastaan kertoo sanakirjalle käytetävän tiedoston nimen. Konstruktori ei lue tiedostoa, tiedoston lukeminen tapahtuu <em>ainoastaan</em> metodissa <code>lataa</code>.</p>

<p>Sanakirjatiedostossa yksi rivi sisältää sanan ja sen käännöksen merkillä ":" erotettuna. Tehtäväpohjan mukana tuleva testaamiseen tarkoitettu sanakirjatiedosto <code>src/sanat.txt</code> on sisällöltään seuraava: </p>

<pre>
apina:monkey
alla oleva:below
olut:beer
</pre>

<p>Lue sanakirjatiedosto rivi riviltä lukijan metodilla <code>nextLine</code>. Voit pilkkoa rivin String metodilla <code>split</code> seuraavasti:

<pre class="sh_java">
Scanner tiedostonLukija = new ...
while ( tiedostonLukija.hasNextLine() ){
    String rivi = tiedostonLukija.nextLine();
    String[] osat = rivi.split(":");   // pilkotaan rivi :-merkkien kohdalta

    System.out.println( osat[0] );     // ennen :-merkkiä ollut osa rivistä
    System.out.println( osat[1] );     // :-merkin jälkeen ollut osa rivistä
}
</pre>

<p>Sanakirjaa käytetään seuraavasti:</p>

<pre class="sh_java">
MuistavaSanakirja sanakirja = new MuistavaSanakirja("src/sanat.txt");
boolean onnistui = sanakirja.lataa();

if ( onnistui ) {
  System.out.println("sanakirjan lataaminen onnistui");
}

System.out.println( sanakirja.kaanna("apina") );
System.out.println( sanakirja.kaanna("ohjelmointi") );
System.out.println( sanakirja.kaanna("alla oleva") );
</pre>

<p>Tulostuu</p>

<pre>
sanakirjan lataaminen onnistui
monkey
null
below
</pre>


<h4>Tallennus tiedostoon</h4>

    <p>Tee sanakirjalle metodi <code>public boolean tallenna()</code>, jota kutsuttaessa sanakirjan sisältö kirjoitetaan konstruktorin parametrina annetun nimiseen tiedostoon. Jos tallennus ei onnistu, palauttaa metodi false ja muuten true. Sanakirjatiedostot tulee tallentaa ylläesitellyssä muodossa, eli ohjelman on osattava lukea itse kirjoittamiaan tiedostoja.</p>

<p><b>Huom1:</b> mikään muu metodi kuin <code>tallenna</code> ei kirjoita tiedostoon. Jos teit edelliset kohdat oikein, sinun ei tulisi tarvita muuttaa mitään olemassaolevaa koodia.</p>

<p><strong>Huom2:</strong> vaikka sanakirja osaa käännökset molempiin suuntiin, ei sanakirjatiedostoon tule kirjoittaa kuin toinen suunta. Eli jos sanakirja tietää esim. käännöksen <em>tietokone = computer</em>, tulee rivi:</p>

<pre>
tietokone:computer
</pre>

<p>tai rivi</p>

<pre>
computer:tietokone
</pre>

<p>mutta ei molempia!</p>

    <p>Talletus kannattanee hoitaa siten, että koko käännöslista kirjoitetaan uudelleen vanhan tiedoston päälle, eli materiaalissa esiteltyä <code>append</code>-metodia ei kannata käyttää.</p>

<p>Sanakirjan lopullista versiota on tarkoitus käyttää  seuraavasti:</p>

<pre class="sh_java">
MuistavaSanakirja sanakirja = new MuistavaSanakirja("src/sanat.txt");
sanakirja.lataa();

// käytä sanakirjaa

sanakirja.tallenna();
</pre>

<p>Eli käytön aluksi ladataan sanakirja tiedostosta ja lopussa tallennetaan se takaisin tiedostoon jotta sanakirjaan tehdyt muutokset pysyvät voimassa seuraavallekin käynnistyskerralle.</p>
</div>
</div>


<h2 id="kalit">Käyttöliittymät</h2>

<p><hr/></p>
<p><big><strong><strong>Huom!</strong> Osa käyttöliittymätehtävien testeistä avaa käyttöliittymän ja käyttää hiirtäsi käyttöliittymäkomponenttien klikkailuun. Kun suoritat käyttöliittymätehtävien testejä, älä käytä hiirtäsi!</strong></big></p>
<p><hr/></p>

<p>Ohjelmamme ovat tähän mennessä koostuneet lähinnä sovelluslogiikasta ja sovelluslogiikkaa käyttävästä tekstikäyttöliittymästä. Muutamissa tehtävissä on ollut myös graafinen käyttöliittymä, mutta ne on yleensä luotu puolestamme. Tutustutaan seuraavaksi graafisten käyttöliittymien luomiseen Javalla.</p>

<p>Käyttöliittymät ovat ikkunoita, jotka sisältävät erilaisia osia kuten nappeja, tekstikenttiä ja valikkoja. Käyttöliittymien ohjelmoinnissa käytetään Javan <a href="http://docs.oracle.com/javase/tutorial/uiswing/components/componentlist.html" target="_blank">Swing</a>-komponenttikirjastoa, joka tarjoaa luokkia käyttöliittymäkomponenttien luomiseen ja käsittelyyn.</p>

<p>Käyttöliittymien peruselementti on luokka <code><a href="http://docs.oracle.com/javase/6/docs/api/javax/swing/JFrame.html" target="_blank">JFrame</a></code>, jonka sisältämään komponenttiosioon käyttöliittymäkomponentit luodaan. Oikeaoppisesti luodut käyttöliittymät toteuttavat rajapinnan <code>Runnable</code>, ja ne käynnistetään pääohjelmasta. Käytämme kurssilla seuraavanlaista käyttöliittymärunkoa:</p>

<pre class="sh_java">
import java.awt.Container;
import java.awt.Dimension;
import javax.swing.JFrame;
import javax.swing.WindowConstants;

public class Kayttoliittyma implements Runnable {

    private JFrame frame;

    public Kayttoliittyma() {
    }

    @Override
    public void run() {
        frame = new JFrame("Otsikko");
        frame.setPreferredSize(new Dimension(200, 100));

        frame.setDefaultCloseOperation(WindowConstants.EXIT_ON_CLOSE);

        luoKomponentit(frame.getContentPane());

        frame.pack();
        frame.setVisible(true);
    }

    private void luoKomponentit(Container container) {
    }

    public JFrame getFrame() {
        return frame;
    }
}
</pre>

<p>Tarkastellaan ylläolevan käyttöliittymäluokan koodia hieman tarkemmin.</p>

<pre class="sh_java">
public class Kayttoliittyma implements Runnable {
</pre>

<p>Luokka <code>Kayttoliittyma</code> toteuttaa Javan rajapinnan <a href="http://docs.oracle.com/javase/6/docs/api/java/lang/Runnable.html" target="_blank">Runnable</a>, joka tarjoaa mahdollisuuden säikeistettyyn ohjelman suorittamiseen. Säikeistetyllä suorittamisella voidaan suorittaa useita ohjelman osia rinnakkain. Emme tutustu säikeisiin tarkemmin, lisää tietoa säikeistä tulee muunmuassa toisen vuoden kurssilla <em>Käyttöjärjestelmät</em>.</p>

<pre class="sh_java">
    private JFrame frame;
</pre>

<p>Käyttöliittymä sisältää oliomuuttujana <code>JFrame</code>-olion, joka on näkyvän käyttöliittymän pohjaelementti. Kaikki käyttöliittymäkomponentit lisätään <code>JFrame</code>-olion sisältämään komponenttialueeseen. Huomaa että <strong>oliomuuttujia ei saa alustaa metodien ulkopuolella</strong>. Esimerkiksi oliomuuttujan <code>JFrame</code> alustus luokkamäärittelyssä <code>"private JFrame frame = new JFrame()"</code> kiertää käyttöliittymäsäikeiden suoritusjärjestyksen, ja voi johtaa ydintuhoon. Tai ohjelmasi kaatumiseen.</p>

<pre class="sh_java">
    @Override
    public void run() {
        frame = new JFrame("Otsikko");
        frame.setPreferredSize(new Dimension(200, 100));

        frame.setDefaultCloseOperation(WindowConstants.EXIT_ON_CLOSE);

        luoKomponentit(frame.getContentPane());

        frame.pack();
        frame.setVisible(true);
    }
</pre>

<p>Rajapinta <code>Runnable</code> määrittelee metodin <code>public void run()</code>, joka jokaisen <code>Runnable</code>-rajapinnan toteuttajan tulee toteuttaa. Metodissa <code>public void run()</code> luodaan ensin uusi JFrame-ikkuna, jonka otsikoksi asetetaan <code>"Otsikko"</code>. Tämän jälkeen asetetaan ikkunan toivotuksi kooksi 200, 100 eli ikkunan leveydeksi tulee 200 pikseliä, korkeudeksi 100 pikseliä. Komento <code>frame.setDefaultCloseOperation(WindowConstants.EXIT_ON_CLOSE);</code> kertoo JFrame-oliolle, että käyttöliittymän käynnistäneen ohjelman suoritus tulee lopettaa, kun käyttäjä painaa käyttöliittymässä olevaa ruksia.</p>

<p>Tämän jälkeen kutsutaan luokassa myöhemmin määriteltyä metodia <code>luoKomponentit</code>. Metodille annetaan parametrina <code>JFrame</code>-olion <em><a href="http://docs.oracle.com/javase/6/docs/api/java/awt/Container.html" target="_blank">Container</a></em>-olio, johon voi lisätä käyttöliittymäkomponentteja.</em>

<p>Lopuksi kutsutaan metodia <code>frame.pack()</code>, joka asettaa JFrame-olion aiemmin määritellyn kokoiseksi ja järjestää JFrame-olion sisältämän Container-olion sisällä olevat käyttöliittymäkomponentit. Lopuksi kutsutaan metodia <code>frame.setVisible(true)</code>, joka näyttää käyttöliittymän käyttäjälle.</p>

<pre class="sh_java">
    private void luoKomponentit(Container container) {
    }
</pre>

<p>Metodissa <code>luoKomponentit</code> lisätään <code>JFrame</code>-olion sisältämään komponenttialueeseen käyttöliittymäkomponentteja. Esimerkissämme ei ole yhtäkään käyttöliittymäkomponenttia JFrame-ikkunan lisäksi. Luokalla <code>Kayttoliittyma</code> on myös sen käyttöä helpottava metodi <code>getFrame</code>, jolla päästään käsiksi luokan kapseloimaan JFrame-olioon.</em>

<p>Swing-käyttöliittymät käynnistetään <code><a href="http://docs.oracle.com/javase/6/docs/api/javax/swing/SwingUtilities.html" target="_blank">SwingUtilities</a></code>-luokan tarjoaman <code>invokeLater</code>-metodin avulla. Metodi <code>invokeLater</code> saa parametrinaan <code>Runnable</code>-rajapinnan toteuttavan olion. Metodi asettaa <code>Runnable</code>-olion suoritusjonoon, ja kutsuu sitä kun ehtii. Luokan <code>SwingUtilities</code> avulla voimme käynnistää uusia säikeitä tarvittaessa.</p>

<pre class="sh_java">
import javax.swing.SwingUtilities;

public class Main {

    public static void main(String[] args) {
        Kayttoliittyma kayttoliittyma = new Kayttoliittyma();
        SwingUtilities.invokeLater(kayttoliittyma);
    }
}
</pre>


<p>Kun ylläoleva pääohjelmametodi suoritetaan, näemme luokassa <code>Kayttoliittyma</code> määrittellyn käyttöliittymän.</p>

    <p><img src="https://www.cs.helsinki.fi/group/java/k13/ohja/img-ohja/kali/eka-kali.png"/></p>


<h3>Käyttöliittymäkomponentit</h3>


<p>Käyttöliittymä koostuu taustaikkunan (JFrame) sisältämästä komponenttipohjasta (Container), ja siihen asetetuista käyttöliittymäkomponenteista. Käyttöliittymäkomponentteja ovat erilaiset painikkeet, tekstit ym. Jokaiselle komponentille on oma luokka. Kannattaa tutustua Oraclen kuvasarjaan erilaisista komponenteista osoitteessa <a href="http://docs.oracle.com/javase/tutorial/uiswing/components/index.html" target="_blank">http://docs.oracle.com/javase/tutorial/uiswing/components/index.html</a>.</p>

<h4>Teksti</h4>

<p>Tekstin näyttäminen tapahtuu <code><a href="http://docs.oracle.com/javase/6/docs/api/javax/swing/JLabel.html" target="_blank">JLabel</a></code>-luokan avulla. Luokka <code>JLabel</code> tarjoaa käyttöliittymäkomponentin, jolle voi asettaa tekstiä ja jonka sisältämää tekstiä voi muokata. Teksti asetetaan joko konstruktorissa tai erillisellä <code>setText</code>-metodilla.</p>

<p>Muokataan käyttöliittymäpohjaamme siten, että siinä näkyy tekstiä. Luodaan uusi JLabel-tekstikomponentti metodissa <code>luoKomponentit</code>. Tämän jälkeen lisätään se <code>JFrame</code>-oliolta saatuun <code>Container</code>-olioon <code>add</code>-metodia käyttäen.</p>

<pre class="sh_java">
    private void luoKomponentit(Container container) {
        JLabel teksti = new JLabel("Tekstikenttä!");
        container.add(teksti);
    }
</pre>

<p>Kuten yllä olevasta lähdekoodista näemme, JLabel-käyttöliittymäkomponentti tulee näyttämään tekstin <code>"Tekstikenttä!"</code>. Kun suoritamme käyttöliittymän, näemme seuraavanlaisen ikkunan.</p>

    <p><img src="https://www.cs.helsinki.fi/group/java/k13/ohja/img-ohja/kali/kali-tekstikentta.png"/></p>


<div class="tehtavat">
<div class="tehtava">
<h3>Tervehtijä</h3>

<p>Toteuta käyttöliittymä, joka näyttää tekstin "Moi!". Käyttöliittymän (eli JFrame-olion) leveyden tulee olla vähintään 400 ja korkeuden vähintään 200 ja otsikkona teksti "Swing on". Tehtävä tulee toteuttaa tehtäväpohjassa tulevaan käyttöliittymärunkoon.  JFrame-olion luominen ja näkyväksi asettamisen tulee tapahtua metodissa <code>run()</code>, tekstikomponentti lisätään käyttöliittymälle metodissa <code>luoKomponentit(Container container)</code>.</p>

<p><strong>HUOM: Käyttöliittymien oliomuuttujia saa alustaa vain metodeissa tai konstruktorissa! Älä alusta oliomuuttujia suoraan määrittelyn yhteydessä.</strong></p>
</div>
</div>
<h4>Painikkeet</h4>

<p>Käyttöliittymään saa painikkeita <code>JButton</code>-luokan avulla. JButton-olion lisääminen käyttöliittymään tapahtuu aivan kuin JLabel-olion lisääminen.</p>

<pre class="sh_java">
    private void luoKomponentit(Container container) {
        JButton nappi = new JButton("Click!");
        container.add(nappi);
    }
</pre>

    <p><img src="https://www.cs.helsinki.fi/group/java/k13/ohja/img-ohja/kali/kali-nappi.png"/></p>

<p>Yritetään seuraavaksi lisätä käyttöliittymään sekä tekstiä, että nappi.</p>

<pre class="sh_java">
    private void luoKomponentit(Container container) {
        JButton nappi = new JButton("Click!");
        container.add(nappi);
        JLabel teksti = new JLabel("Tekstiä.");
        container.add(teksti);
    }
</pre>

<p>Ohjelmaa suorittaessa näemme seuraavanlaisen käyttöliittymän.</p>

    <p><img src="https://www.cs.helsinki.fi/group/java/k13/ohja/img-ohja/kali/kali-tarve-asettelulle.png"/></p>

<p>Vain viimeiseksi lisätty käyttöliittymäkomponentti on näkyvillä, eikä ohjelma toimi toivotusti. Mistä tässä oikein on kyse?</p>

<h3>Käyttöliittymäkomponenttien asettelu</h3>

<p>Jokaisella käyttöliittymäkomponentilla on oma sijainti käyttöliittymässä. Komponentin sijainnin määrää käytössä oleva käyttöliittymän asettelija (<em>Layout Manager</em>). Yrittäessämme aiemmin lisätä useampia käyttöliittymäkomponentteja <code>Container</code>-olioon käyttöliittymässä oli vain yksi komponentti näkyvillä. Jokaisessa <code>Container</code>-oliossa on oletuksena käyttöliittymäasettelija <code><a href="http://docs.oracle.com/javase/6/docs/api/java/awt/BorderLayout.html" target="_blank">BorderLayout</a></code>.</p>

<p>BorderLayout asettelee käyttöliittymäkomponentit viiteen alueeseen: käyttöliittymän keskikohdan lisäksi käytössä ovat ilmansuunnat. Voimme antaa Container-olion <code>add</code>-metodille ylimääräisenä parametrina lisätoiveen kohdasta, johon haluamme asettaa käyttöliittymäkomponentin. BorderLayout-luokassa on käytössä luokkamuuttujat <code>BorderLayout.NORTH</code>, <code>BorderLayout.EAST</code>, <code>BorderLayout.SOUTH</code>, <code>BorderLayout.WEST</code>, ja <code>BorderLayout.CENTER</code>.</p>

<p>Käytettävä käyttöliittymäasettelija asetetaan <code>Container</code>-oliolle metodin <code>setLayout</code>-parametrina. Metodille <code>add</code> voidaan antaa käyttöliittymäkomponentin lisäksi paikka, johon komponentti lisätään. Alla on esimerkki, jossa jokaiseen BorderLayoutin tarjoamaan paikkaan asetetaan käyttöliittymäkomponentti.</p>

<pre class="sh_java">
    private void luoKomponentit(Container container) {
        // seuraava rivi siis ei tässä tilanteessa pakollinen, sillä BorderLayout on JFramessa joka tapauksessa oletuksena
        container.setLayout(new BorderLayout());

        container.add(new JButton("Pohjoinen (North)"), BorderLayout.NORTH);
        container.add(new JButton("Itä (East)"), BorderLayout.EAST);
        container.add(new JButton("Etelä (South)"), BorderLayout.SOUTH);
        container.add(new JButton("Länsi (West)"), BorderLayout.WEST);
        container.add(new JButton("Keski (Center)"), BorderLayout.CENTER);

        container.add(new JButton("Oletuspaikka (Center)"));
    }
</pre>

 <p>Huomaa, että nappi <code>"Keski (Center)"</code> ei tule näkymään käyttöliittymässä, sillä nappi <code>"Oletuspaikka (Center)"</code> asetetaan oletuksena sen paikalle. Käyttöliittymässäpohjassa yllä oleva koodi näyttää seuraavalta.</p>

    <p><img src="https://www.cs.helsinki.fi/group/java/k13/ohja/img-ohja/kali/layout-borderlayout.png"/></p>

<p>Kuten käyttöliittymäkomponentteja, myös käyttöliittymän asettelijoita on useita. Oraclella on käyttöliittymäasettelijoihin visuaalinen opas osoitteessa <a href="http://docs.oracle.com/javase/tutorial/uiswing/layout/visual.html" target="_blank">http://docs.oracle.com/javase/tutorial/uiswing/layout/visual.html</a>. Tutustutaan seuraavaksi käyttöliittymäasettelijaan <code><a href="http://docs.oracle.com/javase/6/docs/api/javax/swing/BoxLayout.html" target="_blank">BoxLayout</a></code>.</a>

<h4>BoxLayout</h4>

<p>BoxLayoutia käytettäessä käyttöliittymäkomponentit asetetaan käyttöliittymään joko vaakasuunnassa tai pystysuunnassa. BoxLayoutin konstruktorille annetaan parametrina Container-olio, johon käyttöliittymäkomponentteja ollaan asettamassa, ja käyttöliittymäkomponenttien asettelusuunta. Asettelusuunta on joko <code>BoxLayout.X_AXIS</code>, eli komponentit vaakasuunnassa, tai <code>BoxLayout.Y_AXIS</code>, eli komponentit pystysuunnassa. Toisin kuin BorderLayout-asettelijaa käytettäessä, BoxLayoutilla ei ole rajattua määrää paikkoja. Container-olioon voi siis lisätä niin monta käyttöliittymäkomponenttia kuin haluaa.</p>

<p>Käyttöliittymän asettelu <code>BoxLayout</code>-asettelijaa käyttäen toimii kuten <code>BorderLayout</code>-asettelijan käyttö. Luomme ensin asettelijan, jonka asetamme <code>Container</code>-oliolle sen metodilla <code>setLayout</code>. Tämän jälkeen voimme lisätä käyttöliittymäkomponentteja <code>Container</code>-olion <code>add</code>-metodilla. Emme tarvitse erillistä sijaintia ilmaisevaa parametria. Alla esimerkki vaakasuunnassa asetetuista käyttöliittymäkomponenteista.</p>

<pre class="sh_java">
    private void luoKomponentit(Container container) {
        BoxLayout layout = new BoxLayout(container, BoxLayout.X_AXIS);
        container.setLayout(layout);

        container.add(new JLabel("Eka!"));
        container.add(new JLabel("Toka!"));
        container.add(new JLabel("Kolmas!"));
    }
</pre>

<p><img src="https://www.cs.helsinki.fi/group/java/k13/ohja/img-ohja/kali/boxlayout-x_axis.png"/></p>

<p>Käyttöliittymäkomponenttien asettelu pystysuunnassa ei vaadi suurta muutosta. Vaihdamme <code>BoxLayout</code>-olion konstruktorille annettavaksi suuntaparametriksi <code>BoxLayout.Y_AXIS</code>.</p>

<pre class="sh_java">
    private void luoKomponentit(Container container) {
        BoxLayout layout = new BoxLayout(container, BoxLayout.Y_AXIS);
        container.setLayout(layout);

        container.add(new JLabel("Eka!"));
        container.add(new JLabel("Toka!"));
        container.add(new JLabel("Kolmas!"));
    }
</pre>

    <p><img src="https://www.cs.helsinki.fi/group/java/k13/ohja/img-ohja/kali/boxlayout-y_axis.png"/></p>

<p>Käyttöliittymäasettelijoita käyttämällä voimme luoda käyttöliittymiä, joissa käyttöliittymäkomponentit ovat aseteltu sopivasti. Alla on esimerkkikäyttöliittymä, jossa komponentit asetetaan pystysuuntaan. Ensin teksti, ja sitten vaihtoehtoinen valinta. Vaihtoehtoisen valinnan, eli valinnan jossa vain yksi vaihtoehto on aina voimassa, voi tehdä käyttämällä <code><a href="http://docs.oracle.com/javase/6/docs/api/javax/swing/ButtonGroup.html" target="_blank">ButtonGroup</a></code>-ryhmittelijää ja <code><a href="http://docs.oracle.com/javase/6/docs/api/javax/swing/JRadioButton.html" target="_blank">JRadioButton</a></code>-painikkeita.</p>

<pre class="sh_java">
    private void luoKomponentit(Container container) {
        BoxLayout layout = new BoxLayout(container, BoxLayout.Y_AXIS);
        container.setLayout(layout);

        container.add(new JLabel("Valitse ruokavalio:"));

        JRadioButton liha = new JRadioButton("Liha");
        JRadioButton kala = new JRadioButton("Kala");

        ButtonGroup buttonGroup = new ButtonGroup();
        buttonGroup.add(liha);
        buttonGroup.add(kala);

        container.add(liha);
        container.add(kala);
    }
</pre>


    <p><img src="https://www.cs.helsinki.fi/group/java/k13/ohja/img-ohja/kali/buttongroup-ruokavalio.png"/></p>

<div class="tehtavat">
    <div class="tehtava">

<h3>Kysely</h3>

<p>Toteuta tehtäväpohjaan käyttöliittymä, joka näyttää seuraavalta:</p>

<p><img src="https://www.cs.helsinki.fi/group/java/k13/ohja/img-ohja/kali/157-kysely.png"/></p>

<p>Käytä käyttöliittymän asettelijana luokkaa <code>BoxLayout</code>, komponentteina luokkia <code>JLabel</code>, <code>JRadioButton</code>, <code>JCheckBox</code> ja <code>JButton</code>.</p>

<p>Käytä <code>ButtonGroup</code>-luokkaa varmistamaan että vaihtoehdot "Siksi" ja "Koska se on kivaa" eivät voi olla valittuina samaan aikaan.</p>

<p>Varmista että käyttöliittymä on niin iso, että käyttäjä voi klikata nappeja muuttamatta sen kokoa. Voit käyttää esimerkiksi leveytenä 200 pikseliä, korkeutena 300 pikseliä.</p>
</div>
</div>

<h3>Tapahtumien käsittely</h3>

<p>Tähänastiset graafiset käyttöliittymämme ovat, vaikkakin hienoja, hieman tylsiä: ne eivät reagoi millään tavalla käyttöliittymässä tehtyihin tapahtumiin. Reagoimattomuus ei johdu käyttöliittymäkomponenteista, vaan siitä että emme ole lisänneet käyttöliittymäkomponentteihin tapahtumia käsitteleviä kuuntelijoita.</p>

<p>Tapahtumankuuntelijat <em>kuuntelevat</em> käyttöliittymäkomponentteja joihin ne on liitetty. Aina kun käyttöliittymäkomponentille tehdään joku toiminto, esimerkiksi napille napin painaminen, käyttöliittymäkomponentti kutsuu jokaisen siihen liitetyn tapahtumakuuntelijan tiettyä metodia. Käytännössä tapahtumankuuntelijat ovat tietyn rajapinnan toteuttavia luokkia, joiden ilmentymiä käyttöliittymäkomponentille voi lisätä. Tapahtuman tapahtuessa käyttöliittymäkomponentti käy jokaisen siihen liitetyn tapahtumankuuntelijan läpi, ja kutsuu rajapinnassa määriteltyä metodia.</p>

<p>Swing-käyttöliittymissä eniten käytetty tapahtumankuuntelurajapinta on <code><a href="http://docs.oracle.com/javase/6/docs/api/java/awt/event/ActionListener.html">ActionListener</a></code>. Rajapinta <code>ActionListener</code> määrittelee metodin <code>void actionPerformed(ActionEvent e)</code>, joka saa parametrinaan tapahtumasta kertovan <code><a href="http://docs.oracle.com/javase/6/docs/api/java/awt/event/ActionEvent.html" target="_blank">ActionEvent</a></code>-olion.</p>

<p>Toteutetaan ensimmäinen oma tapahtumankuuntelija, jonka tarkoituksena on vain tulostaa viesti standarditulostusvirtaan nappia painettaessa. Luokka <code>ViestiKuuntelija</code> toteuttaa rajapinnan <code>ActionListener</code> ja tulostaa viestin <code>"Viesti vastaanotettu!"</code> kun metodia <code>actionPerformed</code> kutsutaan.</p>

<pre class="sh_java">
import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;

public class ViestiKuuntelija implements ActionListener {

    @Override
    public void actionPerformed(ActionEvent ae) {
        System.out.println("Viesti vastaanotettu!");
    }
}
</pre>

<p>Luodaan seuraavaksi käyttöliittymään <code>JButton</code>-tyyppinen nappi, ja lisätään siihen <code>ViestiKuuntelija</code>-luokan ilmentymä. Luokalle <code>JButton</code> voi lisätä tapahtumankuuntelijan käyttämällä sen yläluokassa <code>AbstractButton</code> määriteltyä metodia <code>public void addActionListener(ActionListener actionListener)</code>.</p>

<pre class="sh_java">
    private void luoKomponentit(Container container) {
        JButton nappi = new JButton("Viestitä!");
        nappi.addActionListener(new ViestiKuuntelija());

        container.add(nappi);
    }
</pre>

<p><img src="https://www.cs.helsinki.fi/group/java/k13/ohja/img-ohja/kali/kali-actionlistener-viestita.png"/></p>

<p>Käyttöliittymässä olevaa nappia painettaessa näemme standarditulostusvirrassa seuraavan viestin.</p>

<pre>
Viesti vastaanotettu!
</pre>

<h4>Olioiden käsittely tapahtumankuuntelijoissa</h4>

<p>Haluamme usein että tapahtumankuuntelija muokkaa jonkun olion tilaa. Päästäksemme olioon käsiksi tapahtumankuuntelijassa, tulee meidän antaa viite käsiteltävään olioon tapahtumankuuntelijalle sen konstruktorissa. Tapahtumankuuntelijat ovat täysin samanlaisia luokkia kuin muutkin Javan luokat, eli pääsemme ohjelmoimaan kaiken haluamamme toiminnallisuuden.</p>

<p>Pohditaan seuraavaa käyttöliittymää jossa on kaksi <code><a href="http://docs.oracle.com/javase/6/docs/api/javax/swing/JTextArea.html" target="_blank">JTextArea</a></code>-tyyppistä tekstikenttää, eli tekstikenttää johon käyttäjä voi syöttää tekstiä, ja <code>JButton</code>-tyyppinen nappi. Käyttöliittymä käyttää <code><a href="http://docs.oracle.com/javase/6/docs/api/java/awt/GridLayout.html" target="_blank">GridLayout</a></code>-asettelijaa, jonka avulla käyttöliittymän voi rakentaa taulukkomaiseksi. GridLayout-luokan konstruktorille määriteltiin yksi rivi ja kolme saraketta.</p>

<pre class="sh_java">
    private void luoKomponentit(Container container) {
        GridLayout layout = new GridLayout(1, 3);
        container.setLayout(layout);

        JTextArea textAreaVasen = new JTextArea("Le Kopioija");
        JTextArea textAreaOikea = new JTextArea();
        JButton kopioiNappi = new JButton("Kopioi!");

        container.add(textAreaVasen);
        container.add(kopioiNappi);
        container.add(textAreaOikea);
    }
</pre>

    <p><img src="https://www.cs.helsinki.fi/group/java/k13/ohja/img-ohja/kali/kopioija-alku.png"/></p>

<p>Haluamme lisätä käyttöliittymään toiminnallisuuden, jossa <code>JButton</code>-nappia painettaessa vasemman tekstikentän sisältö kopioituu oikeaan tekstikenttään. Tämä onnistuu toteuttamalla tapahtumankuuntelija. Luodaan rajapinnan <code>ActionListener</code> toteuttava luokka <code>KenttienKopioija</code>, joka kopioi JTextArean sisällön kentästä toiseen. </p>


<pre class="sh_java">
import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;
import javax.swing.JTextArea;

public class KenttienKopioija implements ActionListener {

    private JTextArea lahde;
    private JTextArea kohde;

    public KenttienKopioija(JTextArea lahde, JTextArea kohde) {
        this.lahde = lahde;
        this.kohde = kohde;
    }

    @Override
    public void actionPerformed(ActionEvent ae) {
        this.kohde.setText(this.lahde.getText());
    }
}
</pre>

<p>Tapahtumankuuntelijan rekisteröinti <code>JButton</code>-oliolle onnistuu metodilla <code>addActionListener</code>.</p>

<pre class="sh_java">
    private void luoKomponentit(Container container) {
        GridLayout layout = new GridLayout(1, 3);
        container.setLayout(layout);

        JTextArea textAreaVasen = new JTextArea("Le Kopioija");
        JTextArea textAreaOikea = new JTextArea();
        JButton kopioiNappi = new JButton("Kopioi!");

        KenttienKopioija kopioija = new KenttienKopioija(textAreaVasen, textAreaOikea);
        kopioiNappi.addActionListener(kopioija);

        container.add(textAreaVasen);
        container.add(kopioiNappi);
        container.add(textAreaOikea);
    }
</pre>


<p>Nappia painettaessa vasemman tekstikentän sisältö kopioituu oikealla olevaan tekstikenttään.</p>

    <p><img src="https://www.cs.helsinki.fi/group/java/k13/ohja/img-ohja/kali/kopioija-valmis.png"/></p>



<div class="tehtavat">
<div class="tehtava">
<h3>Ilmoitin</h3>

<p>Toteuta tehtäväpohjaan käyttöliittymä, joka näyttää seuraavalta.</p>

    <p><img src="https://www.cs.helsinki.fi/group/java/k13/ohja/img-ohja/kali/158-ilmoitin.png"/></p>

<p>Ohjelman tulee koostua seuraavista pakkauksessa <code>ilmoitin</code> olevista luokista. Luokka <code>Ilmoitin</code> on käyttöliittymäluokka, joka käynnistetään <code>Main</code>-luokasta. Ilmoittimessa on käyttöliittymäkomponentteina <code>JTextField</code>, <code>JButton</code>, ja <code>JLabel</code>. Voit asetella käyttöliittymäkomponentit <code>GridLayout</code>-asettelijan avulla: kutsu <code>new GridLayout(3, 1)</code> luo uuden asettelijan, joka asettelee kolme käyttöliittymäelementtiä pystysuunnassa.</p>

<p>Sovelluksessa tulee olla lisäksi luokka <code>TapahtumanKuuntelija</code>, joka toteuttaa rajapinnan <code>ActionListener</code>. Tapahtumankuuntelija liitetään nappiin ja sen tulee kopioida käyttöliittymässä olevan JTextField-kentän sisältö JLabel-kenttään napin painalluksen yhteydessä ja samalla tyhjentää JTextField asettamalla sen sisällöksi "".</p>

<p>Varmista että käyttöliittymä käynnistyy niin isona että jokaista nappulaa voi klikata.</p>
</div>
</div>
<h3>Sovelluslogiikan ja käyttöliittymälogiikan eriyttäminen</h3>

<p>Sovelluslogiikan (esimerkiksi tallennus- tai lukutoiminnallisuuden) ja käyttöliittymän sekoittaminen samoihin luokkiin on yleisesti ottaen huono asia. Se vaikeuttaa ohjelman testaamista ja muokkaamista huomattavasti, ja tekee koodista myös paljon vaikeammin luettavaa. Single responsibility principlen sanoin "Jokaisella luokalla pitäisi olla vain yksi selkeä vastuu". Sovelluslogiikan erottaminen käyttöliittymälogiikasta onnistuu sopivan rajapintasuunnittelun kautta.  Oletetaan, että käytössämme on rajapinta <code>HenkiloVarasto</code>, ja haluamme toteuttaa käyttöliittymän henkilöiden tallentamiseen.</p>

<pre class="sh_java">
public interface HenkiloVarasto {
    void talleta(Henkilo henkilo);
    Henkilo hae(String henkilotunnus);

    void poista(Henkilo henkilo);
    void poista(String henkilotunnus);
    void poistaKaikki();

    Collection&lt;Henkilo&gt; haeKaikki();
}
</pre>

<h4>Käyttöliittymän toteutus</h4>

<p>Käyttöliittymää toteutettaessa hyvä aloitustapa on sopivien käyttöliittymäkomponenttien lisääminen käyttöliittymään. Henkilöiden tallennuksessa tarvitsemme kentät nimelle ja henkilötunnukselle, sekä napin jolla henkilö voidaan lisätä. Käytetään Javan <code><a href="http://docs.oracle.com/javase/6/docs/api/javax/swing/JTextField.html" target="_blank">JTextField</a></code>-luokkaa tekstin syöttämiseen, ja <code>JButton</code>-luokkaa napin toteuttamiseen. Luodaan käyttöliittymään lisäksi selventävät <code>JLabel</code>-tyyppiset selitystekstit.</p>

<p>Käytetään käyttöliittymän asetteluun <code>GridLayout</code>-asettelijaa. Rivejä käyttöliittymässä on 3, sarakkeita 2. Lisätään tapahtumankuuntelija myöhemmin. Käyttöliittymäluokan metodi <code>luoKomponentit</code> näyttää nyt seuraavalta.</p>

<pre class="sh_java">
    private void luoKomponentit(Container container) {
        GridLayout layout = new GridLayout(3, 2);
        container.setLayout(layout);

        JLabel nimiTeksti = new JLabel("Nimi: ");
        JTextField nimiKentta = new JTextField();
        JLabel hetuTeksti = new JLabel("Hetu: ");
        JTextField hetuKentta = new JTextField();

        JButton lisaaNappi = new JButton("Lisää henkilö!");
        // tapahtumankuuntelija

        container.add(nimiTeksti);
        container.add(nimiKentta);
        container.add(hetuTeksti);
        container.add(hetuKentta);
        container.add(new JLabel(""));
        container.add(lisaaNappi);
    }
</pre>

<p>Käyttöliittymä näyttää seuraavalta kun siihen on lisätty tietoa.</p>

    <p><img src="https://www.cs.helsinki.fi/group/java/k13/ohja/img-ohja/kali/kali-henkilon-lisays.png"/></p>

<p>Tapahtumankuuntelijan tulee tietää tallennustoiminnallisuudesta eli <code>HenkiloVarasto</code>-rajapinnasta sekä kentistä, joita se käyttää. Luodaan <code>ActionListener</code>-rajapinnan toteuttava luokka <code>HenkilonLisaysKuuntelija</code>. Luokka saa konstruktorissaan parametrina <code>HenkiloVarasto</code>-rajapinnan toteuttavan olion sekä kaksi <code>JTextField</code>-oliota, jotka ovat kentät nimelle ja henkilötunnukselle. Metodissa <code>actionPerformed</code> luodaan uusi <code>Henkilo</code>-olio ja tallennetaan se <code>HenkiloVarasto</code>-olion tarjoamalla <code>talleta</code>-metodilla.</p>

<pre class="sh_java">
public class HenkilonLisaysKuuntelija implements ActionListener {

    private HenkiloVarasto henkiloVarasto;
    private JTextField nimiKentta;
    private JTextField hetuKentta;

    public HenkilonLisaysKuuntelija(HenkiloVarasto henkiloVarasto, JTextField nimiKentta, JTextField hetuKentta) {
        this.henkiloVarasto = henkiloVarasto;
        this.nimiKentta = nimiKentta;
        this.hetuKentta = hetuKentta;
    }

    @Override
    public void actionPerformed(ActionEvent ae) {
        Henkilo henkilo = new Henkilo(nimiKentta.getText(), hetuKentta.getText());
        this.henkiloVarasto.talleta(henkilo);
    }
}
</pre>

<p>Jotta saamme <code>HenkiloVarasto</code>-viitteen <code>HenkilonLisaysKuuntelija</code>-oliolle, tulee sen olla käyttöliittymän tiedossa. Lisätään käyttöliittymälle oliomuuttuja <code>private HenkiloVarasto henkiloVarasto</code>, joka asetetaan konstruktorissa. Luokan <code>Kayttoliittyma</code> konstruktoria muokataan siten, että sille annetaan <code>HenkiloVarasto</code>-rajapinnan toteuttava luokka.</p>

<pre class="sh_java">
public class Kayttoliittyma implements Runnable {

    private JFrame frame;
    private HenkiloVarasto henkiloVarasto;

    public Kayttoliittyma(HenkiloVarasto henkiloVarasto) {
        this.henkiloVarasto = henkiloVarasto;
    }
    // ...


</pre>

<p>Voimme nyt luoda tapahtumankuuntelijan <code>HenkilonLisaysKuuntelija</code>, jolle annetaan sekä <code>HenkiloVarasto</code>-viite, että kentät.</p>

<pre class="sh_java">
    private void luoKomponentit(Container container) {
        GridLayout layout = new GridLayout(3, 2);
        container.setLayout(layout);

        JLabel nimiTeksti = new JLabel("Nimi: ");
        JTextField nimiKentta = new JTextField();
        JLabel hetuTeksti = new JLabel("Hetu: ");
        JTextField hetuKentta = new JTextField();

        JButton lisaaNappi = new JButton("Lisää henkilö!");
        HenkilonLisaysKuuntelija kuuntelija = new HenkilonLisaysKuuntelija(henkiloVarasto, nimiKentta, hetuKentta);
        lisaaNappi.addActionListener(kuuntelija);

        container.add(nimiTeksti);
        container.add(nimiKentta);
        container.add(hetuTeksti);
        container.add(hetuKentta);
        container.add(new JLabel(""));
        container.add(lisaaNappi);
    }
</pre>

<div class="tehtavat">
    <div class="tehtava">
<h3>Axe Click Effect</h3>

<p>Tässä tehtävässä toteutetaan laskuri klikkausten laskemiseen. Tehtävässä sovelluslogiikka, eli laskeminen, ja käyttöliittymälogiikka on erotettu toisistaan. Lopullisen sovelluksen tulee näyttää kutakuinkin seuraavalta. </p>

    <p><img src="https://www.cs.helsinki.fi/group/java/k13/ohja/img-ohja/kali/159-clickeffect.png"/></p>

<h4>OmaLaskuri</h4>

<p>Toteuta pakkaukseen <code>clicker.sovelluslogiikka</code> rajapinnan <code>Laskuri</code> toteuttava luokka <code>OmaLaskuri</code>. Luokan <code>OmaLaskuri</code> metodin <code>annaArvo</code> palauttama luku on aluksi 0. Kun metodia <code>kasvata</code> kutsutaan, kasvaa arvo aina yhdellä.</p>

<p>Voit halutessasi testata luokan toimintaa seuraavan ohjelman avulla.</p>

<pre class="sh_java">
        Laskuri laskuri = new OmaLaskuri();
        System.out.println("Arvo: " + laskuri.annaArvo());
        laskuri.kasvata();
        System.out.println("Arvo: " + laskuri.annaArvo());
        laskuri.kasvata();
        System.out.println("Arvo: " + laskuri.annaArvo());
</pre>

<pre>
Arvo: 0
Arvo: 1
Arvo: 2
</pre>

<h4>KlikkaustenKuuntelija</h4>

<p>Toteuta pakkaukseen <code>clicker.kayttoliittyma</code> rajapinnan <code>ActionListener</code> toteuttava luokka <code>KlikkaustenKuuntelija</code>. Luokka <code>KlikkaustenKuuntelija</code> saa konstruktorin parametrina <code>Laskuri</code>-rajapinnan toteuttavan olion ja <code>JLabel</code>-olion.</p>

<p>Toteuta <code>actionPerformed</code>-metodi siten, että <code>Laskuri</code>-oliota kasvatetaan aluksi yhdellä, jonka jälkeen laskurin arvo asetetaan <code>JLabel</code>-olion tekstiksi. <code>JLabel</code>-olion tekstiä voidaan muuttaa metodilla <code>setText</code>.</p>

<h4>Käyttöliittymä</h4>

<p>Muokkaa luokkaa <code>Kayttoliittyma</code> siten, että käyttöliittymä saa konstruktorin parametrina <code>Laskuri</code>-olion. Tarvitset tätä varten uuden konstruktorin. Lisää käyttöliittymään tarvittavat käyttöliittymäkomponentit. Rekisteröi napille myös edellisessä osassa toteutettu tapahtumankuuntelija.</p>

<p>Käytä käyttöliittymäkomponenttien asetteluun <code>BorderLayout</code>-luokan tarjoamia toiminnallisuuksia. Muuta myös <code>Main</code>-luokkaa siten, että käyttöliittymälle annetaan <code>OmaLaskuri</code>-olio. Kun käyttöliittymässä olevaa <code>"Click!"</code>-nappia on painettu kahdesti, sovellus näyttää kutakuinkin seuraavalta.</p>

    <p><img src="https://www.cs.helsinki.fi/group/java/k13/ohja/img-ohja/kali/159-clickeffect-klikattu.png"/></p>

</div>
</div>

<h3>Sisäkkäiset Container-oliot</h3>

<p>Törmäämme silloin tällöin tilanteeseen, jossa <code>JFrame</code>-luokan tarjoama <code>Container</code>-olio ei riitä käyttöliittymän asetteluun. Saatamme tarvita erilaisia käyttöliittymänäkymiä tai mahdollisuutta käyttöliittymäkomponenttien ryhmittelyyn niiden käyttötarkoituksen mukaan. Esimerkiksi alla olevan käyttöliittymän rakentaminen ei olisi kovin helppoa vain <code>JFrame</code>-luokan tarjoamalla <code>Container</code>-oliolla.</p>

   <p><img src="https://www.cs.helsinki.fi/group/java/k13/ohja/img-ohja/kali/jpanel-container.png"/></p>

<p>Voimme asettaa Container-tyyppisiä olioita toistensa sisään. Luokka <code><a href="http://docs.oracle.com/javase/6/docs/api/javax/swing/JPanel.html" target="_blank">JPanel</a></code> (katso myös <a href="http://docs.oracle.com/javase/tutorial/uiswing/components/panel.html" target="_blank">How to Use Panels</a>) mahdollistaa sisäkkäiset <code>Container</code>-oliot. JPanel-luokan ilmentymään voi lisätä käyttöliittymäkomponentteja samalla tavalla kuin <code>JFrame</code>-luokasta saatuun <code>Container</code>-ilmentymään. Tämän lisäksi <code>JPanel</code>-luokan ilmentymän voi lisätä <code>Container</code>-olioon. Tämä mahdollistaa useamman <code>Container</code>-olion käyttämisen käyttöliittymän suunnittelussa.</p>

<p>Yllä olevan käyttöliittymän luominen on helpompaa <code>JPanel</code>-luokan avulla.. Luodaan käyttöliittymä, jossa on kolme nappia "Suorita", "Testaa", ja "Lähetä", sekä tekstialue joka sisältää tekstiä. Napit ovat oma joukkonsa, joten tehdään niille erillinen <code>JPanel</code>-olio joka asetetaan <code>JFrame</code>-luokasta saadun <code>Container</code>-olion eteläosaan. Tekstialue tulee keskelle.</p>

<pre class="sh_java">
    private void luoKomponentit(Container container) {
        container.add(new JTextArea());
        container.add(luoValikko(), BorderLayout.SOUTH);
    }

    private JPanel luoValikko() {
        JPanel panel = new JPanel(new GridLayout(1, 3));
        panel.add(new JButton("Suorita"));
        panel.add(new JButton("Testaa"));
        panel.add(new JButton("Lähetä"));
        return panel;
    }
</pre>

<p>JPanel-luokalle annetaan konstruktorin parametrina käytettävä asettelutyyli. Jos asettelutyyli tarvitsee konstruktorissaan viitteen käytettyyn <code>Container</code>-olioon (kuten <code>BoxLayout</code>), on <code>JPanel</code>-luokalla myös metodi <code>setLayout</code>.</p>

<p>Jos käyttöliittymässämme on selkeät erilliset kokonaisuudet, voimme myös periä <code>JPanel</code> luokan. Esimerkiksi yllä olevan valikon voisi toteuttaa myös seuraavasti.</p>

<pre class="sh_java">
import java.awt.GridLayout;
import javax.swing.JButton;
import javax.swing.JPanel;

public class ValikkoPanel extends JPanel {

    public ValikkoPanel() {
        super(new GridLayout(1, 3));
        luoKomponentit();
    }

    private void luoKomponentit() {
        add(new JButton("Suorita"));
        add(new JButton("Testaa"));
        add(new JButton("Lähetä"));
    }
}
</pre>

<p>Nyt käyttöliittymäluokassa voidaan luoda <code>ValikkoPanel</code>-luokan ilmentymä.</p>

<pre class="sh_java">
    private void luoKomponentit(Container container) {
        container.add(new JTextArea());
        container.add(new ValikkoPanel(), BorderLayout.SOUTH);
    }
</pre>

<p>Huomaa, että tapahtumankäsittelyä tarvittaessa luokalle <code>ValikkoPanel</code> tulee antaa parametrina kaikki tarvittavat oliot.</p>

<div class="tehtavat">
    <div class="tehtava">
<h3>Laskin</h3>

<p>Tehtävässä on tarkoitus toteuttaa yksinkertainen laskin. Laskimen käyttöliittymän tulee olla seuraavanlainen:</p>

   <p><img src="https://www.cs.helsinki.fi/group/java/k13/ohja/img-ohja/laskin.png"/></p>

<p>Tehtäväpohjan mukana tulee käynnistyksen suorittava pääohjelma sekä graafisen käyttöliittymän sisältävä luokka <code>GraafinenLaskin</code>. Käyttöliittymän on oltava täsmälleen seuraavassa osassa kuvaillulla tavalla tehty, muuten saat vapaasti suunnitella ohjelman rakenteen.</p>

<h4>Layout kuntoon</h4>

 <p>Käyttöliittymän pohjana olevassa  <code>JFrame</code>ssa tulee käyttää asettelijana <code>GridLayout</code>ia jossa on kolme riviä ja yksi sarake. Ylimpänä on tuloskenttänä toimiva <code>JTextField</code>, joka täytyy asettaa "pois päältä" metodikutsulla <code>setEnabled(false)</code>. Toisena on syötekenttänä toimiva  <code>JTextField</code>. Tuloskentässä on aluksi teksti 0 ja syötekenttä on tyhjä.</p>

<p>Alimpana komponenttina sijaitsee <code>JPanel</code>, jonka asettelijana on <code>GridLayout</code>, jossa on yksi rivi ja kolme saraketta. JPanelissa on kolme <code>JButton</code>ia, joissa tekstit "+", "-" ja "Z".</p>

<p>Laskimen käyttöliittymän koon on oltava vähintään 300*150.</p>

<h4>Perustoiminnallisuus</h4>

<p>Laskimen toimintalogiikka on seuraava. Käyttäjän kirjoittaessa syötekenttään luvun n ja painaessa <strong>+</strong>, lisätään tuloskentässä olevaan arvoon n ja päivitetään tuloskenttä uuteen arvoon. Vastaavasti käyttäjän kirjoittaessa syötekenttään luvun n ja painaessa <strong>-</strong>, vähennetään tuloskentässä olevasta arvosta n ja päivitetään tuloskenttä uuteen arvoon. Jos käyttäjä painaa <strong>Z</strong>, nollautuu tuloskenttä.</p>

<p><strong>Vihje: </strong> joskus on tarkoituksenmukaista hoitaa yhdellä tapahtumankuuntelijalla usean napin painallusten käsittely. Tämä onnistuu kysymällä <code>actionPerformed</code>-metodin parametrilta kuka oli tapahtuman aiheuttaja. Seuraava koodi olettaa, että tapahtumankäsittelijällä on oliomuuttujat <code>JButton plus</code> ja <code>JButton miinus</code> jotka viittaavat plus- ja miinus-nappeihin:</p>

<pre class="sh_java">
    @Override
    public void actionPerformed(ActionEvent ae) {
        if (ae.getSource() == plus) {
           // käsittele plus-painike
        } else if (ae.getSource() == miinus) {
           // käsittele miinus-painike
        } else ...
</pre>

<h4>Hienosäätö</h4>

<p>Laajennetaan vielä ohjelmaa seuraavilla ominaisuuksilla:</p>
<ul>
<li>Jos tuloskentässä on 0, ei <strong>Z</strong>-nappia voi painaa, eli se tulee olla asetettu "pois päältä" metodikutsulla <code>setEnabled(false)</code>. Muissa tilanteissa napin tulee olla päällä.</li>
<li>Kun käyttäjä painaa jotain napeista <strong>+, -, Z</strong> syötekenttä tyhjenee.</li>
 <li>Jos syötekentässä oleva syöte ei ole kokonaisluku ja käyttäjä painaa jotain napeista<strong>+, -, Z</strong> syötekenttä tyhjenee ja tuloskentän tila ei muutu (paitsi napin ollessa <strong>Z</strong>).</li>
</ul>
</div>
</div>
<h2>Piirtäminen</h2>

<p>Luokkaa <code>JPanel</code> käytetään <code>Container</code>-toiminnallisuuden lisäksi usein piirtoalustana siten, että käyttäjä perii luokan <code>JPanel</code> ja korvaa metodin <code>protected void paintComponent(Graphics graphics)</code>. Käyttöliittymä kutsuu metodia <code>paintComponent</code> aina kun käyttöliittymäkomponentin sisältö halutaan piirtää ruudulle. Metodi <code>paintComponent</code> saa käyttöliittymältä parametrina abstraktin luokan <code><a href="http://docs.oracle.com/javase/6/docs/api/java/awt/Graphics.html" target="_blank">Graphics</a></code> toteuttavan olion. Luodaan luokan <code>JPanel</code> perivä luokka <code>Piirtoalusta</code>, joka korvaa <code>paintComponent</code>-metodin.</p>

<pre class="sh_java">
public class Piirtoalusta extends JPanel {

    public Piirtoalusta() {
        super.setBackground(Color.WHITE);
    }

    @Override
    protected void paintComponent(Graphics graphics) {
        super.paintComponent(graphics);
    }
}
</pre>

<p>Yllä oleva piirtoalusta ei sisällä konkreettista piirtämistoiminnallisuutta. Asetamme konstruktorissa piirtoalustan taustan valkoiseksi kutsumalla yläluokan metodia <code>setBackground</code>. Metodi <code>setBackGround</code> saa parametrina <code><a href="http://docs.oracle.com/javase/6/docs/api/java/awt/Color.html" target="_blank">Color</a></code>-luokan ilmentymän. Luokka <code>Color</code> sisältää yleisimmät värit luokkamuuttujina, esimerkiksi väri valkoinen löytyy luokkamuuttujasta <code>Color.WHITE</code>.</p>

<p><strong>Huom:</strong> metodin paintComponent alussa tulee olla kutsu korvattuun metodiin, eli ensimmäisen rivin tulee olla <code>super.paintComponent(g);</code> muuten piirtäminen ei toimi halutulla tavalla.</p>

<p>Korvattu <code>paintComponent</code> metodi kutsuu yläluokan <code>paintComponent</code>-metodia eikä tee muuta. Lisätään piirtoalusta seuraavaksi käyttöliittymäluokan <code>luoKomponentit</code>-metodiin. Käytämme kappaleen 51. Käyttöliittymät alussa määriteltyä käyttöliittymäpohjaa.</p>

<pre class="sh_java">
    private void luoKomponentit(Container container) {
        container.add(new Piirtoalusta());
    }
</pre>

<p>Käynnistäessämme käyttöliittymän näemme tyhjän ruudun, jonka taustaväri on valkoinen. Alla olevan käyttöliittymän toivotuksi kooksi on asetettu <code>setPreferredSize</code>-metodilla 300, 300, ja sen otsikko on <code>"Piirtoalusta"</code>.</p>

    <p><img src="https://www.cs.helsinki.fi/group/java/k13/ohja/img-ohja/kali/piirtoalusta.png"/></p>

<p>Piirtoalustalle piirtäminen tapahtuu <code><a href="http://docs.oracle.com/javase/6/docs/api/java/awt/Graphics.html" target="_blank">Graphics</a></code>-olion tarjoamien metodien avulla. Muokataan <code>Piirtoalusta</code>-luokan metodia <code>paintComponent</code> siten, että siinä piirretään kaksi suorakulmiota <code>Graphics</code>-olion tarjoaman metodin <code>fillRect</code> avulla.</p>

<pre class="sh_java">
    @Override
    protected void paintComponent(Graphics graphics) {
        super.paintComponent(graphics);

        graphics.fillRect(50, 80, 100, 50);
        graphics.fillRect(200, 20, 50, 200);
    }
</pre>

<p>Metodi <code>fillRect</code> saa parametrina suorakulmion <code>x</code>, ja <code>y</code> -koordinaatit, sekä suorakulmion leveyden ja korkeuden tässä järjestyksessä. Yllä siis piirretään ensin koordinaatista <code>(50, 80)</code> alkava 100 pikseliä leveä ja 50 pikseliä korkea suorakulmio. Tämän jälkeen piirretään koordinaatista <code>(200, 20)</code> alkava 50 pikseliä leveä ja 100 pikseliä korkea suorakulmio.</p>

<p>Kuten piirtotuloksesta huomaat, koordinaatisto ei toimi aivan kuten olemme tottuneet.</p>

    <p><img src="https://www.cs.helsinki.fi/group/java/k13/ohja/img-ohja/kali/piirtoalusta-suorakulmiot.png"/></p>

<p>Javan <code>Graphics</code>-olio (ja useiden muiden ohjelmointikielten käyttöliittymäkirjastot) olettaa että y-akselin arvo kasvaa alaspäin mennessä. Koordinaatiston origo, eli piste <code>(0, 0)</code> on piirrettävän alueen vasemmassa yläkulmassa: Graphics-olio tietää aina käyttöliittymäkomponentin, johon piirretään, ja osaa sen perusteella päätellä piirtotapahtuman sijainnin. Käyttöliittymän origon sijainti selkeytyy seuraavalla ohjelmalla. Piirretään ensin pisteestä (0, 0) lähtevä 10 pikseliä leveä ja 200 pikseliä korkea vihreä suorakulmio. Tämän jälkeen piirretään pisteestä (0, 0) lähtevä 200 pikseliä leveä ja 10 pikseliä korkea musta. Seuraavana piirrettävän kuvion väri määritellään <code>Graphics</code>-oliolle metodilla <code>setColor</code>.</p>


<pre class="sh_java">
    @Override
    protected void paintComponent(Graphics graphics) {
        super.paintComponent(graphics);

        graphics.setColor(Color.GREEN);
        graphics.fillRect(0, 0, 10, 200);
        graphics.setColor(Color.BLACK);
        graphics.fillRect(0, 0, 200, 10);
    }
</pre>

    <p><img src="https://www.cs.helsinki.fi/group/java/k13/ohja/img-ohja/kali/piirtoalusta-koordinaatisto.png"/></p>

<p>Tämä koordinaatiston käänteisyys johtuu siitä, miten käyttöliittymien kokoa muokataan. Käyttöliittymän kokoa muutettaessa sitä pienennetään tai suurennetaan "oikeasta alakulmasta vetäen", jolloin ruudulla näkyvä piirros siirtyy kokoa muuttaessa. Kun koordinaatisto alkaa vasemmasta yläkulmasta, on piirroksen sijainti aina sama, mutta näkyvä osa muuttuu.</p>

<div class="tehtavat">
    <div class="tehtava">

<h3>Piirtoalusta ja Piirtäminen</h3>

<p>Tehtäväpohjassa on valmiina käyttöliittymä, johon on kytketty <code>JPanel</code>-luokan perivä luokka <code>Piirtoalusta</code>. Muuta luokan <code>Piirtoalusta</code> metodin <code>paintComponent</code> toteutusta siten, että se piirtää seuraavanlaisen kuvion. Saat käyttää tehtävässä vain <code>graphics</code>-olion <code>fillRect</code>-metodia.</p>

<p><img src="https://www.cs.helsinki.fi/group/java/k13/ohja/img-ohja/smiley.gif"/></p>

<p>Huom! Älä käytä enempää kuin viittä <code>fillRect</code>-kutsua. Kuvion ei tarvitse olla täsmälleen samanlainen kuin ylläoleva, testit kertovat kun piirtämäsi kuva on tarpeeksi lähellä haluttua kuvaa.</p>

</div>
</div>

<p>Laajennetaan edellistä esimerkkiä siten, että piirrämme käyttöliittymässä erillisen hahmo-olion. Luodaan hahmon edustamiseen luokka <code>Hahmo</code>. Hahmolla on koordinaatteina ilmaistu sijainti, ja se piirretään ympyränä jonka halkaisija on 10 pikseliä. Hahmon sijaintia voi muuttaa kutsumalla sen <code>siirry</code>-metodia.</p>

<pre class="sh_java">
import java.awt.Graphics;

public class Hahmo {

    private int x;
    private int y;

    public Hahmo(int x, int y) {
        this.x = x;
        this.y = y;
    }

    public int getX() {
        return x;
    }

    public int getY() {
        return y;
    }

    public void siirry(int xmuutos, int ymuutos) {
        this.x += xmuutos;
        this.y += ymuutos;
    }

    public void piirra(Graphics graphics) {
        graphics.fillOval(x, y, 10, 10);
    }
}
</pre>

<p>Muutetaan piirtoalustaa siten, että sille annetaan <code>Hahmo</code>-luokan ilmentymä konstruktorin parametrina. Luokan <code>Piirtoalusta</code> metodi <code>paintComponent</code> ei itse piirrä hahmoa, vaan delegoi piirtovastuun <code>Hahmo</code>-luokan ilmentymälle.</p>

<pre class="sh_java">
import java.awt.Color;
import java.awt.Graphics;
import javax.swing.JPanel;

public class Piirtoalusta extends JPanel {

    private Hahmo hahmo;

    public Piirtoalusta(Hahmo hahmo) {
        super.setBackground(Color.WHITE);
        this.hahmo = hahmo;
    }

    @Override
    protected void paintComponent(Graphics graphics) {
        super.paintComponent(graphics);
        hahmo.piirra(graphics);
    }
}
</pre>

<p>Annetaan hahmo myös käyttöliittymälle parametrina. Hahmo on siis käyttöliittymästä erillinen olio, joka vain halutaan piirtää käyttöliittymässä. Oleelliset muutokset käyttöliittymäluokassa ovat siis konstruktorin muuttaminen siten, että se saa parametrina <code>Hahmo</code>-olion. Tämän lisäksi metodissa <code>luoKomponentit</code> annetaan <code>Hahmo</code>-luokan ilmentymä parametrina luotavalle <code>Piirtoalusta</code>-oliolle.</p>

<pre class="sh_java">
public class Kayttoliittyma implements Runnable {

    private JFrame frame;
    private Hahmo hahmo;

    public Kayttoliittyma(Hahmo hahmo) {
        this.hahmo = hahmo;
    }

// ...

    private void luoKomponentit(Container container) {
        Piirtoalusta piirtoalusta = new Piirtoalusta(hahmo);
        container.add(piirtoalusta);
    }
// ...
</pre>

<p>Käyttöliittymän voi nyt käynnistää antamalla sen konstruktorille <code>Hahmo</code>-olion parametrina.</p>

<pre class="sh_java">
        Kayttoliittyma kayttoliittyma = new Kayttoliittyma(new Hahmo(30, 30));
        SwingUtilities.invokeLater(kayttoliittyma);
</pre>

    <p><img src="https://www.cs.helsinki.fi/group/java/k13/ohja/img-ohja/kali/piirtoalusta-hahmon-piirtaminen.png"/></p>

<p>Yllä olevassa käyttöliittymässä näkyy huikea, pallonmuotoinen hahmo.</p>

<p>Lisätään seuraavaksi ohjelmaan hahmon siirtämistoiminnallisuus. Haluamme liikuttaa hahmoa näppäimistöllä. Kun käyttäjä painaa nuolta vasemmalle, hahmon pitäisi siirtyä vasemmalle. Oikealle osoittavaa nuolta painettaessa hahmon pitäisi siirtyä oikealle. Tarvitsemme siis tapahtumankuuntelijan, joka kuuntelee näppäimistöä. Rajapinta <code><a href="http://docs.oracle.com/javase/6/docs/api/java/awt/event/KeyListener.html" target="_blank">KeyListener</a></code> määrittelee näppäimistönkuuntelijalta vaaditut toiminnallisuudet.</p>

<p>Rajapinta <code>KeyListener</code> vaatii metodien <code>keyPressed</code>, <code>keyReleased</code>, ja <code>keyTyped</code> toteuttamista. Olemme kiinnostuneita vain tapahtumasta, jossa näppäintä painetaan, joten jätämme metodit <code>keyReleased</code> ja <code>keyTyped</code> tyhjiksi. Luodaan luokka <code>NappaimistonKuuntelija</code>, joka toteuttaa rajapinnan <code>KeyListener</code>. Luokka saa parametrina <code>Hahmo</code>-olion, jota tapahtumankäsittelijän tulee liikuttaa.</p>

<pre class="sh_java">
import java.awt.event.KeyEvent;
import java.awt.event.KeyListener;

public class NappaimistonKuuntelija implements KeyListener {

    private Hahmo hahmo;

    public NappaimistonKuuntelija(Hahmo hahmo) {
        this.hahmo = hahmo;
    }

    @Override
    public void keyPressed(KeyEvent e) {
        if (e.getKeyCode() == KeyEvent.VK_LEFT) {
            hahmo.siirry(-5, 0);
        } else if (e.getKeyCode() == KeyEvent.VK_RIGHT) {
            hahmo.siirry(5, 0);
        }
    }

    @Override
    public void keyReleased(KeyEvent e) {
    }

    @Override
    public void keyTyped(KeyEvent ke) {
    }
}
</pre>

<p>Metodi <code>keyPressed</code> saa käyttöliittymältä parametrina <code>KeyEvent</code>-luokan ilmentymän. KeyEvent-oliolta saa tietoon painettuun nappiin liittyvän numeron sen <code>getKeyCode()</code>-metodilla. Eri näppäimille on luokkamuuttujat <code>KeyEvent</code>-luokassa, esimerkiksi nuoli vasemmalle on <code>KeyEvent.VK_LEFT</code>.</p>

<p>Haluamme kuunnella käyttöliittymään kohdistuvia näppäimen painalluksia (emme esimerkiksi ole kirjoittamassa tekstikenttään), joten lisätään näppäimistönkuuntelija <code>JFrame</code>-luokan ilmentymälle. Muokataan käyttöliittymäämme siten, että näppäimistönkuuntelija lisätään JFrame-oliolle.</p>

<pre class="sh_java">
    private void luoKomponentit(Container container) {
        Piirtoalusta piirtoalusta = new Piirtoalusta(hahmo);
        container.add(piirtoalusta);

        frame.addKeyListener(new NappaimistonKuuntelija(hahmo));
    }
</pre>

<p>Nyt sovelluksemme kuuntelee näppäimistöltä tulleita painalluksia, ja ohjaa ne luokan <code>NappaimistonKuuntelija</code> ilmentymälle.</p>

<p>Kokeillessamme käyttöliittymää se ei kuitenkaan toimi: hahmo ei siirry ruudulla. Mistä tässä oikein on kyse? Voimme tarkastaa että näppäimistön painallukset ohjautuvat <code>NappaimistonKuuntelija</code>-oliolle lisäämällä <code>keyPressed</code>-metodin alkuun testitulostuksen.</p>

<pre class="sh_java">
    @Override
    public void keyPressed(KeyEvent e) {
        System.out.println("Nappia " + e.getKeyCode() +  " painettu.");

        // ...
</pre>

<p>Käynnistäessämme ohjelman ja painaessamme näppäimiä näemme konsolissa tulostuksen.</p>

<pre>
Nappia 39 painettu.
Nappia 37 painettu.
Nappia 40 painettu.
Nappia 38 painettu.
</pre>

<p>Huomaamme että näppäimistön kuuntelija toimii, mutta piirtoalusta ei päivity.</p>

<h3>Piirtoalustan uudelleenpiirtäminen</h3>

<p>Käyttöliittymäkomponentit sisältävät yleensä toiminnallisuuden komponentin ulkoasun uudelleenpiirtämiseen tarvittaessa. Esimerkiksi nappia painettaessa <code>JButton</code>-luokan ilmentymä osaa piirtää napin "painettuna", jonka jälkeen nappi piirretään taas normaalina. Toteuttamassamme piirtoalustassa ei ole valmista päivitystoiminnallisuutta, vaan meidän tulee pyytää sitä piirtämään itsensä uudelleen tarvittaessa.</p>

<p>Jokaisella <code>Component</code>-luokan aliluokalla on metodi <code>public void repaint()</code>, jonka kutsuminen pakottaa komponentin uudelleenpiirtämisen. Haluamme että <code>Piirtoalusta</code>-olio piirretään uudestaan aina kun hahmoa siirretään. Hahmon siirtäminen tapahtuu luokassa <code>NappaimistonKuuntelija</code>, joten on loogista että uudelleenpiirtokutsu tapahtuu myös näppäimistönkuuntelijassa.</p>

<p>Uudelleenpiirtokutsua varten näppäimistönkuuntelija tarvitsee viitteen piirtoalustaan. Muutetaan luokkaa <code>NappaimistonKuuntelija</code> siten, että se saa parametrinaan <code>Hahmo</code>-olion lisäksi uudelleenpiirrettävän <code>Component</code>-olion. Kutsutaan <code>Component</code>-olion <code>repaint</code>-metodia jokaisen <code>keyPressed</code> tapahtuman lopussa.</p>

<pre class="sh_java">
import java.awt.Component;
import java.awt.event.KeyEvent;
import java.awt.event.KeyListener;

public class NappaimistonKuuntelija implements KeyListener {

    private Component component;
    private Hahmo hahmo;

    public NappaimistonKuuntelija(Hahmo hahmo, Component component) {
        this.hahmo = hahmo;
        this.component = component;
    }

    @Override
    public void keyPressed(KeyEvent e) {
        if (e.getKeyCode() == KeyEvent.VK_LEFT) {
            hahmo.siirry(-5, 0);
        } else if (e.getKeyCode() == KeyEvent.VK_RIGHT) {
            hahmo.siirry(5, 0);
        }

        component.repaint();
    }

    @Override
    public void keyReleased(KeyEvent e) {
    }

    @Override
    public void keyTyped(KeyEvent ke) {
    }
}
</pre>

<p>Muutetaan myös <code>Kayttoliittyma</code>-luokan <code>luoKomponentit</code>-metodia siten, että <code>Piirtoalusta</code>-luokan ilmentymä annetaan parametrina näppäimistönkuuntelijalle.</p>

<pre class="sh_java">
    private void luoKomponentit(Container container) {
        Piirtoalusta piirtoalusta = new Piirtoalusta(hahmo);
        container.add(piirtoalusta);

        frame.addKeyListener(new NappaimistonKuuntelija(hahmo, piirtoalusta));
    }
</pre>

<p>Nyt hahmon liikuttaminen myös näkyy käyttöliittymässä. Aina kun käyttäjä painaa näppäimistöä, käyttöliittymään liitetty näppäimistönkuuntelija käsittelee kutsun. Jokaisen kutsun lopuksi kutsutaan piirtoalustan <code>repaint</code>-metodia, joka aiheuttaa piirtoalustan uudelleenpiirtämisen.</p>

    <p><img src="https://www.cs.helsinki.fi/group/java/k13/ohja/img-ohja/kali/piirtoalusta-hahmo-liikkuu.png"/></p>

<div class="tehtavat">
    <div class="tehtava">
<h3>Liikkuva kuvio</h3>

<p>Teemme ohjelman, jossa käyttäjä voi liikutella näppäimistön avulla ruudulle piirrettyjä kuvioita. Ohjelmassa tulee mukana käyttöliittymärunko, jota pääset muokkaamaan ohjelman edetessä.</p>

<p>Aluksi tehdään muutama luokka, joilla kuvioita hallitaan. Pääsemme myöhemmin piirtämään kuvioita ruudulle. Tee kaikki ohjelman luokat pakkaukseen <code>liikkuvakuvio</code>.</p>

<p>Tehtävässä käytetään perintää ja abstrakteja luokkia. Kertaa siis tarvittaessa luvut 18.1, 18.2 ja 18.5</p></p>

<h4  >Abstrakti luokka Kuvio</h4>

<p>Tee abstrakti luokka <code>Kuvio</code>. Kuviolla on oliomuuttujat <code>x</code> ja <code>y</code>, jotka kertovat kuvion sijainnin ruudulla sekä metodi <code>public void siirra(int dx, int dy)</code>, jonka avulla kuvion sijainti siirtyy parametrina olevien koordinaattisiirtymien verran. Esim. jos sijainti aluksi on (100,100), niin kutsun <code>siirra(10,-50)</code> jälkeen sijainti on (110, 50). Luokan konstruktorin <code>public Kuvio(int x, int y)</code> tulee asettaa kuviolle alkusijainti. Lisää luokalle myös metodit <code>public int getX()</code> ja <code>public int getY()</code>.</p>

<p>Luokalla tulee olla myös abstrakti metodi <code>public abstract void piirra(Graphics graphics)</code>, jolla kuvio piirretään piirtoalustalle. Kuvion piirtämismetodi toteutetaan luokan <code>Kuvio</code> perivissä metodeissa.</p>

<h4  >Ympyra</h4>

<p>Tee luokka <code>Ympyra</code> joka perii Kuvion. Ympyrällä on <code>halkaisija</code> jonka arvon konstruktori <code>public Ympyra(int x, int y, int halkaisija)</code> asettaa. Sijainti tallennetaan yläluokassa määriteltyihin oliomuuttujiin.
</p>

<p>
Ympyra määrittelee metodin <code>piirra</code> siten, että oikean kokoinen ympyrä piirretään koordinaattien osoittamaan paikkaan
parametrina olevan <code>Graphics</code>-olion <code>fillOval</code>-metodia käyttäen, ympyrän sijaintia tulee käyttää metodin kahtena ensimmäisenä parametrina. Ota mallia Hahmo-esimerkin vastaavasta metodista.
Graphics-olion metodien toimintaa kannattaa tutkia <a href="http://docs.oracle.com/javase/6/docs/api/java/awt/Graphics.html">Java API:sta.</a>
</p>

<h4  >Piirtoalusta</h4>

<p>Luo luokka <code>Piirtoalusta</code> joka perii luokan <code>JPanel</code>, mallia voit ottaa esimerkiksi edellisen tehtävän mukana tulleesta piirtoalustasta. Piirtoalusta saa konstruktorin parametrina <code>Kuvio</code>-tyyppisen olion. Korvaa luokan <code>JPanel</code> metodi <code>protected void paintComponent(Graphics g)</code> siten, että siinä kutsutaan ensin yläluokan <code>paintComponent</code>-metodia ja sitten piirtoalustalle asetetun kuvion <code>piirra</code>-metodia.</p>

<p>Muokkaa luokkaa <code>Kayttoliittyma</code> siten, että se saa konstruktorin parametrina <code>Kuvio</code>-tyyppisen olion. Lisää käyttöliittymään Piirtoalusta <code>luoKomponentit(Container container)</code>-metodissa, anna piirtoalustalle konstruktorin parametrina käyttöliittymälle annettu kuvio.</p>

<p>Testaa lopuksi että seuraavalla esimerkkikoodilla ruudulle piirtyy ympyrä.</p>

<pre class="sh_java">
        Kayttoliittyma kayttoliittyma = new Kayttoliittyma(new Ympyra(50, 50, 250));
        SwingUtilities.invokeLater(kayttoliittyma);
</pre>

<p><img src="https://www.cs.helsinki.fi/group/java/k13/ohja/img-ohja/kali/liikkuvakuvio-ympyra.png"/></p>



        <h4  >Näppäimistöohjaus</h4>

<p>Laajennetaan piirtoalustaa siten, että kuviota voi liikutella nuolinäppäinten avulla. Luo rajapinnan <code><a href="http://docs.oracle.com/javase/6/docs/api/java/awt/event/KeyListener.html" target="_blank">KeyListener</a></code> toteuttava luokka <code>NappaimistonKuuntelija</code>. Luokan <code>NappaimistonKuuntelija</code> konstruktorin parametrit ovat luokan <code>Component</code> ilmentymä ja luokan <code>Kuvio</code> ilmentymä.</p>

<p>Luokan Component ilmentymä annetaan näppäimistönkuuntelijalle, jotta voimme päivittää halutun komponentin jokaisen näppäimenpainalluksen jälkeen uudestaan. Komponentin päivittäminen tapahtuu kutsumalla <code>Component</code> luokasta perityvää metodia <code>repaint</code>. Luokka Piirtoalusta on tyyppiä <code>Component</code> koska <code>Component</code> on luokan <code>JPanel</code> perivän luokan yläluokka.</p>

<p>Toteuta rajapinnan <code>KeyListener</code> määrittelemä metodi <code>keyPressed(KeyEvent e)</code> siten, että käyttäjän painaessa nuolta vasemmalle kuvio siirtyy yhden pykälän vasemmalle. Oikealle painettaessa yksi oikealle. Ylös painettaessa yksi ylös, ja alas painettaessa yksi alas. Huomaa että y-akseli kasvaa ikkunan yläosasta alaspäin. Näppäinkoodit nuolinäppäimille ovat <code>KeyEvent.VK_LEFT</code>, <code>KeyEvent.VK_RIGHT</code>, <code>KeyEvent.VK_UP</code>, ja <code>KeyEvent.VK_DOWN</code>. Jätä muut rajapinnan <code>KeyListener</code> vaatimat metodit tyhjiksi.</p>

<p>Kutsu aina Component-luokan <code>repaint</code>-metodia näppäimistönkuuntelutapahtuman lopussa.</p>

<p>Lisää näppäimistönkuuntelija Kayttoliittyma-luokan <code>lisaaKuuntelijat</code>-metodissa. Näppäimistönkuuntelija tulee liittää <code>JFrame</code>-olioon.</p>


        <h4  >Nelio ja Laatikko</h4>


<p>Peri luokasta <code>Kuvio</code> luokat <code>Nelio</code> ja <code>Laatikko</code>. Neliöllä on konstruktori <code>public Nelio(int x, int y, int sivunPituus)</code>, laatikon konstruktori on muotoa <code>public Laatikko(int x, int y, int leveys, int korkeus)</code>. Käytä piirtämisessä graphics-olion <code>fillRect</code>-metodia.</p>

<p>Varmista, että neliöt ja laatikot piirtyvät ja liikkuvat oikein Piirtoalustalla.</p>

<pre class="sh_java">
        Kayttoliittyma kayttoliittyma = new Kayttoliittyma(new Nelio(50, 50, 250));
        SwingUtilities.invokeLater(kayttoliittyma);
</pre>

<p><img src="https://www.cs.helsinki.fi/group/java/k13/ohja/img-ohja/kali/liikkuvakuvio-nelio.png"/></p>


<pre class="sh_java">
        Kayttoliittyma kayttoliittyma = new Kayttoliittyma(new Laatikko(50, 50, 100, 300));
        SwingUtilities.invokeLater(kayttoliittyma);
</pre>

<p><img src="https://www.cs.helsinki.fi/group/java/k13/ohja/img-ohja/kali/liikkuvakuvio-laatikko.png"/></p>

        <h4  >Koostekuvio</h4>

        <p>Peri luokasta <code>Kuvio</code> luokka <code>Koostekuvio</code>. Koostekuvio sisältää joukon muita kuvioita jotka se tallettaa ArrayList:iin. Koostekuviolla on metodi <code>public void liita(Kuvio k)</code> jonka avulla koostekuvioon voi liittää kuvio-olion. Koostekuviolla ei ole omaa sijaintia ja ei ole merkitystä mitä koostekuvio asettaa perimiensä x- ja y-koordinaatin arvoiksi. Koostekuvio piirtää itsensä pyytämällä osiaan piirtämään itsensä, koostekuvion siirtyminen tapahtuu samoin. Kuviolta peritty metodi <code>siirra</code> on siis ylikirjoitettava!</p>

<p>Koostekuvion konstruktorilla ei ole parametreja. Koostekuvion konstruktorista on kuitenkin pakko kutsua yliluokan konstruktoria jolla taas on parametrit. Koska koostekuviolla ei ole omaa sijaintia, voit käyttää yliluokan konstruktorikutsussa mitä tahansa parametrin arvoja.</p>

        <p>Testaa että koostekuviosi piirtyy ja siirtyy oikein, esim. seuraavan koostekuvion avulla:</p>

<pre class="sh_java">
        Koostekuvio rekka = new Koostekuvio();

        rekka.liita(new Laatikko(220, 110, 75, 100));
        rekka.liita(new Laatikko(80, 120, 200, 100));
        rekka.liita(new Ympyra(100, 200, 50));
        rekka.liita(new Ympyra(220, 200, 50));

        Kayttoliittyma kayttoliittyma = new Kayttoliittyma(rekka);
        SwingUtilities.invokeLater(kayttoliittyma);
</pre>

<p><img src="https://www.cs.helsinki.fi/group/java/k13/ohja/img-ohja/kali/liikkuvakuvio-rekka.png"/></p>



        <p>Huomaa miten <b>olioiden vastuut</b> jakautuvat tehtävässä. Jokainen Kuvio on vastuussa itsensä piirtämisestä ja siirtämisestä. Yksinkertaiset kuviot siirtyvät kaikki samalla tavalla. Jokaisen yksinkertaisen kuvion on itse hoidettava piirtymisestään. Koostekuvio siirtää itsensä pyytämällä osiaan siirtymään, samoin hoituu koostekuvion piirtyminen. Piirtoalusta tuntee Kuvio-olion joka siis voi olla mikä tahansa yksinkertainen kuvio tai koostekuvio, kaikki piirretään ja siirretään samalla tavalla. Piirtoalusta siis toimii samalla tavalla kuvion oikeasta tyypistä huolimatta, piirtoalustan ei tarvitse tietää kuvion yksityiskohdista mitään. Kun piirtoalusta kutsuu kuvion metodia <code>piirra</code> tai <code>siirra</code> <b>polymorfismin</b> ansiosta kutsutuksi tulee kuvion todellista tyyppiä vastaava metodi.</p>

        <p>Huomionarvoista tehtävässä on se, että Koostekuvio voi sisältää mitä tahansa Kuvio-olioita, siis myös koostekuvioita! Luokkarakenne mahdollistaakin mielivaltaisen monimutkaisen kuvion muodostamisen ja kuvion siirtely ja piirtäminen tapahtuu aina täsmälleen samalla tavalla.</p>

        <p>Luokkarakennetta on myös helppo laajentaa, esim. perimällä Kuvio-luokasta uusia kuviotyyppejä: kolmio, piste, viiva, ym... Koostekuvio toimii ilman muutoksia myös uusien kuviotyyppien kanssa, samoin piirtoalusta ja käyttöliittymä.</p>

</div>
</div>

<h3>Valmiit sovelluskehykset</h3>

<p>Sovelluskehys on ohjelma, joka tarjoaa lähtökohdan ja joukon palveluita jonkin erityisen sovelluksen toteuttamiseen. Yksi tapa laatia sovelluskehys on laatia valmiita palveluita tarjoava luokka, jonka päälle luokan perivät luokat rakentavat erityisen sovelluksen. Sovelluskehykset ovat yleensä hyvin laajoja, ja tarkoitettu johonkin tiettyyn tarkoitukseen, esimerkiksi pelien ohjelmointiin tai web-sovelluskehitykseen. Tutustutaan seuraavasti pikaisesti valmiin sovelluskirjaston käyttöön luomalla sovelluslogiikka Game of Life -pelille.</p>

<div class="tehtavat">
    <p class="mooc-pakollinen"></p>
    <div class="tehtava pakollinen-hakuun">
<h3>Game of Life</h3>

<p>Tässä tehtäväsarjassa toteutetaan sovelluslogiikka Game of Life-pelille perimällä valmis sovellusrunko. Sovellusrunko on projektiin erikseen lisätyssä kirjastossa, joten sen lähdekoodit eivät ole nähtävissä.</p>

<p><b>HUOM:</b> tehtävä ei ole erityisen vaikea, mutta tehtävänanto saattaa aluksi vaikuttaa sekavalta. Lue ohje tarkasti uudelleen tai kysy apua jos et pääse alkuun. Tehtävä kannattaa ehdottomasti tehdä, sillä lopputulos on hieno!</p>

<p>Game of Life on matemaatikko John Conway'n kehittelemä yksinkertainen "populaatiosimulaattori", kts. <a href="http://en.wikipedia.org/wiki/Conway%27s_Game_of_Life">http://en.wikipedia.org/wiki/Conway%27s_Game_of_Life</a>.</p>

<p>Game of Lifen säännöt ovat seuraavat:</p>
<ul>
<li>Jokainen elossa oleva solu, jolla on alle kaksi elossa olevaa naapuria kuolee.</li>
<li>Jokainen elossa oleva solu, jolla on kaksi tai kolme elossa olevaa naapuria elää seuraavaan iteraatioon eli kierrokseen.</li>
<li>Jokainen elossa oleva solu, jolla on yli kolme naapuria kuolee.</li>
<li>Jokainen kuollut solu, jolla on tasan kolme elossa olevaa naapuria muuttuu eläväksi.</li>
</ul>

<p>Abstrakti luokka <code>GameOfLifeAlusta</code> tarjoaa seuraavat toiminnot</p>
<ul>
  <li><b>public GameOfLifeAlusta(int leveys, int korkeus)</b> luo määritellyn kokoisen pelialustan</li>
  <li><b>public boolean[][] getAlusta()</b> tarjoaa pääsyn pelialustaan, joka on totuusarvoista koostuva kaksiulotteinen taulukko &ndash; kuten metodin paluuarvosta voi havaita! Palaamme kaksiulotteiseen taulukkoon tarkemmin sitä tarvitessamme.</li>
  <li><b>public int getLeveys()</b> palauttaa alustan leveyden</li>
  <li><b>public int getKorkeus()</b> palauttaa alustan korkeuden</li>
  <li><b>public void pelaaKierros()</b> simuloi pelikierroksen</li>
</ul>

<p>Luokassa <code>GameOfLifeAlusta</code> on lisäksi määritelty seuraavat abstraktit metodit, <b>jotka sinun tulee toteuttaa</b>.<p>

<ul>
  <li><b>public abstract void muutaElavaksi(int x, int y)</b> muuttaa alkion koordinaatissa (x, y) eläväksi eli asettaa sille arvon <i>true</i>. Jos koordinaatit ovat alustan ulkopuolella ei tapahdu mitään.</li>
  <li><b>public abstract void muutaKuolleeksi(int x, int y)</b> muuttaa alkion koordinaatissa (x, y) kuolleeksi eli asettaa sille arvon <i>false</i>. Jos koordinaatit ovat alustan ulkopuolella ei tapahdu mitään.</li>
  <li><b>public abstract boolean onElossa(int x, int y)</b> kertoo onko koordinaatissa (x, y) oleva alkio elossa. Jos koordinaatit ovat alustan ulkopuolella, palautetaan <i>false.</i></li>
  <li><b>public abstract void alustaSatunnaisetPisteet(double todennakoisyysPisteelle)</b> alustaa kaikki alustan alkiot siten, että kukin alkio on elävä todennäköisyydellä <i>todennakoisyysPisteelle.</i> Todennäköisyys annetaan double-arvona suljetulla välillä [0, 1]. Jos metodia kutsutaan arvolla 1, tulee jokaisen alkion olla elävä. Jos taas todennäköisyys on 0, tulee jokaisen alkion olla kuollut.</li>
  <li><b>public abstract int getElossaOlevienNaapurienLukumaara(int x, int y)</b> kertoo elossa olevien naapureiden lukumäärän solulle pisteessä (x, y).</li>
  <li><b>public abstract void hoidaSolu(int x, int y, int elossaOleviaNaapureita)</b> hoitaa solun (x, y) Game of Life -sääntöjen mukaan.</li>
</ul>


<h4>GameOfLife-toteutus, vaihe 1</h4>

<p>Luo pakkaukseen <code>game</code> luokka <code>OmaAlusta</code>, joka perii pakkauksessa <code>gameoflife</code> olevan luokan <code>GameOfLifeAlusta</code>. Huomaa että pakkausta <code>gameoflife</code> ei ole näkyvillä omassa projektissasi, vaan se tulee mukana luokkakirjastona. Toteuta luokalle <code>OmaAlusta</code> konstruktori <code>public OmaAlusta(int leveys, int korkeus)</code>, joka kutsuu yläluokan konstruktoria annetuilla parametreilla:</p>

<pre class="sh_java">
import gameoflife.GameOfLifeAlusta;

public class OmaAlusta extends GameOfLifeAlusta {

    public OmaAlusta(int leveys, int korkeus) {
        super(leveys, korkeus);
    }

    // ..
</pre>

<p>Voit ensin korvata kaikki abstraktit metodit ei-abstrakteilla metodeilla, jotka eivät kuitenkaan vielä tee mitään järkevää. Mutta koska ne eivät ole abstrakteja, tästä luokasta voi luoda ilmentymiä, toisin kuin abstraktista luokasta GameOfLifeAlusta.</p>

<p>Toteuta seuraavat metodit</p>
<ul>
  <li><b>public void muutaElavaksi(int x, int y)</b> muuttaa alkion koordinaatissa (x, y) eläväksi eli asettaa sille arvon <i>true</i></li>
  <li><b>public void muutaKuolleeksi(int x, int y)</b> muuttaa alkion koordinaatissa (x, y) kuolleeksi eli asettaa sille arvon <i>false</i></li>
  <li><b>public boolean onElossa(int x, int y)</b> kertoo onko koordinaatissa (x, y) oleva alkio elossa. Jos koordinaatit ovat alustan ulkopuolella, palautetaan <i>false.</i></li>
</ul>

<p><b>Vihje:</b> Pääset yläluokassa olevaan kaksiulotteiseen taulukkoon käsiksi yläluokan tarjoaman metodin <code>getAlusta()</code> avulla. Kaksiulotteisia taulukoita käytetään kuten yksiulotteisia taulukoita, mutta taulukoille annetaan kaksi indeksiä. Ensimmäinen indeksi kertoo leveyskohdan, toinen indeksi korkeuskohdan. Esimerkiksi seuraava ohjelmapätkä luo ensin 10 x 10 -kokoisen taulukon, ja tulostaa sitten taulukon indeksissä 3, 1 olevan arvon.</p>

<pre class="sh_java">
boolean[][] arvot = new boolean[10][10];
System.out.println(arvot[3][1]);
</pre>

<p>Vastaavasti OmaAlusta-luokassa voidaan tulostaa yläluokasta saadun taulukon arvo indeksissä x, y seuraavasti:</p>

<pre class="sh_java">
boolean[][] alusta = getAlusta();
System.out.println(alusta[x][y]);
</pre>

<p>Ja indeksiin x,y voidaan asettaa esim. arvo true seuraavasti:</p>

<pre class="sh_java">
boolean[][] alusta = getAlusta();
alusta[x][y] = true;
</pre>

<p>Tai suoraan käyttämättä apumuuttujaa:</p>

<pre class="sh_java">
getAlusta()[x][y] = true;
</pre>


<p>Testaa toteutustasi seuraavalla testiohjelmalla. <b>Huom:</b> jos projektissasi ei ole mukana luokkaa <code>GameOfLifeTestaaja</code> löydät sen <a href="http://www.cs.helsinki.fi/group/java/s12/ohja/gol.txt">täältä</a>.</p>

<pre class="sh_java">
package game;

public class Main {
    public static void main(String[] args) {
        OmaAlusta alusta = new OmaAlusta(7, 5);

        alusta.muutaElavaksi(2, 0);
        alusta.muutaElavaksi(4, 0);

        alusta.muutaElavaksi(3, 3);
        alusta.muutaKuolleeksi(3, 3);

        alusta.muutaElavaksi(0, 2);
        alusta.muutaElavaksi(1, 3);
        alusta.muutaElavaksi(2, 3);
        alusta.muutaElavaksi(3, 3);
        alusta.muutaElavaksi(4, 3);
        alusta.muutaElavaksi(5, 3);
        alusta.muutaElavaksi(6, 2);

        GameOfLifeTestaaja gom = new GameOfLifeTestaaja(alusta);
        gom.pelaa();
    }
}
</pre>
<p>

Tulostuksen pitäisi olla seuraavanlainen:

<pre>
Paina enter jatkaaksesi, muut lopettaa: &lt;enter&gt;

  X X

X     X
 XXXXX

Paina enter jatkaaksesi, muut lopettaa: <font color="red">stop</font>
Kiitos!
</pre>
<p>

<h4>GameOfLife-toteutus, vaihe 2</h4>

<p>Toteuta metodi <b>alustaSatunnaisetPisteet(double todennakoisyysPisteelle)</b>, joka alustaa kaikki alkiot siten, että kukin alkio on elävä todennäköisyydellä <i>todennakoisyysPisteelle</i>. Todennäköisyys annetaan metodille suljetulla välillä [0, 1] olevana double-tyyppisenä parametrina.</p>

<p>Testaa metodia. Arvolla 0.0 ei pitäisi olla yhtään elossa olevaa solua, arvolla 1.0 kaikkien solujen tulisi olla elossa (eli näkyä X-merkkisinä). Arvolla 0.5 noin puolet soluista on eläviä.</p>

<pre class="sh_java">
        OmaAlusta alusta = new OmaAlusta(3, 3);
        alusta.alustaSatunnaisetPisteet(1.0);

        GameOfLifeTestaaja gom = new GameOfLifeTestaaja(alusta);
        gom.pelaa();
</pre>

<pre>
Paina enter jatkaaksesi, muut lopettaa: &lt;enter&gt;

XXX
XXX
XXX
Paina enter jatkaaksesi, muut lopettaa: <font color="red">stop</font>
Kiitos!
</pre>

<h4>GameOfLife-toteutus, vaihe 3</h4>

<p>Toteuta metodi <b>getElossaOlevienNaapurienLukumaara(int x, int y),</b> joka laskee elossa olevien naapurien lukumäärän. Keskellä
taulukkoa olevalla solulla on yhteensä kahdeksan naapuria, reunassa olevalla solulla 5, kulmassa olevalla 3. </p>

<p>Testaa metodia seuraavilla lauseilla (voit keksiä myös muita testitapauksia!):</p>

<pre class="sh_java">
OmaAlusta alusta = new OmaAlusta(7, 5);

alusta.muutaElavaksi(0, 1);
alusta.muutaElavaksi(1, 0);
alusta.muutaElavaksi(1, 2);
alusta.muutaElavaksi(2, 2);
alusta.muutaElavaksi(2, 1);

System.out.println("Elossa naapureita (0,0): " + alusta.getElossaOlevienNaapurienLukumaara(0, 0));
System.out.println("Elossa naapureita (1,1): " + alusta.getElossaOlevienNaapurienLukumaara(1, 1));
</pre>
<p>

Tulostuksen pitäisi olla seuraavanlainen:
<pre>
Elossa naapureita (0,0): 2
Elossa naapureita (1,1): 5
</pre>


<h4>GameOfLife-toteutus, vaihe 4</h4>

<p>Jäljellä on vielä metodin <b>hoidaSolu(int x, int y, int elossaOleviaNaapureita)</b> toteuttaminen. GameOfLife-pelin säännöthän olivat seuraavat:</p>

<ul>
  <li>Jokainen elossa oleva solu, jolla on alle kaksi elossa olevaa naapuria kuolee.</li>
  <li>Jokainen elossa oleva solu, jolla on kaksi tai kolme elossa olevaa naapuria elää seuraavaan iteraatioon eli kierrokseen.</li>
  <li>Jokainen elossa oleva solu, jolla on yli kolme naapuria kuolee.</li>
  <li>Jokainen kuollut solu, jolla on tasan kolme elossa olevaa naapuria muuttuu eläväksi.</li>
</ul>

<p>Toteuta metodi <code>hoidaSolu(int x, int y, int elossaOleviaNaapureita)</code> ylläolevien sääntöjen mukaan. Kannattaa ohjelmoida ja testata yksi sääntö kerrallaan!</p>

<p>Kun olet saanut kaikki valmiiksi, voit testata ohjelman toimintaa seuraavalla graafisella simulaattorilla.</p>

<pre class="sh_java">
package game;

import gameoflife.Simulaattori;

public class Main {

    public static void main(String[] args) {
        OmaAlusta alusta = new OmaAlusta(100, 100);
        alusta.alustaSatunnaisetPisteet(0.7);

        Simulaattori simulaattori = new Simulaattori(alusta);
        simulaattori.simuloi();
    }
}
</pre>

</div>
</div>
</div>
</section>

<section class="viikkoraja" id="6" >
  <div class="viikkoraja"></div>
  <div class="viikkoraja-mooc" id="Viikko 12" deadline="avautuu kun 85 % viikosta 11 tehty" data-first-chapter-index="53" data-first-exercise-index="151" data-first-week-index="12"  data-first-chapter-index-mooc="53" data-first-exercise-index-mooc="151" data-first-week-index-mooc="12" tekija="Arto Vihavainen, Matti Luukkainen">

<h2>Muutamia hyödyllisiä tekniikoita</h2>

<p>Kurssin lähestyessä loppua katsomme vielä muutamaa hyödyllistä Javan ominaisuutta.</p>

<h3>Säännölliset lausekkeet</h3>

<p>Säännöllinen lauseke määrittelee tiiviissä muodossa joukon merkkijonoja. Säännöllisiä lausekkeita käytetään muunmuassa merkkijonojen oikeellisuuden tarkistamiseen. Tarkastellaan tehtävää, jossa täytyy tarkistaa, onko käyttäjän antama opiskelijanumero oikeanmuotoinen. Opiskelijanumero alkaa merkkijonolla "01", jota seuraa 7 numeroa väliltä 0&ndash;9.</p>

<p>Opiskelijanumeron oikeellisuuden voisi tarkistaa esimerkiksi käymällä opiskelijanumeroa esittävän merkkijonon läpi merkki merkiltä <code>charAt</code>-metodin avulla. Toinen tapa olisi tarkistaa että ensimmäinen merkki on "0", ja käyttää <code>Integer.parseInt</code> metodikutsua merkkijonon muuntamiseen numeroksi. Tämän jälkeen voisi tarkistaa että <code>Integer.parseInt</code>-metodin palauttama luku on pienempi kuin 20000000.</p>

<p>Oikeellisuuden tarkistus säännöllisten lausekkeiden avulla vaatii ensin sopivan säännöllisen lausekkeen määrittelyn. Tämän jälkeen voimme käyttää <code>String</code>-luokan metodia <code>matches</code>, joka tarkistaa vastaako merkkijono parametrina annettua säännöllistä lauseketta. Opiskelijanumeron tapauksessa sopiva säännöllinen lauseke on <code>"01[0-9]{7}"</code>, ja käyttäjän syöttämän opiskelijanumeron tarkistaminen käy seuraavasti:</p>

<pre class="sh_java">
System.out.print("Anna opiskelijanumero: ");
String numero = lukija.nextLine();

if (numero.matches("01[0-9]{7}")) {
    System.out.println("Muoto on oikea.");
} else {
    System.out.println("Muoto ei ole oikea.");
}
</pre>

<p>Käydään seuraavaksi läpi eniten käytettyjä säännöllisten lausekkeiden merkintöjä.</p>

<h4>Pystyviiva eli vaihtoehtoisuus</h4>

<p>Pystyviiva tarkoittaa, että säännöllisen lausekkeen osat ovat vaihtoehtoisia. Esimerkiksi lauseke <code>00|111|0000</code> määrittelee merkkijonot <code>00</code>, <code>111</code> ja <code>0000</code>. Metodi <code>matches</code> palauttaa arvon <code>true</code> jos merkkijono vastaa jotain määritellyistä vaihtoehdoista.</p>

<pre class="sh_java">
    String merkkijono = "00";

    if(merkkijono.matches("00|111|0000")) {
        System.out.println("Merkkijonosta löytyi joku kolmesta vaihtoehdosta");
    } else {
        System.out.println("Merkkijonosta ei löytynyt yhtäkään vaihtoehdoista");
    }
</pre>

<pre>
Merkkijonosta löytyi joku kolmesta vaihtoehdosta
</pre>

<p>Säännöllinen lauseke <code>00|111|0000</code> vaatii että merkkijono on täsmälleen määritellyn muotoinen: se ei määrittele <em>"contains"</em>-toiminnallisuutta.</p>

<pre class="sh_java">
    String merkkijono = "1111";

    if(merkkijono.matches("00|111|0000")) {
        System.out.println("Merkkijonosta löytyi joku kolmesta vaihtoehdosta");
    } else {
        System.out.println("Merkkijonosta ei löytynyt yhtäkään vaihtoehdoista");
    }
</pre>

<pre>
Merkkijonosta ei löytynyt yhtäkään vaihtoehdoista
</pre>

<h4>Sulut, eli merkkijonon osaan rajattu vaikutusalue</h4>

<p>Sulkujen avulla voi määrittää, mihin säännöllisen lausekkeen osaan sulkujen sisällä olevat merkinnät vaikuttavat. Jos haluamme sallia merkkijonot <code>00000</code> ja <code>00001</code>, voimme määritellä ne pystyviivan avulla muodossa <code>00000|00001</code>. Sulkujen avulla voimme rajoittaa vaihtoehtoisuuden vain osaan merkkijonoa. Lauseke <code>0000(0|1)</code> määrittelee merkkijonot <code>00000</code> ja <code>00001</code>.</p>

<p>Vastaavasti säännöllinen lauseke <code>auto(|n|a)</code> määrittelee sanan auto yksikön nominatiivin (auto), genetiivin (auton), partitiivin (autoa) ja akkusatiivin (auto tai auton).</p>


<pre class="sh_java">
System.out.print("Kirjoita joku sanan auto yksikön taivutusmuoto: ");
String sana = lukija.nextLine();

if (sana.matches("auto(|n|a|ssa|sta|on|lla|lta|lle|na|ksi|tta)")) {
    System.out.println("Oikein meni!");
} else {
    System.out.println("Taivutusmuoto ei ole oikea.");
}
</pre>

<h4>Toistomerkinnät</h4>

<p>Usein halutaan, että merkkijonossa toistuu jokin tietty alimerkkijono. Säännöllisissä lausekkeissa on käytössä seuraavat toistomerkinnät:</p>

<ul>
<li>Merkintä <strong><code>*</code></strong> toisto 0... kertaa, esim<br/>
<pre class="sh_java">
    String merkkijono = "trolololololo";

    if(merkkijono.matches("trolo(lo)*")) {
        System.out.println("Muoto on oikea.");
    } else {
        System.out.println("Muoto ei ole oikea.");
    }
</pre>

<pre>
Muoto on oikea.
</pre>
</li>

<li>Merkintä <strong><code>+</code></strong> toisto 1... kertaa, esim<br/>
<pre class="sh_java">
    String merkkijono = "trolololololo";

    if(merkkijono.matches("tro(lo)+")) {
        System.out.println("Muoto on oikea.");
    } else {
        System.out.println("Muoto ei ole oikea.");
    }
</pre>

<pre>
Muoto on oikea.
</pre>

<pre class="sh_java">
    String merkkijono = "nänänänänänänänä Bätmään!";

    if(merkkijono.matches("(nä)+ Bätmään!")) {
        System.out.println("Muoto on oikea.");
    } else {
        System.out.println("Muoto ei ole oikea.");
    }
</pre>

<pre>
Muoto on oikea.
</pre>
</li>

<li>Merkintä <strong><code>?</code></strong> toisto 0 tai 1 kertaa, esim<br/>
<pre class="sh_java">
    String merkkijono = "You have to accidentally the whole meme";

    if(merkkijono.matches("You have to accidentally (delete )?the whole meme")) {
        System.out.println("Muoto on oikea.");
    } else {
        System.out.println("Muoto ei ole oikea.");
    }
</pre>

<pre>
Muoto on oikea.
</pre>
</li>

<li>Merkintä <strong><code>{a}</code></strong> toisto <code>a</code> kertaa, esim<br/>
<pre class="sh_java">
    String merkkijono = "1010";

    if(merkkijono.matches("(10){2}")) {
        System.out.println("Muoto on oikea.");
    } else {
        System.out.println("Muoto ei ole oikea.");
    }
</pre>

<pre>
Muoto on oikea.
</pre>
</li>

<li>Merkintä <strong><code>{a,b}</code></strong> toisto <code>a</code> ... <code>b</code> kertaa, esim<br/>
<pre class="sh_java">
    String merkkijono = "1";

    if(merkkijono.matches("1{2,4}")) {
        System.out.println("Muoto on oikea.");
    } else {
        System.out.println("Muoto ei ole oikea.");
    }
</pre>

<pre>
Muoto ei ole oikea.
</pre>
</li>

<li>Merkintä <strong><code>{a,}</code></strong> toisto <code>a</code> ... kertaa, esim<br/>
<pre class="sh_java">
    String merkkijono = "11111";

    if(merkkijono.matches("1{2,}")) {
        System.out.println("Muoto on oikea.");
    } else {
        System.out.println("Muoto ei ole oikea.");
    }
</pre>

<pre>
Muoto on oikea.
</pre>
</li>
</ul>

<p>Samassa säännöllisessä lausekkeessa voi käyttää myös useampia toistomerkintöjä. Esimerkiksi säännöllinen lauseke <code>5{3}(1|0)*5{3}</code> määrittelee merkkijonot, jotka alkavat ja loppuvat kolmella vitosella. Välissä saa tulla rajaton määrä ykkösiä ja nollia.</p>

<h4>Hakasulut, eli merkkiryhmät</h4>

<p>Merkkiryhmän avulla voi määritellä lyhyesti joukon merkkejä. Merkit kirjoitetaan hakasulkujen sisään, ja merkkivälin voi määrittää viivan avulla. Esimerkiksi merkintä <code>[145]</code> tarkoittaa samaa kuin <code>(1|4|5)</code> ja merkintä <code>[2-36-9]</code> tarkoittaa samaa kuin <code>(2|3|6|7|8|9)</code>. Vastaavasti merkintä <code>[a-c]*</code> määrittelee säännöllisen lausekkeen, joka vaatii että merkkijono sisältää vain merkkejä <code>a</code>, <code>b</code> ja <code>c</code>.</p>

<div class="tehtavat">
<div class="tehtava">
<h3>Säännölliset lausekkeet</h3>

<p>Harjoitellaan hieman säännöllisten lausekkeiden käyttöä. Tehtävät tehdään oletuspakkauksessa olevaan luokkaan <code>Paaohjelma</code>.</h3>

<h4  >Viikonpäivä</h4>

<p>Tee säännöllisen lausekkeen avulla luokalle <code>Paaohjelma</code> metodi <code>public static boolean onViikonpaiva(String merkkijono)</code>, joka palauttaa <code>true</code> jos sen parametrina saama merkkijono on viikonpäivän lyhenne (ma, ti, ke, to, pe, la tai su).</p>

<p>Esimerkkitulostuksia metodia käyttävästä ohjelmasta:</p>

<pre>
Anna merkkijono: <font color="red">ti</font>
Muoto on oikea.
</pre>

<pre>
Anna merkkijono: <font color="red">abc</font>
Muoto ei ole oikea.
</pre>

<h4  >Vokaalitarkistus</h4>

<p>Tee luokalle <code>Paaohjelma</code> metodi <code>public static boolean kaikkiVokaaleja(String merkkijono)</code> joka tarkistaa säännöllisen lausekkeen avulla ovatko parametrina olevan merkkijonon kaikki merkit vokaaleja. </p>

<p>Esimerkkitulostuksia metodia käyttävästä ohjelmasta:</p>

<pre>
Anna merkkijono: <font color="red">aie</font>
Muoto on oikea.
</pre>

<pre>
Anna merkkijono: <font color="red">ane</font>
Muoto ei ole oikea.
</pre>

<h4  >Kellonaika</h4>

<p>Säännölliset lausekkeet sopivat tietynlaisiin tilanteisiin. Joissain tapaukseesa lausekkeista tulee liian monimutkaisia, ja merkkijonon "sopivuus" kannattaa tarkastaa muulla tyylillä tai voi olla tarkoituksenmukaista käyttää säännöllisiä lausekkeita vain osaan tarkastuksesta.</p>

<p>Tee luokalle <code>Paaohjelma</code> metodi <code>public static boolean kellonaika(String merkkijono)</code>  ohjelma, joka tarkistaa säännöllisen lausekkeen avulla onko parametrina oleva merkkijono muotoa <code>tt:mm:ss</code> oleva kellonaika (tunnit, minuutit ja sekunnit kaksinumeroisina).</p>

<p>Esimerkkitulostuksia metodia käyttävästä ohjelmasta:</p>

<pre>
Anna merkkijono: <font color="red">17:23:05</font>
Muoto on oikea.
</pre>

<pre>
Anna merkkijono: <font color="red">abc</font>
Muoto ei ole oikea.
</pre>

<pre>
Anna merkkijono: <font color="red">33:33:33</font>
Muoto ei ole oikea.
</pre>

</div>
</div>
<p> Nykyään lähes kaikista ohjelmointikielistä löytyy tuki säännöllisille lausekkeille. Säännöllisten lausekkeiden teoriaa tarkastellaan toisen vuoden kurssilla <em>Laskennan mallit</em>. Lisää säännöllisistä lausekkeista löydät esim. googlaamalla hakusanalla <em>regular expressions java</em>.</p>

<h3>Enum eli lueteltu tyyppi</h3>

<p>Toteutimme aiemmin pelikorttia mallintavan luokan <code>Kortti</code> suunilleen seuraavasti:</p>

<pre class="sh_java">
public class Kortti {

    public static final int RUUTU = 0;
    public static final int PATA = 1;
    public static final int RISTI = 2;
    public static final int HERTTA = 3;

    private int arvo;
    private int maa;

    public Kortti(int arvo, int maa) {
        this.arvo = arvo;
        this.maa = maa;
    }

    @Override
    public String toString() {
        return maanNimi() + " "+arvo;
    }

    private String maanNimi() {
        if (maa == 0) {
            return "RUUTU";
        } else if (maa == 1) {
            return  "PATA";
        } else if (maa == 2) {
            return "RISTI";
        }
        return "HERTTA";
    }

    public int getMaa() {
        return maa;
    }
}
</pre>

<p>Kortin maa tallennetaan kortissa olevaan oliomuuttujaan kokonaislukuna. Maan ilmaisemiseen on määritelty luettavuutta helpottavat vakiot. Kortteja ja maita ilmaisevia vakioita käytetään seuraavasti:</p>

<pre class="sh_java">
public static void main(String[] args) {
        Kortti kortti = new Kortti(10, Kortti.HERTTA);

        System.out.println(kortti);

        if (kortti.getMaa() == Kortti.PATA) {
            System.out.println("on pata");
        } else {
            System.out.println("ei ole pata");
        }

}
</pre>

<p>Maan esittäminen numerona on huono ratkaisu, sillä esimerkiksi seuraavat järjenvastaiset tavat käyttää korttia ovat mahdollisia:</p>

<pre class="sh_java">
        Kortti jarjetonKortti = new Kortti(10, 55);

        System.out.println(jarjetonKortti);

        if (jarjetonKortti.getMaa() == 34) {
            System.out.println("kortin maa on 34");
        } else {
            System.out.println("kortin maa on jotain muuta kun 34");
        }

        int maaPotenssiinKaksi = jarjetonKortti.getMaa() * jarjetonKortti.getMaa();

        System.out.println("kortin maa potenssiin kaksi on " + maaPotenssiinKaksi);
</pre>

<p>Jos tiedämme muuttujien mahdolliset arvot ennalta, voimme käyttää niiden esittämiseen <code>enum</code>-tyyppistä luokkaa eli <em>lueteltua tyyppiä</em>. Luetellut tyypit ovat oma luokkatyyppinsä rajapinnan ja normaalin luokan lisäksi. Lueteltu tyyppi määritellään avainsanalla <code>enum</code>. Esimerkiksi seuraava <code>Maa</code>-enumluokka määrittelee neljä vakioarvoa: <code>RUUTU</code>, <code>PATA</code>, <code>RISTI</code> ja <code>HERTTA</code>.</p>

<pre class="sh_java">
public enum Maa {
    RUUTU, PATA, RISTI, HERTTA
}
</pre>

<p>Yksinkertaisimmassa muodossaan <code>enum</code> luettelee pilkulla erotettuina määrittelemänsä vakioarvot. Enumien vakiot on yleensä tapana kirjoittaa kokonaan isoin kirjaimin.</p>

<p>Enum luodaan (yleensä) omaan tiedostoon, samaan tapaan kuin luokka tai rajapinta. NetBeansissa Enumin saa luotua valitsemalla projektin kohdalla <em>new/other/java/java enum</em>. </p>

<p>Seuraavassa luokka <code>Kortti</code> jossa maa esitetään enumin avulla:</p>

<pre class="sh_java">
public class Kortti {

    private int arvo;
    private Maa maa;

    public Kortti(int arvo, Maa maa) {
        this.arvo = arvo;
        this.maa = maa;
    }

    @Override
    public String toString() {
        return maa + " "+arvo;
    }

    public Maa getMaa() {
        return maa;
    }

    public int getArvo() {
        return arvo;
    }
}
</pre>

<p>Kortin uutta versiota käytetään seuraavasti:</p>

<pre class="sh_java">
public class Paaohjelma {

    public static void main(String[] args) {
        Kortti eka = new Kortti(10, Maa.HERTTA);

        System.out.println(eka);

        if (eka.getMaa() == Maa.PATA) {
            System.out.println("on pata");
        } else {
            System.out.println("ei ole pata");
        }

    }
}
</pre>

<p>Tulostuu:</p>

<pre>
HERTTA 10
ei ole pata
</pre>

<p>Huomaamme, että enumin tunnukset tulostuvat mukavasti! Koska kortin maat ovat nyt tyyppiä <code>Maa</code> ei ylemmän esimerkin "järjenvastaiset" kummallisuudet, esim. "maan korottaminen toiseen potenssiin" onnistu. Oraclella on <code>enum</code>-tyyppiin liittyvä sivusto osoitteessa <a href="http://docs.oracle.com/javase/tutorial/java/javaOO/enum.html" target="_blank">http://docs.oracle.com/javase/tutorial/java/javaOO/enum.html</a>.</p>

<h3>Iteraattori</h3>

<p>Tarkastellaan seuraavaa luokkaa <code>Kasi</code>, joka mallintaa tietyssä korttipelissä pelaajan kädessä olevien korttien joukkoa:</p>

<pre class="sh_java">
public class Kasi {
    private ArrayList&lt;Kortti&gt; kortit;

    public Kasi() {
        kortit = new ArrayList&lt;Kortti&gt;();
    }

    public void lisaa(Kortti kortti){
        kortit.add(kortti);
    }

    public void tulosta(){
        for (Kortti kortti : kortit) {
            System.out.println( kortti );
        }
    }
}
</pre>

<p>Luokan metodi <code>tulosta</code> tulostaa jokaisen kädessä olevan kortin tutuksi tullutta "for each"-lausetta käyttämällä. ArrayList ja muut <em>Collection</em>-rajapinnan toteuttavat "oliosäiliöt" toteuttavat rajapinnan <em>Iterable</em>. Rajapinnan <em>Iterable</em> toteuttavat oliot on mahdollista käydä läpi eli "iteroida" esimerkiksi. for each -tyyppisellä komennolla.</p>

<p>Oliosäiliö voidaan käydä läpi myös käyttäen ns. <em>iteraattoria</em>, eli olioa, joka on varta vasten tarkoitettu tietyn oliokokoelman läpikäyntiin. Seuraavassa on iteraattoria käyttävä versio korttien tulostamisesta:</p>

<pre class="sh_java">
public void tulosta() {
    Iterator&lt;Kortti&gt; iteraattori = kortit.iterator();

    while ( iteraattori.hasNext() ){
        System.out.println( iteraattori.next() );
    }
}
</pre>

<p>Iteraattori pyydetään kortteja sisältävältä arraylistiltä <code>kortit</code>. Iteraattori on ikäänkuin "sormi", joka osoittaa aina tiettyä listan sisällä olevaa olioa, ensin ensimmäistä ja sitten seuraavaa jne... kunnes "sormen" avulla on käyty jokainen olio läpi.</p>

<p>Iteraattori tarjoaa muutaman metodin. Metodilla <code>hasNext()</code> kysytään onko läpikäytäviä olioita vielä jäljellä. Jos on, voidaan iteraattorilta pyytää seuraavana vuorossa oleva olio metodilla <code>next()</code>. Metodi siis palauttaa seuraavana läpikäyntivuorossa olevan olion ja laittaa iteraattorin eli "sormen" osoittamaan seuraavana vuorossa olevaa läpikäytävää olioa.</p>

<p>Iteraattorin next-metodin palauttama olioviite voidaan ottaa toki talteen myös muuttujaan, eli metodi <code>tulosta</code> voitaisiin muotoilla myös seuraavasti:</p>

<pre class="sh_java">
public void tulosta(){
    Iterator&lt;Kortti&gt; iteraattori = kortit.iterator();

    while ( iteraattori.hasNext() ){
        Kortti seuraavanaVuorossa = iteraattori.next();
        System.out.println( seuraavanaVuorossa );
    }
}
</pre>

<p>Teemme metodin jonka avulla kädestä voi poistaa tiettyä arvoa pienemmät kortit:</p>

<pre class="sh_java">
public class Kasi {
    // ...

    public void poistaHuonommat(int arvo) {
        for (Kortti kortti : kortit) {
            if ( kortti.getArvo() &lt; arvo ) {
                kortit.remove(kortti);
            }
        }
    }
}
</pre>

<p>Huomaamme että metodin suoritus aiheuttaa kummallisen virheen:</p>

<pre>
Exception in thread "main" java.util.ConcurrentModificationException
        at java.util.AbstractList$Itr.checkForComodification(AbstractList.java:372)
        at java.util.AbstractList$Itr.next(AbstractList.java:343)
        at Kasi.poistaHuonommat(Kasi.java:26)
        at Paaohjelma.main(Paaohjelma.java:20)
Java Result: 1
</pre>

<p>Virheen syynä on se, että for-each:illa listaa läpikäydessä ei ole sallittua poistaa listalta olioita: komento for-each menee tästä "sekaisin".</p>

<p>Jos listalta halutaan poistaa osa olioista läpikäynnin aikana osa, tulee tämä tehdä iteraattoria käyttäen. Iteraattori-olion metodia <code>remove</code> kutsuttaessa listalta poistetaan siististi se alkio jonka iteraattori palautti edellisellä metodin <code>next</code> kutsulla. Toimiva versio metodista seuraavassa:</p>

<pre class="sh_java">
public class Kasi {
    // ...

    public void poistaHuonommat(int arvo) {
        Iterator&lt;Kortti&gt; iteraattori = kortit.iterator();

        while (iteraattori.hasNext()) {
            if (iteraattori.next().getArvo() &lt; arvo) {
                // poistetaan listalta olio jonka edellinen next-metodin kutsu palautti
                iteraattori.remove();
            }
        }
    }
}
</pre>


<div class="tehtavat">
    <div class="tehtava">

<h3>Enum ja Iteraattori</h3>

<p>Tehdään ohjelma pienen yrityksen henkilöstön hallintaan.</p>

<h4>Koulutus</h4>

<p>Tee pakkaukseen <code>henkilosto</code> lueteltu tyyppi eli enum <code>Koulutus</code> jolla on tunnukset <code>FT</code> (tohtori), <code>FM</code> (maisteri), <code>LuK</code> (kandidaatti), <code>FilYO</code> (ylioppilas).</p>

<h4>Henkilo</h4>

<p>Tee pakkaukseen <code>henkilosto</code> luokka Luokka <code>Henkilo</code>. Henkilölle annetaan konstruktorin parametrina annettava nimi ja koulutus. Henkilöllä on myös koulutuksen kertova metodi <code>public Koulutus getKoulutus()</code> sekä alla olevan esimerkin mukaista jälkeä tekevä <code>toString</code>-metodi.</p>

<pre class="sh_java">
    Henkilo arto = new Henkilo("Arto", Koulutus.FT);
    System.out.println(arto);
</pre>

<pre>
Arto, FT
</pre>


<h4>Tyontekijat</h4>

<p>Tee pakkaukseen <code>henkilosto</code> luokka Luokka <code>Tyontekijat</code>. Työntekijät-olio sisältää listan Henkilo-olioita. Luokalla on parametriton konstruktori ja seuraavat metodit:</p>

<ul>
  <li><code>public void lisaa(Henkilo lisattava)</code> lisää parametrina olevan henkilön työntekijäksi</li>
  <li><code>public void lisaa(List&lt;Henkilo&gt; lisattavat)</code> lisää parametrina olevan listan henkilöitä työntekijöiksi</li>
  <li><code>public void tulosta()</code> tulostaa kaikki työntekijät</li>
  <li><code>public void tulosta(Koulutus koulutus)</code> tulostaa työntekijät joiden koulutus on sama kuin parametrissa määritelty koulutus</li>
</ul>

<p><strong>HUOM:</strong> Luokan <code>Tyontekijat</code> <code>tulosta</code>-metodit on toteutettava iteraattoria käyttäen!</p>

<h4>Irtisanominen</h4>

<p>Tee luokalle  <code>Tyontekijat</code> metodi <code>public void irtisano(Koulutus koulutus)</code> joka poistaa Työntekijöiden joukosta kaikki henkilöt joiden koulutus on sama kuin metodin parametrina annettu.</p>

<p><strong>HUOM:</strong> toteuta metodi iteraattoria käyttäen!</p>

<p>Seuraavassa esimerkki luokan käytöstä:</p>

<pre class="sh_java">
Public class Paaohjelma {

    public static void main(String[] args) {
        Tyontekijat yliopisto = new Tyontekijat();
        yliopisto.lisaa(new Henkilo("Matti", Koulutus.FT));
        yliopisto.lisaa(new Henkilo("Pekka", Koulutus.FilYO));
        yliopisto.lisaa(new Henkilo("Arto", Koulutus.FT));

        yliopisto.tulosta();

        yliopisto.irtisano(Koulutus.FilYO);

        System.out.println("==");

        yliopisto.tulosta();
}
</pre>

<p>Tulostuu:</p>

<pre>
Matti, FT
Pekka, FilYO
Arto, FT
==
Matti, FT
Arto, FT
</pre>

</div>
</div>

<h3>Toistolauseet ja continue</h3>

<p>Toistolauseissa on komennon <code>break</code> lisäksi käytössä komento <code>continue</code>, joka mahdollistaa seuraavaan toistokierrokseen hyppäämisen.</p>

<pre class="sh_java">
    List&lt;String&gt; nimet = Arrays.asList("Matti", "Pekka", "Arto");

    for(String nimi: nimet) {
        if (nimi.equals("Arto")) {
            continue;
        }

        System.out.println(nimi);
    }
</pre>

<pre>
Matti
Pekka
</pre>

<p>Komentoa <code>continue</code> käytetään esimerkiksi silloin, kun tiedetään että toistolauseessa iteroitavilla muuttujilla on arvoja, joita ei haluta käsitellä lainkaan. Klassinen lähestymistapa olisi if-lauseen käyttö, mutta komento <code>continue</code> mahdollistaa sisennyksiä välttävän, ja samalla ehkä luettavamman lähestymistavan käsiteltävien arvojen välttämiseen. Alla on kaksi esimerkkiä, jossa käydään listalla olevia lukuja läpi. Jos luku on alle 5, se on jaollinen sadalla, tai se on jaollinen neljälläkymmenellä, niin sitä ei tulosteta, muulloin se tulostetaan. </p>

<pre class="sh_java">
    List&lt;Integer&gt; luvut = Arrays.asList(1, 3, 11, 6, 120);

    for(int luku: luvut) {
        if (luku > 4 && luku % 100 != 0 && luku % 40 != 0) {
            System.out.println(luku);
        }
    }

    for(int luku: luvut) {
        if (luku &lt; 5) {
            continue;
        }

        if (luku % 100 == 0) {
            continue;
        }

        if (luku % 40 == 0) {
            continue;
        }

        System.out.println(luku);
    }
</pre>

<pre>
11
6
11
6
</pre>

<h3>Enumien oliomuuttujat</h3>

<p>Luetellut tyypit voivat sisältää oliomuuttujia. Oliomuuttujien arvot tulee asettaa luetellun tyypin määrittelevän luokan sisäisessä eli näkyvyysmääreen <code>private</code> omaavassa konstruktorissa. Enum-tyyppisillä luokilla ei saa olla <code>public</code>-konstruktoria.</p>
<p>
Seuraavassa lueteltu tyyppi <code>Vari</code>, joka sisältää vakioarvot PUNAINEN, VIHREA ja SININEN. Vakioille on määritelty <a href="http://www.ratol.fi/opensource/xhtml/vari.htm">värikoodin</a> kertova oliomuuttuja:
</p>

<pre class="sh_java">
public enum Vari {
    PUNAINEN("#FF0000"),        // konstruktorin parametrit määritellään vakioarvoja lueteltaessa
    VIHREA("#00FF00"),
    SININEN("#0000FF");

    private String koodi;        // oliomuuttuja

    private Vari(String koodi) { // konstruktori
        this.koodi = koodi;
    }

    public String getKoodi() {
        return this.koodi;
    }
}
</pre>

<p>Lueteltua tyyppiä <code>Vari</code> voidaan käyttää esimerkiksi seuraavasti:</p>
<pre class="sh_java">
    System.out.println(Vari.VIHREA.getKoodi());
</pre>

<pre>
#00FF00
</pre>


<div class="tehtavat">
<div class="tehtava">
<h3>Elokuvien suosittelija</h3>

<p>Hiljattain Suomeen rantautunut <a href="https://signup.netflix.com/" target="_blank">Netflix</a> lupasi lokakuussa 2006 miljoona dollaria henkilölle tai ryhmälle, joka kehittäisi ohjelman, joka on 10% parempi elokuvien suosittelussa kuin heidän oma ohjelmansa. Kilpailu ratkesi syyskuussa 2009 (<a href="http://www.netflixprize.com/" target="_blank">http://www.netflixprize.com/</a>).</p>

<p>Rakennetaan tässä tehtävässä ohjelma elokuvien suositteluun. Alla on sen toimintaesimerkki:</p>

<pre class="sh_java">
    ArvioRekisteri arviot = new ArvioRekisteri();

    Elokuva tuulenViemaa = new Elokuva("Tuulen viemää");
    Elokuva hiljaisetSillat = new Elokuva("Hiljaiset sillat");
    Elokuva eraserhead = new Elokuva("Eraserhead");

    Henkilo matti = new Henkilo("Matti");
    Henkilo pekka = new Henkilo("Pekka");
    Henkilo mikke = new Henkilo("Mikke");
    Henkilo thomas = new Henkilo("Thomas");

    arviot.lisaaArvio(matti, tuulenViemaa, Arvio.HUONO);
    arviot.lisaaArvio(matti, hiljaisetSillat, Arvio.HYVA);
    arviot.lisaaArvio(matti, eraserhead, Arvio.OK);

    arviot.lisaaArvio(pekka, tuulenViemaa, Arvio.OK);
    arviot.lisaaArvio(pekka, hiljaisetSillat, Arvio.HUONO);
    arviot.lisaaArvio(pekka, eraserhead, Arvio.VALTTAVA);

    arviot.lisaaArvio(mikke, eraserhead, Arvio.HUONO);


    Suosittelija suosittelija = new Suosittelija(arviot);
    System.out.println(thomas + " suositus: " +
            suosittelija.suositteleElokuva(thomas));
    System.out.println(mikke + " suositus: " +
            suosittelija.suositteleElokuva(mikke));
</pre>

<pre>
Thomas suositus: Hiljaiset sillat
Mikke suositus: Tuulen viemää
</pre>

<p>Ohjelma osaa suositella elokuvia niiden yleisen arvion perusteella, sekä henkilökohtaisten henkilön antaminen arvioiden perusteella. Lähdetään rakentamaan ohjelmaa.</p>

<h4>Henkilo ja Elokuva</h4>

<p>Luo pakkaus <code>suosittelija.domain</code> ja lisää sinne luokat <code>Henkilo</code> ja <code>Elokuva</code>. Kummallakin luokalla on julkinen konstruktori <code>public <em>Luokka</em>(String nimi)</code>, sekä metodi <code>public String getNimi()</code>, joka palauttaa konstruktorissa saadun nimen.</p>

<pre class="sh_java">
    Henkilo henkilo = new Henkilo("Pekka");
    Elokuva elokuva = new Elokuva("Eraserhead");

    System.out.println(henkilo.getNimi() + " ja " + elokuva.getNimi());
</pre>

<pre>
Pekka ja Eraserhead
</pre>

<p>Lisää luokille myös <code>public String toString()</code>-metodi, joka palauttaa konstruktorissa parametrina annetun nimen, sekä korvaa metodit <code>equals</code> ja <code>hashCode</code>.</p>

<p>
Korvaa <code>equals</code> siten että samuusvertailu tapahtuu oliomuuttujan <code>nimi</code> perusteella. Katso mallia luvusta 45.1. Luvussa 45.2. on ohje metodin <code>hashCode</code> korvaamiselle. Ainakin HashCode kannattaa generoida automaattisesti luvun lopussa olevan ohjeen mukaan:</p>

<p>
<em>
NetBeans tarjoaa metodien equals ja hashCode automaattisen luonnin. Voit valita valikosta Source -> Insert Code, ja valita aukeavasta listasta equals() and hashCode(). Tämän jälkeen NetBeans kysyy oliomuuttujat joita metodeissa käytetään.</em>
</p>

<h4>Arvio</h4>

<p>Luo pakkaukseen <code>suosittelija.domain</code> lueteltu tyyppi <code>Arvio</code>. Enum-luokalla <code>Arvio</code> on julkinen metodi <code>public int getArvo()</code>, joka palauttaa arvioon liittyvän arvon. Arviotunnusten ja niihin liittyvien arvosanojen tulee olla seuraavat:</p>

<p>
<table style="padding-left:2em">
  <tr><th>Tunnus</th><th>Arvo</th></tr>
  <tr><td>HUONO</td><td>-5</td></tr>
  <tr><td>VALTTAVA</td><td>-3</td></tr>
  <tr><td>EI_NAHNYT</td><td>0</td></tr>
  <tr><td>NEUTRAALI</td><td>1</td></tr>
  <tr><td>OK</td><td>3</td></tr>
  <tr><td>HYVA</td><td>5</td></tr>
</table>
</p>

<p>Luokkaa voi käyttää seuraavasti:</p>
<pre class="sh_java">
    Arvio annettu = Arvio.HYVA;
    System.out.println("Arvio " + annettu + ", arvo " + annettu.getArvo());
    annettu = Arvio.NEUTRAALI;
    System.out.println("Arvio " + annettu + ", arvo " + annettu.getArvo());
</pre>

<pre>
Arvio HYVA, arvo 5
Arvio NEUTRAALI, arvo 1
</pre>

<h4>ArvioRekisteri, osa 1</h4>

<p>Aloitetaan arvioiden varastointiin liittyvän palvelun toteutus.</p>

<p>Luo pakkaukseen <code>suosittelija</code> luokka <code>ArvioRekisteri</code>, jolla on konstruktori <code>public ArvioRekisteri()</code> sekä seuraavat metodit:</p>

<ul>
  <li><code>public void lisaaArvio(Elokuva elokuva, Arvio arvio)</code> lisää arviorekisteriin parametrina annetulle elokuvalle uuden arvion. Samalla elokuvalla voi olla useita samanlaisiakin arvioita.</li>
  <li><code>public List&lt;Arvio&gt; annaArviot(Elokuva elokuva)</code> palauttaa elokuvalle lisätyt arviot listana.</li>
  <li><code>public Map&lt;Elokuva, List&lt;Arvio&gt;&gt; elokuvienArviot()</code> palauttaa mapin, joka sisältää arvioidut elokuvat avaimina. Jokaiseen elokuvaan liittyy lista, joka sisältää elokuvaan lisatyt arviot.</li>
</ul>

<p>Testaa metodien toimintaa seuraavalla lähdekoodilla:</p>

<pre class="sh_java">
    Elokuva hiljaisetSillat = new Elokuva("Hiljaiset sillat");
    Elokuva eraserhead = new Elokuva("Eraserhead");

    ArvioRekisteri rekisteri = new ArvioRekisteri();
    rekisteri.lisaaArvio(eraserhead, Arvio.HUONO);
    rekisteri.lisaaArvio(eraserhead, Arvio.HUONO);
    rekisteri.lisaaArvio(eraserhead, Arvio.HYVA);

    rekisteri.lisaaArvio(hiljaisetSillat, Arvio.HYVA);
    rekisteri.lisaaArvio(hiljaisetSillat, Arvio.OK);

    System.out.println("Kaikki arviot: " + rekisteri.elokuvienArviot());
    System.out.println("Arviot Eraserheadille: " + rekisteri.annaArviot(eraserhead));
</pre>

<pre>
Kaikki arviot: {Hiljaiset sillat=[HYVA, OK], Eraserhead=[HUONO, HUONO, HYVA]}
Arviot Eraserheadille: [HUONO, HUONO, HYVA]
</pre>


<h4>ArvioRekisteri, osa 2</h4>

<p>Lisätään seuraavaksi mahdollisuus henkilökohtaisten arvioiden lisäämiseen.</p>

<p>Lisää luokkaan <code>ArvioRekisteri</code> seuraavat metodit:</p>

<ul>
  <li><code>public void lisaaArvio(Henkilo henkilo, Elokuva elokuva, Arvio arvio)</code> lisää parametrina annetulle elokuvalle tietyn henkilön tekemän arvion. Sama henkilö voi arvioida tietyn elokuvan vain kertaalleen. Henkilön tekemä arvio tulee myös lisätä kaikkiin elokuviin liittyviin arvioihin.</li>
  <li><code>public Arvio haeArvio(Henkilo henkilo, Elokuva elokuva)</code> palauttaa parametrina annetun henkilön tekemän arvion parametrina annetulle elokuvalle. Jos henkilö ei ole arvioinut kyseistä elokuvaa, palauta arvio <code>Arvio.EI_NAHNYT</code>.</li>
 <li><code>public Map&lt;Elokuva, Arvio&gt; annaHenkilonArviot(Henkilo henkilo)</code> palauttaa hajautustaulun, joka sisältää henkilön tekemät arviot. Hajautustaulun avaimena on arvioidut elokuvat, arvoina arvioituihin elokuviin liittyvät arviot. Jos henkilö ei ole arvioinut yhtään elokuvaa, palautetaan tyhjä hajautustaulu.</li>
 <li><code>public List&lt;Henkilo&gt; arvioijat()</code> palauttaa listan henkilöistä jotka ovat arvioineet elokuvia.</li></ul>

<p>Henkilöiden tekemät arviot kannattanee tallentaa hajautustauluun, jossa avaimena on henkilö. Arvona hajautustaulussa on toinen hajautustaulu, jossa avaimena on elokuva ja arvona arvio.</p>

<p>Testaa paranneltua <code>ArvioRekisteri</code>-luokkaa seuraavalla lähdekoodipätkällä:</p>

<pre class="sh_java">
    ArvioRekisteri arviot = new ArvioRekisteri();

    Elokuva tuulenViemaa = new Elokuva("Tuulen viemää");
    Elokuva eraserhead = new Elokuva("Eraserhead");

    Henkilo matti = new Henkilo("Matti");
    Henkilo pekka = new Henkilo("Pekka");

    arviot.lisaaArvio(matti, tuulenViemaa, Arvio.HUONO);
    arviot.lisaaArvio(matti, eraserhead, Arvio.OK);

    arviot.lisaaArvio(pekka, tuulenViemaa, Arvio.OK);
    arviot.lisaaArvio(pekka, eraserhead, Arvio.OK);

    System.out.println("Arviot Eraserheadille: " + arviot.annaArviot(eraserhead));
    System.out.println("Matin arviot: " + arviot.annaHenkilonArviot(matti));
    System.out.println("Arvioijat: " + arviot.arvioijat());
</pre>

<pre>
Arviot Eraserheadille: [OK, OK]
Matin arviot: {Tuulen viemää=HUONO, Eraserhead=OK}
Arvioijat: [Pekka, Matti]
</pre>

<p>Luodaan seuraavaksi muutama apuluokka arviointien helpottamiseksi.</p>

<h4>HenkiloComparator</h4>

<p>Luo pakkaukseen <code>suosittelija.comparator</code> luokka <code>HenkiloComparator</code>. Luokan <code>HenkiloComparator</code> tulee toteuttaa rajapinta <code>Comparator&lt;Henkilo&gt;</code>, ja sillä pitää olla konstruktori <code>public HenkiloComparator(Map&lt;Henkilo, Integer&gt; henkiloidenSamuudet)</code>. Luokkaa <code>HenkiloComparator</code> käytetään myöhemmin henkilöiden järjestämiseen henkilöön liittyvän luvun perusteella.</p>

<p>HenkiloComparator-luokan tulee mahdollistaa henkilöiden järjestäminen henkilöön liittyvän luvun perusteella.</p>

<p>Testaa luokan toimintaa seuraavalla lähdekoodilla:</p>

<pre class="sh_java">
    Henkilo matti = new Henkilo("Matti");
    Henkilo pekka = new Henkilo("Pekka");
    Henkilo mikke = new Henkilo("Mikke");
    Henkilo thomas = new Henkilo("Thomas");

    Map&lt;Henkilo, Integer&gt; henkiloidenSamuudet = new HashMap&lt;Henkilo, Integer&gt;();
    henkiloidenSamuudet.put(matti, 42);
    henkiloidenSamuudet.put(pekka, 134);
    henkiloidenSamuudet.put(mikke, 8);
    henkiloidenSamuudet.put(thomas, 82);

    List&lt;Henkilo&gt; henkilot = Arrays.asList(matti, pekka, mikke, thomas);
    System.out.println("Henkilöt ennen järjestämistä: " + henkilot);

    Collections.sort(henkilot, new HenkiloComparator(henkiloidenSamuudet));
    System.out.println("Henkilöt järjestämisen jälkeen: " + henkilot);
</pre>

<pre>
Henkilöt ennen järjestämistä: [Matti, Pekka, Mikke, Thomas]
Henkilöt järjestämisen jälkeen: [Pekka, Thomas, Matti, Mikke]
</pre>

<h4>ElokuvaComparator</h4>


<p>Luo pakkaukseen <code>suosittelija.comparator</code> luokka <code>ElokuvaComparator</code>. Luokan <code>ElokuvaComparator</code> tulee toteuttaa rajapinta <code>Comparator&lt;Elokuva&gt;</code>, ja sillä pitää olla konstruktori <code>public ElokuvaComparator(Map&lt;Elokuva, List&lt;Arvio&gt;&gt; arviot)</code>. Luokkaa <code>ElokuvaComparator</code> käytetään myöhemmin elokuvien järjestämiseen niiden arvioiden perusteella.</p>

<p>ElokuvaComparator-luokan tulee tarjota mahdollisuus elokuvien järjestäminen niiden saamien arvosanojen keskiarvon perusteella. Korkeimman keskiarvon saanut elokuva tulee ensimmäisenä, matalimman keskiarvon saanut viimeisenä.</p>

<p>Testaa luokan toimintaa seuraavalla lähdekoodilla:</p>

<pre class="sh_java">
    ArvioRekisteri arviot = new ArvioRekisteri();

    Elokuva tuulenViemaa = new Elokuva("Tuulen viemää");
    Elokuva hiljaisetSillat = new Elokuva("Hiljaiset sillat");
    Elokuva eraserhead = new Elokuva("Eraserhead");

    Henkilo matti = new Henkilo("Matti");
    Henkilo pekka = new Henkilo("Pekka");
    Henkilo mikke = new Henkilo("Mikke");

    arviot.lisaaArvio(matti, tuulenViemaa, Arvio.HUONO);
    arviot.lisaaArvio(matti, hiljaisetSillat, Arvio.HYVA);
    arviot.lisaaArvio(matti, eraserhead, Arvio.OK);

    arviot.lisaaArvio(pekka, tuulenViemaa, Arvio.OK);
    arviot.lisaaArvio(pekka, hiljaisetSillat, Arvio.HUONO);
    arviot.lisaaArvio(pekka, eraserhead, Arvio.VALTTAVA);

    arviot.lisaaArvio(mikke, eraserhead, Arvio.HUONO);

    Map&lt;Elokuva, List&lt;Arvio&gt;&gt; elokuvienArviot = arviot.elokuvienArviot();

    List&lt;Elokuva&gt; elokuvat = Arrays.asList(tuulenViemaa, hiljaisetSillat, eraserhead);
    System.out.println("Elokuvat ennen järjestämistä: " + elokuvat);

    Collections.sort(elokuvat, new ElokuvaComparator(elokuvienArviot));
    System.out.println("Elokuvat järjestämisen jälkeen: " + elokuvat);
</pre>

<pre>
Elokuvat ennen järjestämistä: [Tuulen viemää, Hiljaiset sillat, Eraserhead]
Elokuvat järjestämisen jälkeen: [Hiljaiset sillat, Tuulen viemää, Eraserhead]
</pre>


<h4>Suosittelija, osa 1</h4>

<p>Toteuta pakkaukseen <code>suosittelija</code> luokka <code>Suosittelija</code>. Luokan <code>Suosittelija</code> konstruktori saa parametrinaan <code>ArvioRekisteri</code>-tyyppisen olion. Suosittelija käyttää arviorekisterissä olevia arvioita suositusten tekemiseen.</p>

<p>Toteuta luokalle metodi <code>public Elokuva suositteleElokuva(Henkilo henkilo)</code>, joka suosittelee henkilölle elokuvia.

Toteuta metodi ensin siten, että se suosittelee aina elokuvaa, jonka arvioiden arvosanojen keskiarvo on suurin. Vinkki: Tarvitset parhaan elokuvan selvittämiseen ainakin aiemmin luotua <code>ElokuvaComparator</code>-luokkaa, luokan <code>ArvioRekisteri</code> metodia <code>public Map&lt;Elokuva, List&lt;Arvio&gt;&gt; elokuvienArviot()</code>, sekä listaa olemassaolevista elokuvista.</p>

<p>Testaa ohjelman toimimista seuraavalla lähdekoodilla:</p>

<pre class="sh_java">
    ArvioRekisteri arviot = new ArvioRekisteri();

    Elokuva tuulenViemaa = new Elokuva("Tuulen viemää");
    Elokuva hiljaisetSillat = new Elokuva("Hiljaiset sillat");
    Elokuva eraserhead = new Elokuva("Eraserhead");

    Henkilo matti = new Henkilo("Matti");
    Henkilo pekka = new Henkilo("Pekka");
    Henkilo mikke = new Henkilo("Mikael");

    arviot.lisaaArvio(matti, tuulenViemaa, Arvio.HUONO);
    arviot.lisaaArvio(matti, hiljaisetSillat, Arvio.HYVA);
    arviot.lisaaArvio(matti, eraserhead, Arvio.OK);

    arviot.lisaaArvio(pekka, tuulenViemaa, Arvio.OK);
    arviot.lisaaArvio(pekka, hiljaisetSillat, Arvio.VALTTAVA);
    arviot.lisaaArvio(pekka, eraserhead, Arvio.VALTTAVA);

    Suosittelija suosittelija = new Suosittelija(arviot);
    Elokuva suositeltu = suosittelija.suositteleElokuva(mikke);
    System.out.println("Mikaelille suositeltu elokuva oli: " + suositeltu);
</pre>

<pre>
Mikaelille suositeltu elokuva oli: Hiljaiset sillat
</pre>

<p>Nyt tekemämme ensimmäinen vaihe toimii oikein ainoastaan henkilöille, jotka eivät ole vielä arvostelleet yhtään elokuvaa. Heidän elokuvamaustaanhan on mahdoton sanoa mitään ja paras arvaus on suositella heille keskimäärin parhaan arvosanan saanutta elokuvaa. </p>

<h4>Suosittelija, osa 2</h4>

<p><em>Huom! Tehtävä on haastava. Kannattaa tehdä ensin muut tehtävät ja palata tähän myöhemmin. Voit palauttaa tehtäväsarjan TMC:hen vaikket saakaan tätä tehtävää tehdyksi, aivan kuten muidenkin tehtävien kohdalla.</em></p>

<p>Valitettavasti tämän osan virhediagnostiikkakaan ei ole samaa luokkaa kuin edellisissä kohdissa.</p>

<p>Jos henkilöt ovat lisänneet omia suosituksia suosituspalveluun, tiedämme jotain heidän elokuvamaustaan. Laajennetaan suosittelijan toiminnallisuutta siten, että se luo henkilökohtaisen suosituksen jos henkilö on jo arvioinut elokuvia. Edellisessä osassa toteutettu toiminnallisuus tulee säilyttää: Jos henkilö ei ole arvioinut yhtäkään elokuvaa, hänelle suositellaan elokuva arvosanojen perusteella.</p>

<p>Henkilökohtaiset suositukset perustuvat henkilön tekemien arvioiden samuuteen muiden henkilöiden tekemien arvioiden kanssa. Pohditaan seuraavaa taulukkoa, missä ylärivillä on elokuvat, ja vasemmalla on arvioita tehneet henkilöt. Taulukon solut kuvaavat annettuja arvioita.</p>

<p>
    <table style="padding-left:2em">
      <tr><th>Henkilo \ Elokuva</th><td>Tuulen viemää</td><td>Hiljaiset sillat</td><td>Eraserhead</td><td>Blues Brothers</td></tr>
      <tr><td>Matti</td><td>HUONO (-5)</td><td>HYVA (5)</td><td>OK (3)</td><td>-</td></tr>
      <tr><td>Pekka</td><td>OK (3)</td><td>-</td><td>HUONO (-5)</td><td>VALTTAVA (-3)</td></tr>
      <tr><td>Mikael</td><td>-</td><td>-</td><td>HUONO (-5)</td><td>-</td></tr>
      <tr><td>Thomas</td><td>-</td><td>HYVA (5)</td><td>-</td><td>HYVA (5)</td></tr>
    </table>
</p>

<p>Kun haluamme hakea Mikaelille sopivaa elokuvaa, tutkimme Mikaelin samuutta kaikkien muiden arvioijien kesken. Samuus lasketaan arvioiden perusteella: samuus on kummankin katsomien elokuvien arvioiden tulojen summa. Esimerkiksi Mikaelin ja Thomasin samuus on 0, koska Mikael ja Thomas eivät ole katsoneet yhtäkään samaa elokuvaa.</p>

<p>Mikaelin ja Pekan samuutta laskettaessa yhteisten elokuvien tulojen summa olisi 25. Mikael ja Pekka ovat katsoneet vain yhden yhteisen elokuvan, ja kumpikin antaneet sille arvosanan huono (-5).</p>

<pre>
-5 * -5 = 25
</pre>

<p>Mikaelin ja Matin samuus on -15. Mikael ja Matti ovat myös katsoneet vain yhden yhteisen elokuvan. Mikael antoi elokuvalle arvosanan huono (-5), Matti antoi sille arvosanan ok (3).</p>

<pre>
-5 * 3 = -15
</pre>

<p>Näiden perusteella Mikaelille suositellaan elokuvia Pekan elokuvamaun mukaan: suosituksena on elokuva Tuulen viemää.</p>


<p>Kun taas haluamme hakea Matille sopivaa elokuvaa, tutkimme Matin samuutta kaikkien muiden arvioijien kesken. Matti ja Pekka ovat katsoneet kaksi yhteistä elokuvaa. Matti antoi Tuulen viemälle arvosanan huono (-5), Pekka arvosanan OK (3). Elokuvalle Eraserhead Matti antoi arvosanan OK (3), Pekka arvosanan huono (-5). Matin ja Pekan samuus on siis -30.</p>

<pre>
-5 * 3 + 3 * -5 = -30
</pre>

<p>Matin ja Mikaelin samuus on edellisestä laskusta tiedetty -15. Samuudet ovat symmetrisia.</p>

<p>Matti ja Thomas ovat katsoneet Tuulen viemää, ja kumpikin antoi sille arvosanan hyvä (5). Matin ja Thomaksen samuus on siis 25.</p>

<pre>
5 * 5 = 25
</pre>

<p>Matille tulee siis suositella elokuvia Thomaksen elokuvamaun mukaan: suosituksena olisi Blues Brothers.</p>

<p>Toteuta yllä kuvattu suosittelumekanismi. Jos henkilölle ei löydy yhtään suositeltavaa elokuvaa, tai henkilö, kenen elokuvamaun mukaan elokuvia suositellaan on arvioinut elokuvat joita henkilö ei ole vielä katsonut huonoiksi, välttäviksi tai neutraaleiksi, palauta metodista <code>suositteleElokuva</code> arvo <code>null</code>. Edellisessä tehtävässä määritellyn lähestymistavan tulee toimia jos henkilö ei ole lisännyt yhtäkään arviota.</p>

<p>Älä suosittele elokuvia, jonka henkilö on jo nähnyt.</p>

<p>Voit testata ohjelmasi toimintaa seuraavalla lähdekoodilla:</p>

<pre class="sh_java">
    ArvioRekisteri arviot = new ArvioRekisteri();

    Elokuva tuulenViemaa = new Elokuva("Tuulen viemää");
    Elokuva hiljaisetSillat = new Elokuva("Hiljaiset sillat");
    Elokuva eraserhead = new Elokuva("Eraserhead");
    Elokuva bluesBrothers = new Elokuva("Blues Brothers");

    Henkilo matti = new Henkilo("Matti");
    Henkilo pekka = new Henkilo("Pekka");
    Henkilo mikke = new Henkilo("Mikael");
    Henkilo thomas = new Henkilo("Thomas");
    Henkilo arto = new Henkilo("Arto");

    arviot.lisaaArvio(matti, tuulenViemaa, Arvio.HUONO);
    arviot.lisaaArvio(matti, hiljaisetSillat, Arvio.HYVA);
    arviot.lisaaArvio(matti, eraserhead, Arvio.OK);

    arviot.lisaaArvio(pekka, tuulenViemaa, Arvio.OK);
    arviot.lisaaArvio(pekka, eraserhead, Arvio.HUONO);
    arviot.lisaaArvio(pekka, bluesBrothers, Arvio.VALTTAVA);

    arviot.lisaaArvio(mikke, eraserhead, Arvio.HUONO);

    arviot.lisaaArvio(thomas, bluesBrothers, Arvio.HYVA);
    arviot.lisaaArvio(thomas, hiljaisetSillat, Arvio.HYVA);

    Suosittelija suosittelija = new Suosittelija(arviot);
    System.out.println(thomas + " suositus: " + suosittelija.suositteleElokuva(thomas));
    System.out.println(mikke + " suositus: " + suosittelija.suositteleElokuva(mikke));
    System.out.println(matti + " suositus: " + suosittelija.suositteleElokuva(matti));
    System.out.println(arto + " suositus: " + suosittelija.suositteleElokuva(arto));
</pre>

<pre>
Thomas suositus: Eraserhead
Mikael suositus: Tuulen viemää
Matti suositus: Blues Brothers
Arto suositus: Hiljaiset sillat
</pre>

<p>Miljoona käsissä? Ei ehkä vielä. Kursseilla Johdatus tekoälyyn ja Johdatus koneoppimiseen opitaan lisää tekniikoita oppivien järjestelmien rakentamiseen.</p>

</div>
</div>
<h3>Vaihteleva määrä parametreja metodille</h3>

<p>Olemme tähän mennessä luoneet metodimme siten, että niiden parametrien määrät ovat olleet selkeästi määritelty. Java tarjoaa tavan antaa metodille rajoittamattoman määrän määrätyntyyppisiä parametreja asettamalla metodimäärittelyssä parametrin tyypille kolme pistettä perään. Esimerkiksi metodille <code>public int summa(int... luvut)</code> voi antaa summattavaksi niin monta <code>int</code>-tyyppistä kokonaislukua kuin käyttäjä haluaa. Metodin sisällä parametrin arvoja voi käsitellä taulukkona.</p>

<pre class="sh_java">
    public int summa(int... luvut) {
        int summa = 0;
        for (int i = 0; i &lt; luvut.length; i++) {
            summa += luvut[i];
        }
        return summa;
    }
</pre>

<pre class="sh_java">
    System.out.println(summa(3, 5, 7, 9));  // luvut = {3, 5, 7, 9}
    System.out.println(summa(1, 2));        // luvut = {1, 2}
</pre>

<pre>
24
3
</pre>

<p>Huomaa yllä miten parametrimäärittely <code>int... luvut</code> johtaa siihen, että metodin sisällä näkyy taulukkotyyppinen muuttuja <code>luvut</code>.</p>

<p>Metodille voi määritellä vain yhden parametrin joka saa rajattoman määrän arvoja, ja sen tulee olla metodimäärittelyn viimeinen parametri. Esimerkiksi:</p>

<pre class="sh_java">
    public void tulosta(String... merkkijonot, int kertaa) // ei sallittu!
    public void tulosta(int kertaa, String... merkkijonot) // sallittu!
</pre>

<p>Ennalta määrittelemätöntä parametrien arvojen määrää käytetään esimerkiksi silloin, kun halutaan tarjota rajapinta, joka ei rajoita sen käyttäjää tiettyyn parametrien määrään. Vaihtoehtoinen lähestymistapa on metodimäärittely, jolla on parametrina tietyn tyyppinen lista. Tällöin oliot voidaan asettaa listaan ennen metodikutsua, ja kutsua metodia antamalla lista sille parametrina.</p>

<div class="tehtavat">
<div class="tehtava">
<h3>JoustavatHakuehdot</h3>

<p>Muutamassa tehtävässä (mm. ohpen kirjasto ja ohjan sanatutkimus) törmäsimme tilanteeseen, jossa jouduimme filtteröimään listalta jotain hakuehtoa vastaavat oliot. Esim. sanatutkimuksessa metodit <code>zSisaltava, lLoppuiset, palindromit, kaikkiVoksSis</code> tekivät oleellisesti saman asian: ne kävivät läpi tiedoston sisällön sana kerrallaan ja tarkastivat jokaisen sanan kohdalla päteekö sille tietty ehto, ja jos pätee, ottivat sanan talteen. Koska kaikkien metodien ehto oli erilainen, ei toisteisuutta tehtävissä osattu poistaa vaan kaikkien koodi oli ehtoa vaille "copypastea". </p>

<p>Tässä tehtävässä teemme ohjelman, jonka avulla on mahdollista filtteröidä rivejä <a href="http://www.gutenberg.org/">Project Gutenbergin</a> sivuilta löytyvistä kirjoista. Seuraavassa esimerkkinä Dostojevskin Rikos ja rangaistus. Haluamme, että erilaisia filtteröintiehtoja on monelaisia ja että filtteröinti voi tapahtua myös eri ehtojen kombinaationa. Ohjelman rakenteen pitää myös mahdollistaa uusien ehtojen lisääminen myöhemmin.</p>


<p>Sopiva ratkaisu tilanteeseen on jokaisen filtteröintiehdon määritteleminen omana rajapinnan <code>Ehto</code> toteuttavana oliona. Seuraavassa rajapinnan määritelmä:</p>

<pre class="sh_java">
public interface Ehto {
    boolean toteutuu(String rivi);
}
</pre>

<p>Seuraavassa eräs rajapinnan toteuttava filtteriluokka:</p>

<pre class="sh_java">
public class SisaltaaSanan implements Ehto {

    String sana;

    public SisaltaaSanan(String sana) {
        this.sana = sana;
    }

    @Override
    public boolean toteutuu(String rivi) {
        return rivi.contains(sana);
    }
}
</pre>

<p>Luokan oliot ovat siis hyvin yksinkertaisia, ne muistavat konstruktorin parametrina annetun sanan. Olion ainoalta metodilta voi kysyä toteutuuko ehto parametrina olevalle merkkijonolle, ja ehdon toteutuminen tarkoittaa olion tapauksessa sisältääkö merkkijono olion muistaman sanan.</p>

<p>Tehtäväpohjan mukana saat valmiina luokan <code>GutenbergLukija</code>, jonka avulla voit tutkia kirjojen rivejä filtteröitynä parametrina annetun hakuehdon perusteella:</p>

<pre class="sh_java">
public class GutenbergLukija {

    private List&lt;String&gt; sanat;

    public GutenbergLukija(String osoite) throws IllegalArgumentException {
        // kirjan verkosta hakeva koodi
    }

    public List&lg;String&gt; rivitJoilleVoimassa(Ehto ehto){
        List&lg;String&gt; ehdonTayttavat = new ArrayList&lg;String&gt;();

        for (String rivi : sanat) {
            if ( ehto.toteutuu(rivi)) {
                ehdonTayttavat.add(rivi);
            }
        }

        return ehdonTayttavat;
    }
}
</pre>

<p>Seuraavassa tulostetaan Rikoksesta ja rangaistuksesta kaikki rivit, joilla esiintyy sana "beer":</p>

<pre class="sh_java">
public static void main(String[] args) {
    String osoite = "http://www.gutenberg.myebook.bg/2/5/5/2554/2554-8.txt";
    GutenbergLukija kirja = new GutenbergLukija(osoite);

    Ehto ehto = new SisaltaaSanan("beer");

    for (String rivi : kirja.rivitJoilleVoimassa(ehto)) {
        System.out.println(rivi);
    }
}
</pre>


<p><b>Huom:</b> Project Gutenbergin sivuilla olevat tekstit ovat tarkoitettu vain ihmisten luettaviksi. Jos tekstejä haluaa lukea koneellisesti eli esim. <em>GutenbergLukijalla</em>, on kirjan sivulta, esim. <a href="http://www.gutenberg.org/ebooks/2554">http://www.gutenberg.org/ebooks/2554</a> mentävä alakulmassa olevaan linkin <em>mirror sites</em> takaa löytyvälle sivulle, esim. bulgarialaiselle e-book Ltd:n sivulle ja luettava kirja sieltä löytyvästä osoitteesta.</p>

<h4>Kaikki sanat</h4>

<p>Tee rajapinnan <code>ehto</code> toteuttava luokka <code>KaikkiRivit</code>, joka kelpuuttaa jokaisen rivin. Tämä ja muutkin tämän tehtävän luokat tulee toteuttaa pakkaukseen <code>lukija.ehdot</code>.</p>

<pre class="sh_java">
public static void main(String[] args) {
    String osoite = "http://www.gutenberg.myebook.bg/2/5/5/2554/2554-8.txt";
    GutenbergLukija kirja = new GutenbergLukija(osoite);

    Ehto ehto = new KaikkiRivit();

    for (String rivi : kirja.rivitJoilleVoimassa(ehto)) {
        System.out.println(rivi);
    }
}
</pre>

<h4>Loppuu huuto- tai kysymysmerkkiin</h4>

<p>Tee rajapinnan <code>ehto</code> toteuttava luokka <code>LoppuuHuutoTaiKysymysmerkkiin</code>, joka kelpuuttaa ne rivit, joiden viimeinen merkki on huuto- tai kysymysmerkki.</p>

<pre class="sh_java">
public static void main(String[] args) {
    String osoite = "http://www.gutenberg.myebook.bg/2/5/5/2554/2554-8.txt";
    GutenbergLukija kirja = new GutenbergLukija(osoite);

    Ehto ehto = new LoppuuHuutoTaiKysymysmerkkiin();

    for (String rivi : kirja.rivitJoilleVoimassa(ehto)) {
        System.out.println(rivi);
    }
}
</pre>

<p><strong>Muistutus:</strong> merkkien vertailu Javassa tapahtuu == operaattorilla:</p>

<pre class="sh_java">
String nimi = "pekka";

// HUOM: 'p' on merkki eli char p, "p" taas merkkojono, jonka ainoa merkki on p
if ( nimi.charAt(0) == 'p' ) {
    System.out.println("alussa p");
} else {
    System.out.println("alussa jokin muu kuin p");
}
</pre>

<h4>Pituus vähintään</h4>

<p>Tee rajapinnan <code>ehto</code> toteuttava luokka <code>PituusVahintaan</code>, jonka oliot kelpuuttavat ne rivit, joiden pituus on vähintään olion konstruktorin parametrina annettu luku.</p>

<pre class="sh_java">
public static void main(String[] args) {
    String osoite = "http://www.gutenberg.myebook.bg/2/5/5/2554/2554-8.txt";
    GutenbergLukija kirja = new GutenbergLukija(osoite);

    Ehto ehto = new PituusVahintaan(40);

    for (String rivi : kirja.rivitJoilleVoimassa(ehto)) {
        System.out.println(rivi);
    }
}
</pre>

<h4>molemmat</h4>

<p>Tee rajapinnan <code>ehto</code> toteuttava luokka <code>Molemmat</code>. Luokan oliot saavat konstruktorin parametrina kaksi rajapinnan <code>Ehto</code> toteuttavaa olioa. <code>Molemmat</code>-olio kelpuuttavaa ne rivit, jotka sen kummatkin konstruktorissa saamansa ehdot kelpuuttavat. Seuraavassa tulostetaan kaikki huuto- tai kysymysmerkkiin loppuvat rivit, jotka sisältävät sanan "beer".
</p>

<pre class="sh_java">
public static void main(String[] args) {
    String osoite = "http://www.gutenberg.myebook.bg/2/5/5/2554/2554-8.txt";
    GutenbergLukija kirja = new GutenbergLukija(osoite);

    Ehto ehto = new Molemmat(
                    new LoppuuHuutoTaiKysymysmerkkiin(),
                    new SisaltaaSanan("beer")
                );

    for (String rivi : kirja.rivitJoilleVoimassa(ehto)) {
        System.out.println(rivi);
    }
}
</pre>

<h4>negaatio</h4>

<p>Tee rajapinnan <code>ehto</code> toteuttava luokka <code>Ei</code>. Luokan oliot saavat parametrina rajapinnan <code>Ehto</code> toteuttavaavan olion. <code>Ei</code>-olio kelpuuttaa ne rivit, joita sen parametrina saama ehto ei kelpuuta.
Seuraavassa tulostetaan rivit, joiden pituus vähemmän kuin 10.
</p>

<pre class="sh_java">
public static void main(String[] args) {
    String osoite = "http://www.gutenberg.myebook.bg/2/5/5/2554/2554-8.txt";
    GutenbergLukija kirja = new GutenbergLukija(osoite);

    Ehto ehto = new Ei( new PituusVahintaan(10) );

    for (String rivi : kirja.rivitJoilleVoimassa(ehto)) {
        System.out.println(rivi);
    }
}
</pre>

<h4>vähintään yksi</h4>

<p>Tee rajapinnan <code>ehto</code> toteuttava luokka <code>VahintaanYksi</code>. Luokan oliot saavat konstruktorin parametrina mielivaltaisen määrän rajapinnan <code>Ehto</code> toteuttavia olioita, konstruktorissa siis käytettävä vaihtuvanmittaista parametrilistaa. <code>VahintaanYksi</code>-oliot kelpuuttavat ne rivit, jotka ainakin yksi sen konstruktoriparametrina saamista ehdoista kelpuuttaa. Seuraavassa tulostetaan rivit, jotka sisältävät jonkun sanoista "beer", "milk" tai "oil".
</p>

<pre class="sh_java">
public static void main(String[] args) {
    String osoite = "http://www.gutenberg.myebook.bg/2/5/5/2554/2554-8.txt";
    GutenbergLukija kirja = new GutenbergLukija(osoite);

    Ehto ehto = new VahintaanYksi(
                    new SisaltaaSanan("beer"),
                    new SisaltaaSanan("milk"),
                    new SisaltaaSanan("oil")
                );

    for (String rivi : kirja.rivitJoilleVoimassa(ehto)) {
        System.out.println(rivi);
    }
}
</pre>

<p>Huomaa, että ehtoja voi kombinoida mielivaltaisesti. Seuraavassa ehto, joka hyväksyy rivit, joilla on vähintään yksi sanoista "beer", "milk" tai "oil" ja jotka ovat pituudeltaan 20-30 merkkiä.</p>

<pre class="sh_java">
    Ehto sanat = new VahintaanYksi(
                    new SisaltaaSanan("beer"),
                    new SisaltaaSanan("milk"),
                    new SisaltaaSanan("oil")
                );

    Ehto oikeaPituus = new Molemmat(
                         new PituusVahintaan(20),
                         new Ei( new PituusVahintaan(31))
                       );

    Ehto halutut = new Molemmat(sanat, oikeaPituus);
</pre>

</div>
</div>
<h3>StringBuilder</h3>

<p>Olemme tottuneet rakentamaan merkkijonoja seuraavaan tapaan:</p>

<pre class="sh_java">
    public static void main(String[] args) {
        int[] t = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};
        System.out.println(muotoile(t));
    }

    public static String muotoile(int[] t) {
        String mj = "{";

        for (int i = 0; i &lt; t.length; i++) {
            mj += t[i];
            if (i != t.length - 1) {
                mj += ", ";

            }
        }

        return mj + "}";
    }
</pre>

<p>Tulostus:</p>

<pre>
{1, 2, 3, 4, 5, 6, 7, 8, 9, 10}
</pre>

<p>Tapa on toimiva mutta ei kovin tehokas. Kuten muistamme, merkkijonot ovat <em>immutaabeleita</em> eli olioita joita ei voi muuttaa. Merkkijono-operaatioiden tuloksena onkin aina uusi merkkijono-olio. Eli edellisessäkin esimerkissä syntyi välivaiheena 10 merkkijono-olioa. Jos syötteen koko olisi isompi, alkaisi välivaiheena olevien olioiden luominen vaikuttaa ohjelman suoritusaikaan ikävällä tavalla.</p>

<div class="tehtavat">
<div class="tehtava">
<h3>String builder</h3>
<p>Edellisen kaltaisissa tilanteissa onkin parempi käyttää merkkijonon muodostamisessa <code>StringBuilder</code>-olioita. Toisin kuin Stringit, StringBuilderit eivät ole immutaabeleita, ja yhtä StringBuilderolioa voi muokata. Tutustu StringBuilderin API-kuvaukseen (löydät sen esim googlaamalla stringbuilder java api 6) ja muuta tehtäväpohjassa oleva metodi <code>public static String muotoile(int[] t)</code> toimimaan StringBuilderia käyttäen seuraavaan tapaan:</p>

<pre>
{
 1, 2, 3, 4,
 5, 6, 7, 8,
 9, 10
}
</pre>

<p>Eli aaltosulkeet tulevat omalle rivilleen. Taulukon alkioita tulostetaan 4 per rivi ja rivin ensimmäistä edeltää välilyönti. Pilkun jälkeen ennen seuraavaa numeroa tulee olla tasan yksi välilyönti.</p>

</div>
</div>

<h2>Loppuhuipennus</h2>

<p>Kurssi alkaa olla ohi ja on loppuhuipennuksen aika!</p>

<div class="tehtavat">
    <p class="mooc-pakollinen"></p>
<div class="tehtava pakollinen-hakuun">
<h3>Matopeli</h3>


<p>Tässä tehtävässä luodaan rakenteet ja osa toiminnallisuudesta seuraavannäköiseen matopeliin. Tehtävän palautettavassa versiossa tosin pelin väritys on erilainen, mato on musta, omena punainen ja pohja harmaa.</p>

    <p><img src="https://www.cs.helsinki.fi/group/java/k13/ohja/img-ohja/kali/170-matopeli.png"/></p>

<h4>Pala ja Omena</h4>

<p>Luo pakkaukseen <code>matopeli.domain</code> luokka <code>Pala</code>. Luokalla <code>Pala</code> on konstruktori <code>public Pala(int x, int y)</code>, joka saa palan sijainnin parametrina. Lisäksi luokalla <code>Pala</code> on seuraavat metodit.</p>

<ul>
  <li><code>public int getX()</code> palauttaa Palan konstruktorissa saadun x-koordinaatin.</li>
  <li><code>public int getY()</code> palauttaa Palan konstruktorissa saadun y-koordinaatin.</li>
  <li><code>public boolean osuu(Pala pala)</code> palauttaa true jos oliolla on sama x- ja y-koordinaatti kuin parametrina saadulla Pala-luokan ilmentymällä.</li>
  <li><code>public String toString()</code> palauttaa palan sijainnin muodossa <code>(x,y)</code>. Esim. <code>(5,2)</code> kun x-koordinaatin arvo on 5 ja y-koordinaatin arvo on 2.</li>
</ul>

<p>Toteuta pakkaukseen <code>matopeli.domain</code> myös luokka <code>Omena</code>. Peri luokalla Omena luokka <code>Pala</code>.</p>


<h4>Mato</h4>

<p>Toteuta pakkaukseen <code>matopeli.domain</code> luokka <code>Mato</code>. Luokalla <code>Mato</code> on konstruktori <code>public Mato(int alkuX, int alkuY, Suunta alkusuunta)</code>, joka luo uuden madon jonka suunta on parametrina annettu <code>alkusuunta</code>. Mato koostuu listasta <code>Pala</code>-luokan ilmentymiä. Huom: enum <code>Suunta</code> löytyy valmiina pakkauksesta <code>Matopeli</code>.</p>

<p>Mato luodaan yhden palan pituisena, mutta madon "aikuispituus" on kolme. Madon tulee kasvaa yhdellä aina kun se liikkuu. Kun madon pituus on kolme, se kasvaa isommaksi vain syödessään.</p>

<p>Toteuta madolle seuraavat metodit</p>

<ul>
  <li><code>public Suunta getSuunta()</code> palauttaa madon suunnan.</li>
  <li><code>public void setSuunta(Suunta suunta)</code> asettaa madolle uuden suunnan. Mato liikkuu uuteen suuntaan kun metodia <code>liiku</code> kutsutaan seuraavan kerran.</li>
  <li><code>public int getPituus()</code> palauttaa madon pituuden. Madon pituuden tulee olla sama kuin <code>getPalat()</code>-metodikutsun palauttaman listan alkioiden määrä.</li>
  <li><code>public List&lt;Pala&gt; getPalat()</code> palauttaa listan pala-olioita, joista mato koostuu. Palat ovat listalla järjestyksessä, siten että pää sijaitsee listan lopussa.</li>
  <li><code>public void liiku()</code> liikuttaa matoa yhden palan verran eteenpäin.</li>
  <li><code>public void kasva()</code> kasvattaa madon kokoa yhdellä. Madon kasvaminen tapahtuu seuraavan <code>liiku</code>-metodikutsun yhteydessä. Sitä seuraaviin liiku-kutsuihin kasvaminen ei enää vaikuta. Jos madon pituus on 1 tai 2 kun metodia kutsutaan, ei kutsulla saa olla mitään vaikutusta matoon.</li>
  <li><code>public boolean osuu(Pala pala)</code> tarkistaa osuuko mato parametrina annettuun palaan. Jos mato osuu palaan, eli joku madon pala osuu metodille parametrina annettuun palaan, tulee metodin palauttaa arvo <code>true</code>. Muuten metodi palauttaa arvon <code>false</code>.</li>
  <li><code>public boolean osuuItseensa()</code> tarkistaa osuuko mato itseensä. Jos mato osuu itseensä, eli joku sen pala osuu johonkin toiseen sen palaan, metodi palauttaa arvon <code>true</code>. Muuten metodi palauttaa arvon <code>false</code>.</li>
</ul>

<p>Metodien <code>public void kasva()</code> ja <code>public void liiku()</code> toiminnallisuus tulee toteuttaa siten, että mato kasvaa vasta seuraavalla liikkumiskerralla.

</p>

<p>Liikkuminen kannattaa toteuttaa siten, että madolle luodaan liikkuessa aina uusi pala. Uuden palan sijainti riippuu madon kulkusuunnasta: vasemmalle mennessä uuden palan sijainti on edellisen pääpalan sijainnista yksi vasemmalle, eli sen x-koordinaatti on yhtä pienempi. Jos uuden palan sijainti on edellisen pääpalan alapuolella, eli madon suunta on alas, tulee uuden palan y-koordinaatin olla yhtä isompi kuin pääpalan y-koordinaatti (käytämme siis piirtämisestä tuttua koordinaattijärjestelmää, jossa y-akseli on kääntynyt).</p>

<p>Liikkuessa uusi pala lisätään listan loppuun, ja poistetaan listan alussa oleva alkio. Uudesta palasta siis tulee madon "uusi pää" ja  jokaisen palan koordinaatteja ei tarvitse päivittää erikseen. Toteuta kasvaminen siten, että listan alussa olevaa palaa, eli "madon häntää" ei poisteta jos metodia <code>kasva</code> on juuri kutsuttu.</p>

<p>Huom! Kasvata matoa aina sen liikkuessa jos sen pituus on pienempi kuin 3.</p>

<pre class="sh_java">
        Mato mato = new Mato(5, 5, Suunta.OIKEA);
        System.out.println(mato.getPalat());
        mato.liiku();
        System.out.println(mato.getPalat());
        mato.liiku();
        System.out.println(mato.getPalat());
        mato.liiku();
        System.out.println(mato.getPalat());

        mato.kasva();
        System.out.println(mato.getPalat());
        mato.liiku();
        System.out.println(mato.getPalat());

        mato.setSuunta(Suunta.VASEN);
        System.out.println(mato.osuuItseensa());
        mato.liiku();
        System.out.println(mato.osuuItseensa());
</pre>

<pre>
[(5,5)]
[(5,5), (6,5)]
[(5,5), (6,5), (7,5)]
[(6,5), (7,5), (8,5)]
[(6,5), (7,5), (8,5)]
[(6,5), (7,5), (8,5), (9,5)]
false
true
</pre>

<h4>Matopeli, osa 1</h4>

<p>Muokataan seuraavaksi pakkauksessa <code>matopeli.peli</code> olevaa matopelin toiminnallisuutta kapseloivaa luokka <code>Matopeli</code>. Matopeli-luokka perii luokan <code>Timer</code>, joka tarjoaa ajastustoiminnallisuuden pelin päivittämiseen. Luokka <code>Timer</code> vaatii toimiakseen <code>ActionListener</code>-rajapinnan toteuttavan luokan. Olemme toteuttaneet luokalla <code>Matopeli</code> rajapinnan <code>ActionListener</code>.</p>

<p>Muokkaa matopelin konstruktorin toiminnallisuutta siten, että konstruktorissa luodaan peliin liittyvä <code>Mato</code>. Luo mato siten, että sijainti riippuu Matopeli-luokan konstruktorissa saaduista parametreista. Madon x-koordinaatin tulee olla <code>leveys / 2</code>, y-koordinaatin <code>korkeus / 2</code> ja suunnan <code>Suunta.ALAS</code>.</p>

<p>Luo konstruktorissa myös omena. Konstruktorissa luotavan omenan sijainnin tulee olla satunnainen, kuitenkin niin että omenan x-koordinaatti on aina välillä <code>[0, leveys[</code>, ja y-koordinaatti välillä <code>[0, korkeus[</code>.</p>

<p>Lisää matopeliin lisäksi seuraavat metodit</p>
<ul>
  <li><code>public Mato getMato()</code> palauttaa matopelin madon.</li>
  <li><code>public void setMato(Mato mato)</code> asettaa matopeliin metodin parametrina olevan madon. Jos metodia <code>getMato</code> kutsutaan madon asetuksen jälkeen, tulee metodin <code>getMato</code> palauttaa viite <em>samaan</em> matoon.</li>
  <li><code>public Omena getOmena</code> palauttaa matopelin omenan.</li>
  <li><code>public void setOmena(Omena omena)</code> asettaa matopeliin metodin parametrina olevan omenan. Jos metodia <code>getOmena</code> kutsutaan omenan asetuksen jälkeen, tulee metodin <code>getOmena</code> palauttaa viite <em>samaan</em> omenaan.</li>
</ul>



<h4>Matopeli, osa 2</h4>

<p>Muokkaa metodin <code>actionPerformed</code>-toiminnallisuutta siten, että metodissa toteutetaan seuraavat askeleet annetussa järjestyksessä.</p>

<ol>
  <li>Liikuta matoa</li>
  <li>Jos mato osuu omenaan, syö omena ja kutsu madon kasva-metodia. Arvo peliin uusi omena.</li>
  <li>Jos mato törmää itseensä, aseta muuttujan <code>jatkuu</code> arvoksi <code>false</code></li>
  <li>Jos mato törmää seinään, aseta muuttujan <code>jatkuu</code> arvoksi <code>false</code></li>
  <li>Kutsu rajapinnan <code>Paivitettava</code> toteuttavan muuttujan <code>paivitettava</code> metodia <code>paivita</code>.</li>
  <li>Kutsu Timer-luokalta perittyä <code>setDelay</code>-metodia siten, että pelin nopeus kasvaa suhteessa madon pituuteen. Kutsu <code>setDelay(1000 / <em>mato</em>.getPituus());</code> käy hyvin: kutsussa oletetaan että olet määritellyt oliomuuttujan nimeltä <code>mato</code>.</li>
</ol>

<p>Aletaan seuraavaksi rakentamaan käyttöliittymäkomponentteja.</p>

<h4>Näppäimistön kuuntelija</h4>

<p>Toteuta pakkaukseen <code>matopeli.gui</code> luokka <code>Nappaimistonkuuntelija</code>. Luokalla on konstruktori <code>public Nappaimistonkuuntelija(Mato mato)</code>, ja se toteuttaa rajapinnan <code>KeyListener</code>. Korvaa metodi <code>keyPressed</code> siten, että nuolinäppäintä ylös painettaessa madolle asetetaan suunta ylös. Nuolinäppäintä alas painettaessa madolle asetetaan suunta alas, vasemmalle painettaessa suunta vasen, ja oikealle painettaessa suunta oikea.</p>

<h4>Piirtoalusta</h4>

<p>Toteuta pakkaukseen <code>matopeli.gui</code> luokka <code>Piirtoalusta</code>, joka perii luokan <code>JPanel</code>. Piirtoalusta saa konstruktorin parametrina luokan <code>Matopeli</code> ilmentymän sekä int-tyyppisen muuttujan <code>palanSivunPituus</code>. Muuttuja <code>palanSivunPituus</code> kertoo minkä levyinen ja korkuinen yksittäinen pala on.</p>

<p>Korvaa luokalta <code>JPanel</code> peritty metodi <code>paintComponent(Graphics g)</code> siten, että piirrät metodissa <code>paintComponent</code> madon ja omenan. Käytä madon piirtämiseen Graphics-olion tarjoamaa <code>fill3DRect</code>-metodia. Madon värin tulee olla musta (<code>Color.BLACK</code>). Omenan piirtämisessä tulee käyttää Graphics-olion tarjoamaa <code>fillOval</code>-metodia. Omenan värin tulee olla punainen (<code>Color.RED</code>).</p>

<p><strong>Huom:</strong> metodin paintComponent alussa tulee olla kutsu korvattuun metodiin, eli ensimmäisen rivin tulee olla <code>super.paintComponent(g);</code></p>

<p>Toteuta luokalla <code>Piirtoalusta</code> myös rajapinta <code>Paivitettava</code>. Paivitettava-rajapinnan määrittelemän metodin <code>paivita</code> tulee kutsua JPanel-luokalta perittyä <code>repaint</code>-metodia.</p>

<h4>Kayttoliittyma</h4>

<p>Muuta luokkaa <code>Kayttoliittyma</code> siten, että käyttöliittymä sisältää piirtoalustan. Metodissa <code>luoKomponentit</code> tulee luoda piirtoalustan ilmentymä ja lisätä se container-olioon. Luo metodin <code>luoKomponentit</code> lopussa luokan <code>Nappaimistokuuntelija</code> ilmentymä, ja lisää se frame-olioon.</p>

<p>Lisää luokalle <code>Kayttoliittyma</code> myös metodi <code>public Paivitettava getPaivitettava()</code>, joka palauttaa metodissa <code>luoKomponentit</code> luotavan piirtoalustan.</p>

<p>Voit käynnistää käyttöliittymän <code>Main</code>-luokassa seuraavasti. Ennen pelin käynnistystä odotamme että käyttöliittymä luodaan. Kun käyttöliittymä on luotu, se kytketään matopeliin ja matopeli käynnistetään.</p>

<pre class="sh_java">
        Matopeli matopeli = new Matopeli(20, 20);

        Kayttoliittyma kali = new Kayttoliittyma(matopeli, 20);
        SwingUtilities.invokeLater(kali);

        while (kali.getPaivitettava() == null) {
            try {
                Thread.sleep(100);
            } catch (InterruptedException ex) {
                System.out.println("Piirtoalustaa ei ole vielä luotu.");
            }
        }

        matopeli.setPaivitettava(kali.getPaivitettava());
        matopeli.start();
</pre>

<p>Peliin jää vielä paljon paranneltavaa. Palauta nyt tehtävä ja voit sen jälkeen laajentaa ja parannella peliä haluamallasi tavalla!</p>
</div>
</div>

<h2>Kurssipalaute</h2>

<div class="tehtavat">
<p class="mooc-pakollinen"></p>
<div class="tehtava pakollinen-hakuun">
<h3>Kurssipalaute</h3>

<p class="hidden-in-mooc" >Olemme saaneet paljon arvokasta palautetta TMC:n kautta. Näin kurssin viimeisenä kysymyksenä haluaisimme koko kurssin sisältöä koskevan palautteen. Anna palaute täyttämällä <a href="https://ilmo.cs.helsinki.fi/kurssit/servlet/Valinta">täältä</a> löytyvä lomake. Palaute on anonyymi.</p>

<p class="hidden-in-mooc">Jotta saat merkatuksi tämän tehtävän, aja tehtävän TMC-testit ja lähetä tehtävä palvelimelle. </p>
<p class="hidden-in-hy">Vaikka olemme saaneet paljon arvokasta palautetta TMC:n kautta yksittäisistä tehtävistä, palauttaessasi tätä, kirjoitathan kommenttikenttään palautteen koko MOOC-kurssista. Mainitsethan siinä, mikäli et halua palautettasi julkaistavan anonyymisti sivustoillamme. Vain osa palautteesta tullaan julkaisemaan.</p>
</div></div>

</section>
</body>

</html>


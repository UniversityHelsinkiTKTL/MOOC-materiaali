<!DOCTYPE html>

<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<title>Ohjelmoinnin perusteet</title>

<link rel="stylesheet" href="stylesheets/menu.css" type="text/css" media="screen" />


<link rel="stylesheet" href="stylesheets/common-new.css" type="text/css" media="screen, print" />

<script type="text/javascript" src="js/bootstrap.min.js"></script>


<!-- BEGIN MOOC SNIP -->
<script type="text/javascript" src="javascripts/html5shiv.js"></script>
<script type="text/javascript" src="javascripts/jquery-1.7.1.min.js"></script>
<script type="text/javascript" src="javascripts/exercises2.js"></script>
<script type="text/javascript" src="javascripts/common-new.js"></script>
<script type="text/javascript" src="javascripts/shjs/sh_main.min.js"></script>
<script type="text/javascript" src="javascripts/shjs/sh_java.min.js"></script>
<!-- END MOOC SNIP -->

<link rel="stylesheet" href="stylesheets/shjs/sh_style.css" type="text/css" media="screen, print" />
<link rel="stylesheet" href="stylesheets/common-new.css" type="text/css" media="screen, print" />
<script type="text/javascript" src="javascripts/jquery.easing.js"></script>
<!-- BEGIN MOOC SNIP -->
<script type="text/javascript">

    jQuery(document).ready(function() {
      $(".tehtava").hide();
      $("div.toc_viikko").hide();
      $(".heading").click(function()      {
        $(this).next(".tehtava").slideToggle(200);
       });});
    </script>
</head>
<!-- END MOOC SNIP -->
<body>
<p><small>Tämä materiaali on lisensoitu Creative Commons BY-NC-SA-lisenssillä, joten voit käyttää ja levittää sitä vapaasti, kunhan alkuperäisten tekijöiden nimiä ei poisteta. Jos teet muutoksia materiaaliin ja haluat levittää muunneltua versiota, se täytyy lisensoida samanlaisella vapaalla lisenssillä. Materiaalien käyttö kaupalliseen tarkoitukseen on ilman erillistä lupaa kielletty.</small></p>
<h1>Ohjelmoinnin perusteet</h1>
<p>Arto Vihavainen ja Matti Luukkainen</p>

        <div id="toc" class="menu" data-first-chapter-index="1" data-first-exercise-index="1">
          <div id="materiaali_toc"></div>
          <!--div id="tehtavat_toc"></div-->
          <div id="tehtavat_toc2"></div>
        </div>


<section class="viikkoraja" id="0">
<div div class="viikkoraja-mooc" id="Huomautus lukijalle" tekija="Arto Vihavainen, Matti Luukkainen" deadline=" ">

<h2>Huomautus lukijalle</h2>
<p>Tämä materiaali on tarkoitettu Helsingin yliopiston tietojenkäsittelytieteen laitoksen Ohjelmoinnin perusteet -kurssille.
 Materiaali pohjautuu syksyn 2012 ja
keväiden 2013, 2012, 2011 ja 2010 kurssimateriaaleihin, joiden sisältöön ovat vaikuttaneet Matti Paksula, Antti Laaksonen, Pekka Mikkola, Juhana Laurinharju, Martin Pärtel, Joel Kaasinen ja Mikael Nousiainen</p>

<p>Lue materiaalia siten, että teet samalla itse kaikki lukemasi esimerkit. Esimerkkeihin kannattaa tehdä pieniä muutoksia ja tarkkailla, miten
  muutokset vaikuttavat ohjelman toimintaan. Äkkiseltään voisi luulla, että esimerkkien tekeminen myös itse ja niiden muokkaaminen hidastaa opiskelua.
  Tämä ei kuitenkaan pidä ollenkaan paikkansa. Ohjelmoimaan ei ole vielä tietääksemme kukaan ihminen oppinut lukemalla (tai esim. luentoa kuuntelemalla).
  Oppiminen perustuu oleellisesti aktiiviseen tekemiseen ja rutiinin kasvattamiseen. Esimerkkien ja erityisesti erilaisten omien kokeilujen
  tekeminen on parhaita tapoja "sisäistää" luettua tekstiä. </p>
<p>Pyri tekemään tai ainakin yrittämään tehtäviä sitä mukaa kuin luet tekstiä. Jos et osaa heti tehdä jotain tehtävää, älä masennu, sillä saat ohjausta tehtävän tekemiseen pajassa.</p>
<p>Tekstiä ei ole tarkoitettu vain kertaalleen luettavaksi. Joudut varmasti myöhemmin palaamaan jo aiemmin lukemiisi kohtiin tai aiemmin tekemiisi tehtäviin.
  Tämä teksti ei sisällä kaikkea oleellista ohjelmointiin liittyvää. Itse asiassa ei ole olemassa mitään kirjaa josta löytyisi kaikki oleellinen. Eli joudut
  joka tapauksessa ohjelmoijan urallasi etsimään tietoa myös omatoimisesti. Kurssin harjoitukset sisältävät jo jonkun verran ohjeita, mistä suunnista ja miten
  hyödyllistä tietoa on mahdollista löytää.</p>
<p>Muutamiin kohtiin olemme myös liittäneet screencasteja joita katsomalla voi pelkän valmiin koodin lukemisen sijaan seurata miten ohjelma muodostuu.</p>

</div>
</section>

<section class="viikkoraja" id="1" >
  <div class="viikkoraja">Viikko1</div>
  <div class="viikkoraja-mooc" id="Viikko 1" deadline=" " data-first-chapter-index="1" data-first-exercise-index="1" data-first-week-index="1"  data-first-chapter-index-mooc="1" data-first-exercise-index-mooc="1" data-first-week-index-mooc="1" tekija="Arto Vihavainen, Matti Luukkainen">




  <h2 id="koodia">Ohjelma ja lähdekoodi</h2>
  <h3>Lähdekoodi</h3>
  <p>Ohjelma muodostuu <em>lähdekoodista</em>.  Tietokone suorittaa lähdekoodissa olevia <em>komentoja</em> pääsääntöisesti <em>ylhäältä alaspäin</em> ja <em>vasemmalta oikealle</em>.  Lähdekoodi talletetaan tekstimuodossa ja <em>suoritetaan</em> jollakin tavalla.</p>
  <h3>Komennot</h3>
  <p>Varsinaisesti ohjelma muodostuu lähdekoodiin kirjoitetuista komennoista.  Tietokone suorittaa eri <em>operaatioita</em>, eli toimintoja, komentojen perusteella.  Esimerkiksi merkkijonon, eli tekstin, "Hei maailma"-tulostuksessa tärkein komento on <code>System.out.println</code>.</p>
<pre class="sh_java">
System.out.println("Hei maailma");
</pre>
  <p>Komento <code>System.out.println</code> tulostaa sille sulkeiden sisällä annetun merkkijonon.  Pääte <code>ln</code> on lyhenne sanasta <i>line</i>.  Komento siis tulostaa rivin, eli kun annettu merkkijono on tulostettu, tulostaa komento myös rivinvaihdon.</p>
  <h3>Kääntäjä ja tulkki</h3>
  <p>Tietokone ei suoraan ymmärrä käyttämäämme ohjelmointikieltä.  Tarvitsemme lähdekoodin ja tietokoneen väliin <em>kääntäjän</em>.  Ohjelmoidessamme komentoriviä käyttäen, komento <code>javac Hei.java</code> kääntää <code>Hei.java</code>-tiedoston <i>tavukoodiksi</i>, jota voidaan ajaa java-tulkin avulla.  Käännetty ohjelma ajetaan komentoriviltä komennolla <code>java Hei</code>, missä Hei on käännetyn java-lähdekooditiedoston nimi.</p>

  <p>Käyttäessämme modernia ohjelmointiympäristöä (tästä myöhemmin lisää), ohjelmointiympäristö hoitaa lähdekoodin kääntämisen.  Valitessamme ohjelman suorittamisen, ohjelmointiympäristö kääntää ja suorittaa ohjelman.  Ohjelmointiympäristöt kääntävät ohjelmakoodia ohjelmoijan sitä kirjoittaessa, jolloin yksinkertaiset virheet huomataan ennen ohjelman suoritusta.</p>
  <h3>Komennon osia</h3>
  <h4>Puolipiste</h4>
  <p>Puolipisteellä <code>;</code> erotetaan komennot toisistaan.  Kääntäjä ja tulkki ei siis ole kiinnostunut lähdekoodissa olevista riveistä, vaan voimme kirjoittaa koko ohjelman yhdelle riville.</p>
  <p>Alla olevassa esimerkissä käytetään komentoa <code>System.out.print</code>, joka on kuten komento <code>System.out.println</code> ilman rivinvaihtoa. <code>System.out.print</code>-komento ei siis tulosta rivinvaihtoa tekstin tulostamisen jälkeen.</p>
  <p><b>Esimerkki puolipisteiden käytöstä</b></p>
<pre class="sh_java">
System.out.print("Hei "); System.out.print("maailma");
System.out.print("!");
</pre>
<pre>
Hei maailma!
</pre>
  <p>Vaikka kääntäjä ja tulkki eivät tarvitse rivinvaihtoja, on niiden käyttö hyvin tärkeää muita ihmisiä ajatellen.  Selkeä lähdekoodin osien erottelu vaatii rivinvaihtojen käyttöä. Tätä ja muita lähdekoodin luettavuuteen liittyviä seikkoja tullaan painottamaan tällä kurssilla.</p>
  <h4>Komennoille lähdetettävät "tiedot" eli parametrit</h4>
  <p>Komennon käsittelemä tieto eli <em>komennon parametrit</em> lähetetään komennolle lisäämällä ne komennon nimen perässä olevien sulkujen <code>()</code> sisään.  Esimerkiksi <code>System.out.print</code> -komennon parametriksi annetaan teksti <em>hei</em> seuraavasti: <code>System.out.print("hei")</code>. </p>
  <h4>Kommentit</h4>
  <p>Lähdekoodin <code>kommentit</code> ovat kätevä tapa merkitä asioita itselle ja muille muistiin.  Kommentti on mikä tahansa rivi, joka alkaa kahdella vinoviivalla <code>//</code>.  Kaikki kommenttimerkkiä seuraava samalla rivillä oleva teksti tulkitaan kommentiksi.</p>
  <h4>Esimerkki kommenttien käytöstä</h4><br>

<pre class="sh_java">
// Tulostamme tekstin "Hei maailma"
System.out.print("Hei maailma");

System.out.print(" ja kaikki sen ihmiset."); // Lisäämme samalle riville tekstiä.

// System.out.print("tätä riviä ei suoriteta koska se on kommentoitu ulos");
</pre>
  <p>Esimerkissä alin rivi esittelee erityisen kätevän käyttökohteen kommenteille: kirjoitettua koodia ei tarvitse poistaa jos haluaa tilapäisesti kokeilla jotain.</p>
  <h3>Lisää tulostamisesta</h3>
  <p>Kuten aiemmin huomattiin, tulostamiseen on kaksi komentoa:</p>
  <p>
  <ul>
    <li> <code>System.out.print</code> tulostaa tekstin ilman loppurivinvaihtoa</li>
    <li> <code>System.out.println</code> tulostaa tekstin ja loppurivinvaihdon</li>
  </ul>
  </p>
  <p>Tulostettavan tekstin osana voi olla erikoismerkkejä.  Tärkein näistä on <code>\n</code>, joka vaihtaa riviä. Erikoismerkkejä on <a href="http://en.wikipedia.org/wiki/Escape_character" title="Escape character - Wikipedia, the free encyclopedia">muitakin</a>.</p>
<pre class="sh_java">
System.out.println("Ensimmäinen\nToinen\nKolmas");
</pre>
  <p>Ylläoleva tulostaa suoritettaessa seuraavaa:</p>
<pre>
Ensimmäinen
Toinen
Kolmas
</pre>

  <h3>Pääohjelmarunko</h3>
  <p>Ohjelman "Esimerkki" runko on seuraavanlainen. </p>
<pre class="sh_java">
public class Esimerkki {
    public static void main(String[] args) {
        // ohjelmakoodi
    }
}
</pre>
  <p>Ohjelma sijaitsee samannimisessä <i>.java</i>-päätteisessä tiedostossa.  Ohjelman <i>Esimerkki</i> täytyy siis sijaita tiedostossa,
    jonka nimi on <code>Esimerkki.java</code>.</p>
  <p>Ohjelmaa suoritettaessa suoritetaan alue, joka on rungossamme merkitty kommentilla <i>ohjelmakoodi</i>.  Ohjelmoimme ensimmäisellä viikolla
    vain tälle alueelle.  Kun puhumme komennoista, esimerkiksi tulostamisesta, tulee komennot kirjoittaa ohjelmarungon sisälle. Esimerkiksi <code>System.out.print("Tulostettava teksti");</code></p>
  <pre class="sh_java">
public class Esimerkki {
    public static void main(String[] args) {
        System.out.print("Tulostettava teksti");
    }
}
</pre>

  <p>Jatkossa esimerkeissä ei erikseen näytetä pääohjelmarunkoa.</p>

<h3>Tutustuminen ohjelmointiympäristöön</h3>

  <div>

  <p>Nykyaikainen ohjelmointi tapahtuu lähes poikkeuksetta ohjelmointiympäristössä.  Ohjelmointiympäristö sisältää joukon ohjelmoijaa auttavia aputoimintoja.  Ohjelmointiympäristö ei rakenna ohjelmaa ohjelmoijan puolesta, mutta se muunmuassa vinkkaa helpoista virheistä ohjelmakoodissa ja auttaa ohjelmoijaa hahmottamaan ohjelman rakennetta.</p>
<div class="help">
<p>Käytämme tällä kurssilla <a href="http://netbeans.org/">NetBeans</a>-nimistä ohjelmointiympäristöä.
Ohje ohjelmoinnin aloittamiseen NetBeans-ohjelmointiympäristössä löytyy <a href="http://www.cs.helsinki.fi/group/java/k14/ohpe/nb-asennus.html">täältä</a>.
</p>

  <p>Jatkossa julkaisemme pikkuhiljaa lisää ohjeita NetBeansin käyttöön. Vaikka ohjelma tuntuisi nyt sekavalta, älä hätäile. NetBeans on loppujenlopuksi hyvin helppokäyttöinen. Perusteet opit 5 minuutissa, ja kurssin myötä opit koko ajan hieman lisää ja kesäkuussa olet jo todellinen NetBeans "poweruser".</p>
</div>

<p>Ennen kuin tiedät mitä teet, <b>toimi täsmälleen ohjeen kuvaamalla tavalla</b>. Useimmat seuraavista tehtävänannoista näyttävät mitä pyydetyn tehtävän tulisi tulostaa ruudulle toimiakseen oikein. </p>

    <p>HUOM: älä tee tehtäviä siten että pelkästään kirjoitat koodia ja painelet testinappia. Suorita myös koodia normaaliin tapaan (vihreällä nuolella) ja katso mitä ruudulle tulostuu. Erityisesti jos ohjelma ei meinaa mennä testeistä läpi, kannattaa varmistaa normaalisti suorittamalla että ohjelma toimii silmämääräisesti niinkuin sen pitäisi.</p>
  </div>
  <!-- syntax ok-->
  <div class="tehtavat" id="viikko1">
    <p class="help">Seuraavissa tehtävissä harjoitellaan tuntuman saamista NetBeansiin ja ruudulle tulostamista.</p>

    <p><strong>Muista ensin katsoa ohje NetBeansin käyttöön</strong>
    <a class="ahy" href="http://www.cs.helsinki.fi/group/java/k14/ohpe/nb-asennus.html">täältä</a>.
</p>

    <p class="help"><strong>Jos et ole vielä käynyt vastaamassa kyselyyn, tee se NYT <a href="http://laatu.mooc.fi/">klikkaamalla tästä</a></strong></p>
    <p><strong>Näet tehtävänannon klikkaamalla tehtävän nimeä</strong></p>
    <NEXTWEEK></NEXTWEEK>
<div class="tehtava">
    <h3 class="req">Nimi</h3>
    <p>Tee ohjelma, joka tulostaa nimesi.</p>
    <p>Ohjelman tulostus voi olla seuraava:</p>
    <pre>
Oskari Opiskelija
</pre>
</div>
<div class="tehtava">
    <h3>Hei Maailma! (Ja Mualima!)</h3>
    <p>Tee ohjelma, jonka tulostus on seuraava:</p>
<pre>
Hei Maailma!
(Ja Mualima!)
</pre>
</div>
<div class="tehtava">
    <h3 class="req">Kuusi</h3>
    <p>Tee ohjelma, jonka tulostus on seuraava:</p>
<pre>
    *
   ***
  *****
 *******
*********
    *
</pre>
  <div class="help">
    <p><b>HUOM:</b> kirjoitit todennäköisesti aika monta kertaa <code>System.out.println("...")</code>. Kokeile kirjoittaa NetBeans:iin (main:in sisään) tyhjälle riville <i>sout</i> ja paina tabulaatoria (näppäin q:n vasemmalla puolella). Mitä tapahtuu? Tämä pieni apuväline säästänee jatkossa runsaasti aikaasi.</p>
  </div>
  </div>
</div>
  <h2 id="muuttuja_ja_sijoitus">Muuttuja ja sijoitus</h2>
  <h3>Muuttujat ja tietotyypit</h3>
  <p>Ohjelmoinnissa eräs keskeinen käsite on <em>muuttuja</em>.  Muuttuja kannattaa ajatella lokerona, johon voi tallettaa tietoa.  Muuttujaan talletettavalla tiedolla on aina tyyppi.  Tyyppejä ovat esimerkiksi teksti eli merkkijono (<em>String</em>), kokonaisluku (<em>int</em>), liukuluku (<em>double</em>) ja totuusarvo (<em>boolean</em>).  Muuttujaan asetetaan <em>arvo</em> yhtäsuuruusmerkillä (<code>=</code>). </p>
<pre class="sh_java">
int kuukausia = 12;
</pre>
  <p>Yllä olevassa asetuslauseessa asetetaan kokonaisluku-tyyppiä (<em>int</em>) olevaan muuttujaan nimeltä <em>kuukausia</em> arvo 12.  Asetuslause luetaan "muuttuja <em>kuukausia</em> saa <em>arvon</em> 12".</p>
  <p>Muuttujan arvo voidaan yhdistää merkkijonoon <code>+</code>-merkillä
    seuraavan esimerkin mukaisesti.</p>

  <!--
<h4>Esimerkkejä muuttujista ja tietotyypeistä</h4>
-->

  <pre class="sh_java">
String teksti = "sisältää tekstiä";
int kokonaisluku = 123;
double liukuluku = 3.141592653;
boolean onkoTotta = true;

System.out.println("Tekstimuuttujan arvo on " + teksti);
System.out.println("Kokonaislukumuuttujan arvo on " + kokonaisluku);
System.out.println("Liukulukumuuttujan arvo on " + liukuluku);
System.out.println("Totuusarvomuuttujan arvo on " + onkoTotta);
</pre>
  <p>Tulostus:</p>
<pre>
Tekstimuuttujan arvo on sisältää tekstiä
Kokonaislukumuuttujan arvo on 123
Liukulukumuuttujan arvo on 3.141592653
Totuusarvomuuttujan arvo on true
</pre>
  <p>Muuttuja säilyttää arvonsa kunnes siihen asetetaan toinen arvo.  Huomaa että muuttujan tyyppi kirjoitetaan vain kun muuttuja esitellään ohjelmassa ensimmäistä kertaa.</p>
<pre class="sh_java">
int kokonaisluku = 123;
System.out.println("Kokonaislukumuuttujan arvo on " + kokonaisluku);

kokonaisluku = 42;
System.out.println("Kokonaislukumuuttujan arvo on " + kokonaisluku);
</pre>
  <p>Tulostuu:</p>
<pre>
Kokonaislukumuuttujan arvo on 123
Kokonaislukumuuttujan arvo on 42
</pre>
  <h3>Muuttujan tyyppi pysyy</h3>
  <p>Kun muuttujan tyyppi on kertaalleen määritelty, ei se enää muutu.  Esimerkiksi merkkijonomuuttuja ei voi muuttua kokonaislukumuuttujaksi, eikä siihen voi asettaa kokonaislukua.</p>
<pre class="sh_java">
String merkkijono = "tsuppadui!";
merkkijono = 42; // Ei onnistu! :(
</pre>
  <p>Liukulukuun voi asettaa kokonaisluvun, sillä kokonaisluku on myös liukuluku</p>
<pre class="sh_java">
double liukuluku = 0.42;
liukuluku = 1; // Onnistuu! :)
</pre>
  <div class="tehtavat">
    <div class="tehtava">
    <h3 class="req">Muuttuvat muuttujat</h3>
    <p>Tehtäväpohja sisältää ohjelman, joka tulostaa seuraavaa.</p>
<pre>
Kanoja:
3
Pekonia (kg):
5.5
Traktori:
Ei ole!

Tässä vielä tiivistelmä:
3
5.5
Ei ole!
</pre>
    <p>Muuta ohjelmaa annetuista kohdista niin että tuloste on:</p>
<pre>
Kanoja:
9000
Pekonia (kg):
0.1
Traktori:
Zetor

Tässä vielä tiivistelmä:
9000
0.1
Zetor
</pre>
</div>
  </div>
  <h3>Sallittu ja kuvaava muuttujan nimi</h3>
  <p>Muuttujan nimeämistä rajoittavat tietyt ehdot.  Vaikka muuttujan nimessä voidaan käyttää ääkkösiä, on parempi olla <em>kayttamatta niita</em>, sillä <a href="http://en.wikipedia.org/wiki/Character_encoding" title="Character encoding - Wikipedia, the free encyclopedia">merkistökoodauksesta</a> saattaa tulla ongelmia.</p>
  <p>Muuttujan nimessä ei saa olla tiettyjä erikoismerkkejä, kuten huutomerkkejä (!).  Välilyönti ei ole sallittu, sillä se erottaa komentojen osat toisistaan.  Välilyönti kannattaa korvata <em><a href="http://fi.wikipedia.org/wiki/CamelCase" title="CamelCase – Wikipedia">camelCase</a></em>-tyylillä, jolloin nimi <code>muistuttaneeKamelia</code>. <b>Huom!</b> Muuttujien nimien ensimmäinen kirjain kirjoitetaan aina pienellä:</p>
<pre class="sh_java">
int camelCaseMuuttuja = 7;
</pre>
  <p>Numeroita voidaan käyttää muuttujan nimessä, kunhan nimi ei ala numerolla.  Nimi ei myöskään voi koostua pelkistä numeroista.</p>
<pre class="sh_java">
int 7muuttuja = 4; // Ei sallittu!
int muuttuja7 = 4; // Sallittu, mutta ei kuvaava muuttujan nimi
</pre>
  <p>Muuttujan nimi ei myöskään saa olla jo entuudestaan käytössä.  Tälläisiä nimiä ovat mm. aikaisemmin määritellyt muuttujat ja komennot, kuten <code>System.out.print</code> ja <code>System.out.println</code>.</p>
  <pre class="sh_java">
int camelCase = 2;
int camelCase = 5; // Ei sallittu -- muuttuja camelCase on jo käytössä!
</pre>
  <p>Muuttuja kannattaa nimetä siten, että sen käyttötarkoitus on selvää ilman kommentteja tai miettimistä.  Tällä kurssilla muuttujat <strong>pitää</strong> nimetä kuvaavasti.</p>
  <h4>Sallittuja muuttujien nimiä</h4>
  <p>
  <ul>
    <li>kuukaudenViimeinenPaiva = 20</li>
    <li>ensimmainenVuosi = 1952</li>
    <li>nimi = "Matti"</li>
  </ul>
</p>
  <h4>Virheellisiä muuttujien nimiä</h4>
  <p>
  <ul>
    <li>kuukauden viimeinen päivä = 20</li>
    <li>1paiva = 1952</li>
    <li>varo! = 1910</li>
    <li>1920 = 1</li>
  </ul>
  </p>
  <h2 id="laskentaa">Laskentaa</h2>
  <p>Laskentaoperaatiot ovat varsin suoraviivaisia: <code>+</code>, <code>-</code>, <code>*</code> ja <code>/</code>.  Erikoisempana operaationa on <code>%</code>, joka on jakojäännös, eli modulo.  Laskentajärjestys on myös varsin suoraviivainen: operaatiot lasketaan vasemmalta oikealle sulut huomioon ottaen. Kuitenkin <code>*</code> ja <code>/</code> laskentaan ennen <code>+</code> ja <code>-</code> operaatioita. <a href="http://docs.oracle.com/javase/tutorial/java/nutsandbolts/operators.html">Tässä vielä tarkemmin laskujärjestyksestä javassa.</a> Linkin takana oleva materiaali ei ole kuitenkaan aloittelijan kannalta kovin oleellista.</p>
<pre class="sh_java">
int eka = 2; // kokonaislukutyyppinen muuttuja eka saa arvon 2
int toka = 4; // kokonaislukutyyppinen muuttuja toka saa arvon 4
int summa = eka + toka;  // kokonaislukutyyppinen muuttuja summa saa arvon eka + toka, eli 2 + 4

System.out.println(summa); // tulostetaan muuttujan summa arvo
</pre>
<pre class="sh_java">
int laskuSuluilla = (1 + 1) + 3 * (2 + 5);   // 23
int laskuSuluitta = 1 + 1 + 3 * 2 + 5;       // 13
</pre>
  <p>Yllä olevan sulkuesimerkin voi suorittaa myös askeleittain.</p>
<pre class="sh_java">
int laskuSuluilla = (1 + 1);
laskuSuluilla = laskuSuluilla + 3 * (2 + 5)   // 23

int laskuSuluitta = 1 + 1;
laskuSuluitta = laskuSuluitta + 3 * 2;
laskuSuluitta = laskuSuluitta + 5;      // 13
</pre>
  <p>Laskentaoperaatioita voidaan suorittaa lähes missä tahansa kohdassa ohjelmakoodia.</p>
<pre class="sh_java">
int eka = 2;
int toka = 4;

System.out.println(eka+toka);
System.out.println(2 + toka - eka - toka);
</pre>
  <h3 id="liuku_eli_desimaali">Liukuluvut eli desimaaliluvut</h3>
  <p>Kokonaislukujen jako ja jakojäännös ovat hieman hankalampia.  Liukuluku ja kokonaisluku menevät helposti sekaisin.  Jos kaikki laskuoperaatiossa olevat muuttujat ovat kokonaislukuja, on tulos myös kokonaisluku.</p>
<pre class="sh_java">
int tulos = 3 / 2;      // tulos on 1 (kokonaisluku), sillä 3 ja 2 ovat myös kokonaislukuja
</pre>
<pre class="sh_java">
int eka = 3:
int toka = 2;
double tulos = eka / toka;      // nytkin tulos on 1, sillä eka ja toka ovat kokonaislukuja
</pre>
  <p>Jakojäännös-operaation (%) avulla saadaan selville jakojäännös.  Esimerkiksi laskun <code>7 % 2</code> jakojäännös on 1.</p>
<pre class="sh_java">
int jakojaannos = 7 % 2; // jakojaannos on 1 (kokonaisluku)
</pre>
  <p>Jos jakolaskun jakaja tai jaettava (tai molemmat!) ovat liukulukuja, tulee tulokseksi myös liukuluku</p>
<pre class="sh_java">
double kunJaettavaOnLiukuluku = 3.0 / 2;  // tulokseksi: 1.5
double kunJakajaOnLiukuluku = 3 / 2.0;    // tulokseksi: 1.5
</pre>
  <p>Kokonaisluku voidaan tarvittaessa muuttaa liukuluvuksi lisäämällä sen eteen tyyppimuunnosoperaatio <code>(double)</code>:</p>
<pre class="sh_java">
int eka = 3;
int toka = 2;

double tulos1 = (double)eka / toka;  // tulokseksi: 1.5

double tulos2 = eka / (double)toka;  // tulokseksi: 1.5

double tulos3 = (double)(eka / toka);  // tulokseksi: 1
</pre>
  <p>Jälkimmäisessä tulos pyöristyy väärin sillä laskuoperaatio kokonaisluvuilla suoritetaan ennen tyyppimuunnosta.</p>
  <p>Jos jakolaskun tulos asetetaan kokonaislukutyyppiseen muuttujaan, on tulos automaattisesti kokonaisluku</p>
<pre class="sh_java">
int tulosKokonaislukuKoskaTyyppiKokonaisluku = 3.0 / 2;  // tulos automaattisesti kokonaisluku: 1
</pre>
  <p>Seuraava esimerkki tulostaa "1.5", sillä jaettavasta tehdään liukuluku kertomalla se liukuluvulla (1.0 * 3 = 3.0) ennen jakolaskua.</p>
<pre class="sh_java">
int jaettava = 3;
int jakaja = 2;

double tulos = 1.0 * jaettava / jakaja;
System.out.println(tulos);
</pre>
  <p>Mitä seuraava tulostaa?</p>
<pre class="sh_java">
int jaettava = 3;
int jakaja = 2;

double tulos = jaettava / jakaja * 1.0;
System.out.println(tulos);
</pre>
  <p> <big> Huomioi, että nimeät muuttujat nyt ja jatkossakin yllä esiteltyjen hyvien käytäntöjen mukaan. </big> </p>
  <div class="tehtavat">
    <div class="tehtava">
    <h3 class="req">Sekunnit vuodessa</h3>
    <p>Tee ohjelma, joka laskee, kuinka monta sekuntia on vuodessa.
      Voit olettaa, että vuodessa on 365 päivää (eli ei ole karkausvuosi).</p>
    <p>Ohjelman tulostus on seuraava:</p>
<pre>
Vuodessa on X sekuntia.
</pre>
    <p>X:n kohdalle tulee ohjelmasi laskema tulos.</p>
  </div>
</div>
  <h2 id="katenointi">Katenointi eli merkkijonojen yhdistäminen</h2>
  <p>Tarkastellaan vielä lähemmin merkkijonojen
    yhdistämistä <code>+</code>-merkinnän avulla.</p>
  <p>Jos operaatiota <code>+</code> sovelletaan kahden merkkijonon välille, syntyy uusi merkkijono, jossa kaksi merkkijonoa on yhdistetty.  Huomaa nokkela välilyönnin käyttö lauseen "muuttujien" osana!</p>
<pre class="sh_java">
String tervehdys = "Hei ";
String nimi = "Matti";
String hyvästely = ", ja näkemiin!";

String lause = tervehdys + nimi + hyvästely;

System.out.println(lause);
</pre>
<pre>
Hei Matti, ja näkemiin!
</pre>
  <p>Jos toinen operaation <code>+</code> kohteista on merkkijono, syntyy uusi merkkijono, jossa esimerkiksi kokonaisluku <code>2</code> on muutettu merkkijonoksi "2" ja tähän yhdistetty haluttu merkkijono.</p>
<pre class="sh_java">
System.out.println("tuossa on kokonaisluku --&gt; " + 2);
System.out.println( 2 + " &lt;-- tuossa on kokonaisluku");
</pre>
    <p>Edellä esitellyt laskusäännöt pätevät täälläkin:</p>
<pre class="sh_java">
System.out.println("Neljä: " + (2+2));
System.out.println("Mutta! kaksikymmentäkaksi: " + 2 + 2);
</pre>
<pre>
Neljä: 4
Mutta! kaksikymmentäkaksi: 22
</pre>
  <p>Edellisiä tietoja yhdistelemällä pystymme tulostamaan muuttujan arvoja ja tekstiä sekaisin:</p>
<pre class="sh_java">
int x = 10;

System.out.println("muuttujan x arvo on: " + x);

int y = 5;
int z = 6;

System.out.println("y on " + y + " ja z on " + z);
</pre>
  <p>Tämä ohjelma tulostaa tietenkin:</p>
<pre>
muuttujan x arvo on: 10
y on 5 ja z on 6
</pre>
  <div class="tehtavat">
    <div class="tehtava">
    <h3 class="req">Yhteenlasku</h3>
    <p>Tee ohjelma, jonka avulla voidaan laskea kahden kokonaisluvun summa.
      Ohjelman alussa määritellään kaksi muuttujaa,
      jotka sisältävät summattavat luvut.
      Voit tarvittaessa käyttää myös muita muuttujia.</p>
    <p>Esimerkiksi jos muuttujissa on luvut 5 ja 4,
      ohjelman tulostus on seuraava:</p>
<pre>
5 + 4 = 9
</pre>
    <p>Jos taas muuttujissa on luvut 73457 ja 12888,
      ohjelman tulostus on seuraava:</p>
<pre>
73457 + 12888 = 86345
</pre>
</div>
<div class="tehtava">
    <h3 class="">Kertolasku</h3>
    <p>Tee edellistä ohjelmaa vastaava ohjelma,
      joka laskee kahden kokonaislukumuuttujaan sijoitetun arvon kertolaskun.</p>
    <p>Esimerkiksi jos muuttujissa on luvut 2 ja 8,
      ohjelman tulostus on seuraava:</p>
<pre>
2 * 8 = 16
</pre>
    <p>Jos taas muuttujissa on luvut 277 ja 111,
      ohjelman tulostus on seuraava:</p>
<pre>
277 * 111 = 30747
</pre>
    <p>Kuinka suuren kertolaskun ohjelmasi
      pystyy laskemaan?</p>
  </div>
</div>
  <h2 id="syötteen_lukeminen">Käyttäjän syötteen lukeminen</h2>
  <p>Tähän asti ohjelmamme ovat olleet kovin yksipuolisia. Seuraavaksi luemme <em>syötettä</em> käyttäjältä.  Käytämme syötteen lukemiseen erityistä <em>Scanner</em>-apuvälinettä.</p>
  <p>Lisätään <em>Scanner</em> valmiiseen pääohjelmarunkoomme.  Älä hätäile vaikka pääohjelmarunko saattaa näyttää vaikeaselkoiselta, jatkamme koodausta kuten ennenkin, eli kohtaan mikä on merkattu kommentilla <em>ohjelmakoodi</em>.</p>
<pre class="sh_java">
import java.util.Scanner;

public class OhjelmaRunko {

    public static void main(String[] args) {
        Scanner lukija = new Scanner(System.in);

        // ohjelmakoodi
    }
}
</pre>
  <h3 id="syote_simppeli">Merkkijonon lukeminen</h3>
  <p>Seuraava koodi lukee käyttäjän nimen ja tulostaa tervehdyksen:</p>
<pre class="sh_java">
System.out.print("Mikä on nimesi? ");
String nimi = lukija.nextLine(); // Luetaan käyttäjältä rivi tekstiä ja asetetaan se muuttujaan nimi

System.out.println("Hei, " + nimi);
</pre>
<pre>
Mikä on nimesi? <span class="red">Matti</span>
Hei, Matti
</pre>
  <p>(Seuraavassa on yllä oleva ohjelma pääohjelmarungon kanssa.  Ohjelman nimi on <em>Tervehdys</em>.  Koska ohjelman nimi on Tervehdys, täytyy sen sijaita tiedostossa <code>Tervehdys.java</code> -- Käyttäessäsi NetBeans-ohjelmointiympäristöä, toimi kuten alussa olleessa
    <!-- BEGIN mini MOOC SNIP-->
    <a class="ahy" href="netbeansohje.html">ohjeessa</a>
    <!-- END mini MOOC SNIP-->
    <!-- BEGIN mini SNIP-->
    <a class="amooc" href="http://mooc.cs.helsinki.fi/ohjelmointi/ilmoittautuminen-ja-alkutoimet">ohjeessa</a>
    <!-- END mini SNIP-->
     tehtiin, mutta muuta ohjelman nimi Heistä (<em>Hei</em>) Tervehdykseksi (<em>Tervehdys</em>)</p>
  <pre class="sh_java">
import java.util.Scanner;

public class Tervehdys {

    public static void main(String[] args) {
        Scanner lukija = new Scanner(System.in);

        System.out.print("Kenelle sanotaan hei: ");
        String nimi = lukija.nextLine(); // Luetaan käyttäjältä rivi tekstiä ja asetetaan sen arvo muuttujaan nimi

        System.out.print("Hei " + nimi);
    }
}
</pre>
  <p>Kun yllä oleva ohjelma ajetaan, pääset kirjoittamaan syötteen.  NetBeansin tulostusvälilehti (alhaalla) näyttää ajetun ohjelman jälkeen seuraavalta (käyttäjä syöttää nimen "Matti").</p>
<pre>
run:
Kenelle sanotaan hei: Matti
Hei Matti
BUILD SUCCESSFUL (total time: 6 seconds)
</pre>
  <h3 id="syote_kokonaisluku">Kokonaisluvun lukeminen</h3>
  <p>Scanner-apuvälineemme ei ole hyvä kokonaislukujen lukemiseen, joten käytämme toista apuvälinettä merkkijonon kokonaisluvuksi muuttamisessa.  Komento <code>Integer.parseInt</code> muuttaa sille annetussa tekstimuuttujassa olevan kokonaisluvun kokonaislukumuuttujaksi.  Komennolle annetaan tekstimuuttuja sulkuihin, ja se palauttaa kokonaisluvun joka asetetaan kokonaislukumuuttujaan.</p>
  <p>Käytännössä kytkemme kaksi komentoa yhteen. Ensin luemme käyttäjältä rivin, jonka annamme heti komennolle <code>Integer.parseInt</code>.</p>

  <!--
<pre class="sh_java">
String kolmonenMerkkijonona = "3";
int kolme = Integer.parseInt(kolmonenMerkkijonona);
</pre>

    <p>Sama esimerkki, mutta luetaan kokonaisluku käyttäjältä merkkijonona.</p>
<pre class="sh_java">
System.out.print("Anna kokonaisluku: ");
String kokonaislukuMerkkijonona = lukija.nextLine();
int kokonaisluku = Integer.parseInt(kokonaislukuMerkkijonona);

System.out.println("Annoit " + kokonaisluku);
</pre>
    <p>Komentoja voi usein myös ketjuttaa.  Käytetään lukijan <code>nextLine</code>-komennon antamaa merkkijonoa suoraan komennossa <code>Integer.parseInt</code>.  Tällöin lukija lukee käyttäjältä ensiksi syötteen, komento <code>Integer.parseInt</code> muuttaa syötteen kokonaisluvuksi.  Käytämme jatkossa alla esitettyä tapaa kokonaisluvun lukemiseen.</p>
    //-->

  <pre class="sh_java">
System.out.print("Anna kokonaisluku: ");
int kokonaisluku = Integer.parseInt(lukija.nextLine());

System.out.println("Annoit " + kokonaisluku);
</pre>
  <p>Kysytään seuraavaksi käyttäjältä nimi, ja sen jälkeen ikä.  Tällä kertaa esimerkissä on myös ohjelmarunko mukana.</p>
  <pre class="sh_java">
import java.util.Scanner;

public class NimiJaIkaTervehdys {
    public static void main(String[] args) {
        Scanner lukija = new Scanner(System.in);

        System.out.print("Nimesi: ");
        String nimi = lukija.nextLine();   // Luetaan käyttäjältä rivi tekstiä

        System.out.print("Kuinka vanha olet: ");
        int ika = Integer.parseInt(lukija.nextLine()); // luetaan käyttäjältä tekstimuuttuja ja muutetaan se kokonaisluvuksi

        System.out.println("Nimesi on siis: " + nimi + ", ja ikäsi " + ika + ", hauska tutustua.");
    }
}
</pre>
  <h3 id="yhteenveto">Yhteenveto</h3>
  <p>Käyttäjän kanssa keskustelevan ohjelman runko:</p>
<pre class="sh_java">
import java.util.Scanner;
public class OhjelmanNimi {
    public static void main(String[] args) {
        Scanner lukija = new Scanner(System.in);

        // koodi tähän
    }
}
</pre>
  <p>Merkkijonon lukeminen:</p>
<pre class="sh_java">
String merkkijono = lukija.nextLine();
</pre>
  <p>Kokonaisluvun lukeminen:</p>
<pre class="sh_java">
int kokonaisluku = Integer.parseInt(lukija.nextLine());
</pre>
  <div class="tehtavat">
    <div class="tehtava">
    <h3 class="req">Summaaja</h3>
    <p>Tee ohjelma, joka kysyy käyttäjältä kaksi kokonaislukua ja tulostaa niiden summan.</p>
<pre>
Anna ensimmäinen luku: <font color="red">6</font>
Anna toinen luku: <font color="red">2</font>

Lukujen summa: 8
</pre>
<!-- syntax ok-->
    <p>Esimerkissä punainen väri tarkoittaa
      käyttäjän kirjoittamaa tekstiä.
      Tätä käytäntöä noudatetaan jatkossa esimerkeissä.</p>
  </div>
  <div class="tehtava">
    <h3>Jakaja</h3>
    <p>Tee ohjelma, joka kysyy käyttäjältä kaksi kokonaislukua ja
      tulostaa niiden osamäärän. Varmista, että <code>3 / 2 = 1.5</code>. Jos desimaaliosa katoaa, lue materiaalin kohdasta <a class="ahy" href="#liuku_eli_desimaali">Liukuluvut eli desimaaliluvut</a> missä vika on.</p>
<pre>
Anna ensimmäinen luku: <font color="red">3</font>
Anna toinen luku: <font color="red">2</font>

Jakolasku: 3 / 2 = 1.5
</pre>
</div>
    <div class="tehtava">
    <h3 class="req">Ympyrän kehän pituus</h3>
    <p>Ympyrän kehän pituus lasketaan kaavalla <code>2 * pii * säde</code>.
      Tee ohjelma, joka kysyy käyttäjältä ympyrän säteen ja laskee sen perusteella ympyrän kehän pituuden.
      Javasta löytyy valmis piin arvo, saat sen kirjoittamalla <code>Math.PI</code> laskutoimitukseen.</p>
<pre>
Anna ympyrän säde: <font color="red">20</font>

Ympyrän kehä: 125.66370614359172
</pre>
</div>
<div class="tehtava">
    <h3>Suurempi luku</h3>
    <p>Tee ohjelma, joka kysyy käyttäjältä kaksi kokonaislukua ja
      tulostaa luvuista suuremman.</p>
  <div class="help">
    <p><strong>Vihje</strong>: kun kirjoitat NetBeans:iin Math. (eli Math ja perään piste), näet erinäisiä Javan valmiita matemaattisia laskutoimituksia, esim. <code>Math.cos(10)</code> laskee luvun 10 kosinin. Kokeile, löydätkö Math:sta sopivan työkalun seuraavan ohjelman tekemiseen. Jos et löydä tai osaa tehdä tätä kohtaa, siirry heti eteenpäin. Tutustumme asiaan tarkemmin myöhemmässä vaiheessa.</p>
  </div>
<pre>
Anna ensimmäinen luku: <font color="red">20</font>
Anna toinen luku: <font color="red">14</font>

Luvuista suurempi: 20
</pre>
</div>
<div class="tehtava">
    <h3 class="req">Ikien summa</h3>
    <p>Tee ohjelma, joka kysyy kahden käyttäjän nimet ja iät.  Tämän jälkeen ohjelma tulostaa henkilöiden ikien summan.</p>
<pre>
Kerro nimi: <font color="red">Matti</font>
Kerro ikä: <font color="red">14</font>

Kerro nimi: <font color="red">Arto</font>
Kerro ikä: <font color="red">12</font>

Matti ja Arto ovat yhteensä 26 vuotta vanhoja.
</pre>
</div>

<div class="tehtava">

    <h3 class="req">Robottiohjain</h3>

    <p>Tehtäväpohjaan on liitetty valmis komponentti <code>Ohjain</code> jonka avulla on mahdollista ohjata pientä robottia.</p>
    <p>Pääohjelma "importoi" eli ottaa komponentin käyttöönsä lisäämällä koodin yläosaan <code>import robotti.Ohjain;</code>. Komennolla <code>Ohjain.kaynnista();</code> robottiohjain käynnistää robotin, ja luo ikkunan, jossa robotin kulkemista voi seurata.</p>

    <img src="http://www.cs.helsinki.fi/group/java/mooc-matsku/img/exercises/13-robotcontrol-init.png"/>

    <p>Robottia liikutetaan komennoilla <code>Ohjain.ylos();</code>, <code>Ohjain.oikealle();</code>, <code>Ohjain.alas();</code>, ja <code>Ohjain.vasemmalle();</code>. Seuraavassa on esimerkkiohjelma robottiohjaimen käytöstä siten, että robottia siirretään kaksi ruutua ylöspäin:</p>

<pre class="sh_java">
import java.util.Scanner;
import robotti.Ohjain;

public class Paaohjelma {
    public static void main(String[] args) throws Exception {
        Scanner lukija = new Scanner(System.in);

        // käynnistetään robotti
        Ohjain.kaynnista();

        Ohjain.ylos();
        Ohjain.ylos();

        // sammutetaan robotti
        Ohjain.sammuta();
    }
}
</pre>

    <p>Yllä oleva ohjelma päätyy seuraavaan tilanteeseen:</p>

    <img src="http://www.cs.helsinki.fi/group/java/mooc-matsku/img/exercises/13-robotcontrol-twoup.png"/>

    <p>Kuten huomaat, robotti jättää liikkuessaan jäljen kohtiin, missä se on käynyt.</p>

    <p>Tehtävänäsi on tehdä ohjelmarunkoon ohjelma, joka kuljettaa robottia siten, että lopputilanne on seuraavanlainen.</p>

    <img src="http://www.cs.helsinki.fi/group/java/mooc-matsku/img/exercises/13-robotcontrol.png"/>

    <p>Yllä suuremman suorakulmion leveys on 7 askelta ja korkeus on 5 askelta, ja pienemmän suorakulmion leveys on 3 askelta, ja korkeus 2 askelta.  Kun olet lähettänyt tehtävän tarkastettavaksi ja palautusautomaatti hyväksyy sen, voit muokata koodia ja tehdä vapaasti erilaisia kuvioita!</p>

  </div>
</div>
  <h2 id="valinta_ja_totuusarvot">Valinta ja totuusarvot</h2>
  <p>Tähän mennessä tekemämme ohjelmat ovat edenneet suoraviivaisesti käskystä toiseen, toimien jokaisella suorituskerralla samalla tavalla. Jotta ohjelman suoritus voisi <em>haarautua</em> erilaisille suorituspoluille käyttäjän esim. käyttäjän antaman syötteen perusteella, tarvitsemme käyttöömme valintakäskyn.</p>
<pre class="sh_java">
int luku = 11;

if ( luku &gt; 10 ) {
    System.out.println("Luku oli suurempi kuin 10");
}
</pre>
  <p>Ehto <code>( luku > 10 )</code> muuntautuu totuusarvoksi <em>true</em> tai <em>false</em>.  Valintakäsky <code>if</code> käsittelee siis lopulta vain ja ainoastaan totuusarvoja.  Yllä oleva ehtolause luetaan "jos luku on suurempi kuin 10".</p>
  <p>Huomaa, että <code>if</code> -lauseen perään ei tule puolipistettä, sillä lause ei lopu ehto-osan jälkeen.</p>
  <p>Ehdon jälkeen avaava aaltosulku <code>{</code> aloittaa <em>lohkon</em> (block), jonka sisältö suoritetaan jos <em>ehto</em> on tosi. <em>Lohko</em> loppuu sulkevaan aaltosulkuun <code>}</code>.   Lohko voi olla kuinka pitkä tahansa.</p>
  <p>Vertailuoperaattoreita ovat seuraavat: </p>
  <ul>
    <li><code>&gt;</code>suurempi kuin</li>
    <li><code>&gt;=</code>suurempi tai yhtäsuuri kuin</li>
    <li><code>&lt;</code>pienempi kuin</li>
    <li><code>&lt;=</code> pienempi tai yhtäsuuri kuin</li>
    <li><code>==</code> yhtäsuuri kuin</li>
    <li><code>!=</code> erisuuri kuin</li>
  </ul>
<pre class="sh_java">
int luku = 55;

if ( luku != 0 ) {
    System.out.println("Luku oli erisuuri kuin 0");
}

if ( luku &gt;= 1000 ) {
    System.out.println("Luku oli vähintään 1000");
}

  </pre>
  <p>Lohkon sisällä voi olla mitä tahansa koodia, myös toinen valintakäsky. </p>
<pre class="sh_java">
int x = 45;
int luku = 55;

if ( luku &gt; 0 ) {
    System.out.println("Luku on positiivinen");

    if ( luku>x ) {
        System.out.println(" ja suurempi kuin muuttujan x arvo");
        System.out.println("muuttujan x arvohan on " + x);
    }
}
</pre>
  <p>Vertailuoperaattoreita voi käyttää myös ehtojen ulkopuolella.  Tällöin ehdon totuusarvo asettuu totuusarvomuuttujaan.</p>
<pre class="sh_java">
int eka = 1;
int toka = 3;

boolean onkoSuurempi = eka &gt; toka;
</pre>
  <p>Yllä olevassa esimerkissä totuusarvomuuttuja <code>onkoSuurempi</code> sisältää nyt totuusarvon <em>false</em>.</p>
  <p>Totuusarvomuuttujaa voidaan käyttää ehtolauseessa ehtona.</p>
  <pre class="sh_java">
int eka = 1;
int toka = 3;

boolean onkoPienempi = eka &lt; toka;

if ( onkoPienempi ) {
    System.out.println("1 on pienempi kuin 3!");
}
</pre>
  <pre>
  1 on pienempi kuin 3!
</pre>
  <h3 id="sisennys">Koodin sisennys</h3>
  <p>Huomaa, että if-komennon jälkeisen lohkon, eli {-merkkiä seuraavien rivien komentoja ei kirjoiteta samalle tasolle (eli yhtä "vasemmalle") kuin komentoa if, vaan ne <b>sisennetään</b> hieman oikealle. Sisentäminen tapahtuu tabulaattorimerkillä (q:n vasemmalla puolella oleva näppäin). Kun lohko sulkeutuu, eli tulee }-merkki, sisennys loppuu. }-merkki on samalla tasolla kuin if.</p>
  <p class="help">Sisennys on oleellinen seikka ohjelmien ymmärrettävyyden kannalta. Tällä kurssilla ja kaikkialla "oikeassa elämässä" edellytetään, että koodi sisennetään asiallisesti. NetBeans auttaa sisennyksessä. Ohjelman saa sisennettyä helposti painamalla yhtä aikaa shift, alt ja f.</p>
  <h3>else</h3>
  <p>Jos valinnan ehto on epätotta, eli totuusarvo on false, voidaan suorittaa toinen vaihtoehtoinen lohko koodia, tämä käy komennon <code>else</code> avulla.</p>
<pre class="sh_java">
int luku = 4;

if ( luku &gt; 5 ) {
    System.out.println("Lukusi on suurempi kuin viisi!");
} else {
    System.out.println("Lukusi on viisi tai alle!");
}
</pre>
  <pre>
  Lukusi on viisi tai alle!
</pre>
  <div class="tehtavat">
    <div class="tehtava">
    <h3 class="req">Positiivinen luku</h3>
    <p>Tee ohjelma, joka kysyy käyttäjältä kokonaisluvun ja kertoo,
      onko se positiivinen (eli suurempi kuin nolla).</p>
<pre>
Anna luku: <font color="red">5</font>

Luku on positiivinen.
</pre>
<pre>
Anna luku: <font color="red">-2</font>

Luku ei ole positiivinen.
</pre>
    <big>
    <p><b>Onhan koodisi varmasti sisennetty oikein?</b></p>
    </big>
    <p class="help">Kertaa materiaalista kohta
    <!-- BEGIN mini MOOC SNIP-->
    <a class="ahy" href="#sisennys">Koodin sisennys</a>
    <!-- END mini MOOC SNIP-->
    <!-- BEGIN mini SNIP-->
    <a class="amooc" href="viikko-1#sisennys">ohjeessa</a>
    <!-- END mini SNIP-->

    . Kokeile mitä tapahtuu NetBeansissa kun painat yhtä aikaa shift, alt ja f! Sama toiminnallisuus eli automaattinen sisennys saadaan aikaan valitsemalla yläpalkista Source ja sen alta Format.</p>
    </div>
    <div class="tehtava">
    <h3 class="req">Täysi-ikäisyys</h3>
    <p>Tee ohjelma, joka kysyy käyttäjän ikää ja kertoo,
      onko tämä täysi-ikäinen (eli 18-vuotias tai vanhempi).</p>
<pre>
Kuinka vanha olet? <font color="red">12</font>

Et ole vielä täysi-ikäinen!
</pre>
<pre>
Kuinka vanha olet? <font color="red">32</font>

Olet jo täysi-ikäinen!
</pre>
</div>
<div class="tehtava">
    <h3 class="req">Pariton vai parillinen?</h3>
    <p>Tee ohjelma, joka kysyy käyttäjältä luvun ja ilmoittaa,
      onko se parillinen vai pariton.</p>
<pre>
Anna luku: <font color="red">2</font>
Luku 2 on parillinen.
</pre>
<pre>
Anna luku: <font color="red">7</font>
Luku 7 on pariton.
</pre>
    <p>Vihje: Luvun jakojäännös 2:lla kertoo, onko luku parillinen vai pariton. Jakojäännos taas saadaan <code>%</code>-operaattorilla, tehtäväpohjassa on lisää ohjeita miten parittomuustarkastus hoituu jakojäännöksen avulla.</p>
  </div>
</div>
  <h3>else if</h3>
  <p>Jos valittavissa olevia vaihtoehtoja on enemmän kuin kaksi kannattaa käyttää <code>else if</code>-komentoa, joka on kuten <code>else</code>, mutta lisäehdolla. <code>else if</code> tulee <code>if</code>-ehdon jälkeen. <code>else if</code> ehtoja voi olla useita.</p>
<pre class="sh_java">
int luku = 3;

if ( luku == 1 ) {
    System.out.println("Luku on yksi");
} else if ( luku == 2 ) {
    System.out.println("Lukuna on kaksi");
} else if ( luku == 3 ) {
    System.out.println("Kolme lienee lukuna!");
} else {
    System.out.println("Aika paljon!");
}
</pre>
  <pre>
  Kolme lienee lukuna!
</pre>
  <p>Luetaan ylläoleva esimerkki: 'Jos luku on yksi, tulosta "Luku on yksi", muuten jos luku on kaksi, tulosta "Lukuna on kaksi", muuten jos
    lukuna on kolme, tulosta "Kolme lienee lukuna".  Muulloin, tulosta "Aika paljon!"'.</p>
  <h3>Merkkijonojen vertailu</h3>
  <p>Merkkijonoja, eli tekstejä, ei voi vertailla yhtäsuuri kuin (<em>==</em>) operaatiolla.  Merkkijonojen vertailuun käytetään erillistä <code>equals</code>-komentoa, joka liittyy aina verrattavaan merkkijonoon.</p>
<pre class="sh_java">
String teksti = "kurssi";

if ( teksti.equals("marsipaani") ) {
    System.out.println("Teksti-muuttujassa on teksti marsipaani.");
} else {
    System.out.println("Teksti-muuttujassa ei ole tekstiä marsipaani.");
}
</pre>
  <p>Komento <code>equals</code> liitetään aina siihen verrattavaan tekstimuuttujaan, "tekstimuuttuja piste equals teksti".  Tekstimuuttujaa voidaan myös verrata toiseen tekstimuuttujaan. </p>
<pre class="sh_java">
String teksti = "kurssi";
String toinenTeksti = "pursi";

if ( teksti.equals(toinenTeksti) ) {
    System.out.println("Samat tekstit!");
} else {
    System.out.println("Ei samat tekstit!");
}
</pre>
  <p>Merkkijonoja vertailtaessa on syytä varmistaa että verrattavalla tekstimuuttujalla on arvo.  Jos muuttujalla ei ole arvoa, ohjelma tuottaa virheen <em>NullPointerException</em>, joka tarkoittaa ettei muuttujan arvoa ole asetettu tai se on tyhjä (<em>null</em>).</p>
  <div class="tehtavat">
    <div class="tehtava">
    <h3 class="req"> Suurempi luku</h3>
    <p>Tee ohjelma, joka kysyy käyttäjältä kaksi kokonaislukua ja tulostaa niistä suuremman. Jos luvut ovat yhtä suuret, ohjelma huomaa myös tämän.</p>
    <p>Esimerkkitulostuksia:</p>
<pre>
Anna ensimmäinen luku: <font color="red">5</font>
Anna toinen luku: <font color="red">3</font>

Suurempi luku: 5
</pre>
<pre>
Anna ensimmäinen luku: <font color="red">5</font>
Anna toinen luku: <font color="red">8</font>

Suurempi luku: 8
</pre>
<pre>
Anna ensimmäinen luku: <font color="red">5</font>
Anna toinen luku: <font color="red">5</font>

Luvut ovat yhtä suuret!
</pre>
</div>
<div class="tehtava">
    <h3 class="req">Arvosanat ja pisteet</h3>
    <p>Tee ohjelma, joka ilmoittaa kurssiarvosanan
      seuraavan taulukon mukaisesti.</p>
    <table border style="margin-left:50px">
      <tr>
        <th>pistemäärä</th>
        <th>arvosana</th>
      </tr>
      <tr>
        <td>0&ndash;29</td>
        <td>hylätty</td>
      </tr>
      <tr>
        <td>30&ndash;34</td>
        <td>1</td>
      </tr>
      <tr>
        <td>35&ndash;39</td>
        <td>2</td>
      </tr>
      <tr>
        <td>40&ndash;44</td>
        <td>3</td>
      </tr>
      <tr>
        <td>45&ndash;49</td>
        <td>4</td>
      </tr>
      <tr>
        <td>50&ndash;60</td>
        <td>5</td>
      </tr>
    </table>
    <p>Esimerkkitulostuksia:</p>
<pre>
Anna pisteet [0-60]: <font color="red">37</font>

Arvosana: 2
</pre>
<pre>
Anna pisteet [0-60]: <font color="red">51</font>

Arvosana: 5
</pre>
  </div>
</div>
  <h3>Loogiset operaatiot</h3>
  <p>Valinnan ehto voi olla myös monimutkaisempi, yksittäisten loogisten operaatioiden avulla koostettu ehto. Loogisia operaatioita ovat:</p>
<ul>
<li><code>ehto1 &amp;&amp; ehto2</code> lausekkeen arvo on tosi molemmat ehtoista ovat tosia</li>
<li><code>ehto1 || ehto2</code> lausekkeen arvo on tosi jos jompi kumpi tai molemmat ehdoista tosia</li>
<li><code>!ehto</code> lausekkeen arvo on tosi kun ehdon arvo on epätosi</li>
</ul>

<p>Seuraavassa yhdistetään <code>&amp;&amp;</code>:lla eli ja-operaatiolla kaksi yksittäistä ehtoa, sillä halutaan tarkistaa, onko muuttujassa oleva luku suurempi kuin 4 <strong>ja</strong> pienempi kuin 11, eli siis välillä 5-10:</p>

<pre class="sh_java">
System.out.println("Onkohan luku väliltä 5-10: ");
int luku = 7;

if ( luku &gt; 4 &amp;&amp; luku &lt; 11 ) {
    System.out.println("On! :)");
} else {
    System.out.println("Ei ollut :(")
}
</pre>
<pre>
Onkohan luku väliltä 5-10:
On! :)
</pre>

<p>Seuraavassa annetaan <code>||</code>:n eli tai-operaation avulla kaksi vaihtoehtoa, onko luku pienempi kuin 0 <strong>tai</strong> suurempi kuin 100. Ehto toteutuu jos luku täyttää jomman kumman ehdon:</p>

<pre class="sh_java">
System.out.println("Onkohan luku pienempi kuin 0 tai suurempi kuin 100");
int luku = 145;

if ( luku &lt; 0 || luku &gt; 100 ) {
    System.out.println("On! :)");
} else {
    System.out.println("Ei ollut :(")
}
</pre>
<pre>
Onkohan luku pienempi kuin 0 tai suurempi kuin 100
On! :)
</pre>

<p>Seuraavassa käännetään <code>!</code>:n eli negaatio-operaation avulla ehdon arvo päinvastaiseksi:</p>

<pre class="sh_java">
System.out.println("Eihän merkkijono ole 'maito'");
String merkkijono = "piimä";

if ( !(merkkijono.equals("maito")) ) {  // tosi jos ehto merkkijono.equals("maito") on epätosi
    System.out.println("ei ollut!");
} else {
    System.out.println("oli")
}
</pre>
<pre>
ei ollut!
</pre>

  <p>Monimutkaisten ehtojen muodostamisessa tarvitaan usein sulkuja:</p>
<pre class="sh_java">
int luku = 99;

if ( (luku &gt; 0 &amp;&amp; luku &lt; 10) || luku &gt; 100 ) {
    System.out.println("luku oli joko yhden ja yhdeksän väliltä tai yli sata");
} else {
    System.out.println("luku oli 0 tai pienempi tai väliltä 10-99");
}
</pre>
<pre>
luku oli 0 tai pienempi tai väliltä 10-99
</pre>
  <div class="tehtavat">
    <div class="tehtava">
    <h3 class="req">Iän tarkistus</h3>
    <p>Tee ohjelma, joka kysyy käyttäjän iän ja tarkistaa,
      että se on mahdollinen (ainakin 0 ja korkeintaan 120).</p>
<pre>
Kuinka vanha olet? <font color="red">10</font>
OK
</pre>
<pre>
Kuinka vanha olet? <font color="red">55</font>
OK
</pre>
<pre>
Kuinka vanha olet? <font color="red">-3</font>
Mahdotonta!
</pre>
<pre>
Kuinka vanha olet? <font color="red">150</font>
Mahdotonta!
</pre>
</div>
<div class="tehtava">
    <h3 class="req">Käyttäjätunnukset</h3>
    <p>Tee ohjelma, joka tunnistaa seuraavat käyttäjät:</p>
    <table border style="margin-left:50px">
      <tr>
        <th>tunnus</th>
        <th>salasana</th>
      </tr>
      <tr>
        <td>aleksi</td>
        <td>tappara</td>
      </tr>
      <tr>
        <td>elina</td>
        <td>kissa</td>
      </tr>
    </table>
    <p>Ohjelma näyttää käyttäjälle henkilökohtaisen viestin
      tai ilmoittaa, jos tunnus tai salasana on väärin.</p>
<pre>
Anna tunnus: <font color="red">aleksi</font>
Anna salasana: <font color="red">tappara</font>
Olet kirjautunut järjestelmään
</pre>
<pre>
Anna tunnus: <font color="red">elina</font>
Anna salasana: <font color="red">kissa</font>
Olet kirjautunut järjestelmään
</pre>
<pre>
Anna tunnus: <font color="red">aleksi</font>
Anna salasana: <font color="red">jokerit</font>
Virheellinen tunnus tai salasana!
</pre>

<p><strong>HUOM:</strong> muista, että merkkijonoja ei voi vertailla ==-operaatiolla!</p>
<p><strong>HUOM:</strong> Todellisuudessa kirjautumistoiminnallisuutta ei tule toteuttaa, eikä yleensä toteutetakkaan näin.</p>
</div>
<div class="tehtava">
    <h3 class="">Karkausvuosi</h3>
    <p>Vuosi on karkausvuosi, jos se on jaollinen 4:llä.
      Kuitenkin jos vuosi on jaollinen 100:lla,
      se on karkausvuosi vain silloin,
      kun se on jaollinen myös 400:lla.</p>
    <p>Tee ohjelma, joka tarkistaa, onko vuosi karkausvuosi.</p>
<pre>
Anna vuosi: <font color="red">2011</font>
Vuosi ei ole karkausvuosi.
</pre>
<pre>
Anna vuosi: <font color="red">2012</font>
Vuosi on karkausvuosi.
</pre>
<pre>
Anna vuosi: <font color="red">1800</font>
Vuosi ei ole karkausvuosi.
</pre>
<pre>
Anna vuosi: <font color="red">2000</font>
Vuosi on karkausvuosi.
</pre>
  </div>
</div>
  <h2 id="toiston_alkeet">Toiston alkeet</h2>
  <p>Valintakomennon avulla saamme ohjelman toimintaan mukaan ehdollisuutta, eli esim. jos käyttäjätunnus ja salasana ovat oikein, päästetään käyttäjä kirjautumaan ohjelmaan ja muuten ei.</p>
  <p>Ehdollisuuden lisäksi tarvitsemme toistoa: käyttäjätunnusta ja salasanaa pitää pystyä kysymään uudelleen niin kauan kunnes oikea käyttäjätunnus/salasana-pari on annettu.</p>
  <p>Yksinkertaisin toiston muoto on ikuinen toisto. Seuraava ohjelma tulostaa merkkijonoa <em>osaan ohjelmoida!</em> ikuisesti eli "äärettömän monta kertaa":</p>
<pre class="sh_java">
while ( true ) {
    System.out.println("osaan ohjelmoida!");
}
</pre>
  <p>Komento <code>while( true )</code> saa sen aikaan, että siihen liittyvää lohkoa, eli <code>{}</code>:lla ympäröityjä komentoja suoritetaan äärettömän monta kertaa.</p>
  <p>Ikuinen toisto ei yleensä ole se mitä halutaan. Toisto voidaan keskeyttää esim. komennolla <code>break</code>. </p>
<pre class="sh_java">
while ( true ) {
    System.out.println("osaan ohjelmoida!");

    System.out.print("jatketaanko (ei lopettaa)? ");
    String komento = lukija.nextLine();
    if ( komento.equals("ei") ) {
        break;
    }
}

System.out.println("kiitos ja kuulemiin.");
</pre>
  <p>Nyt toisto etenee siten että ensin tulostuu <em>osaan ohjelmoida!</em> ja tämän jälkeen ohjelma kysyy käyttäjältä jatketaanko vielä. Jos käyttäjä vastaa <em>ei</em>, suoritetaan komento <code>break</code> jonka ansiosta toisto lopetetaan ja suoritetaan komento joka tulostaa <em>kiitos ja kuulemiin.</em> </p>
<pre>
osaan ohjelmoida!
jatketaanko (ei lopettaa)? <font color="red">joo</font>
osaan ohjelmoida!
jatketaanko (ei lopettaa)? <font color="red">jawohl</font>
osaan ohjelmoida!
jatketaanko (ei lopettaa)? <font color="red">ei</font>
kiitos ja kuulemiin.
</pre>
  <p>Toiston sisällä voi tehdä erilaisia asioita. Seuraavassa yksinkertainen laskin. Laskin kysyy käyttäjältä komentoa. Komennossa <em>lopetus</em> suoritetaan <code>break</code> ja toisto loppuu. Tämän jälkeen kysytään kahta lukua. Jos komento oli <em>summa</em> lasketaan lukujen summa ja tulostetaan se.  Jos komento oli <em>erotus</em> toimitaan vastaavasti. Muussa tapauksessa ilmoitetaan että komento on tuntematon.</p>
<pre class="sh_java">
System.out.println("tervetuloa käyttämään laskinta");

while ( true ) {
    System.out.print("anna komento (summa, erotus, lopetus): ");
    String komento = lukija.nextLine();
    if ( komento.equals("lopetus") ) {
        break;
    }

    System.out.print("anna luvut ");
    int eka = Integer.parseInt(lukija.nextLine());
    int toka = Integer.parseInt(lukija.nextLine());

    if ( komento.equals("summa") ) {
        int summa = eka+toka;
        System.out.println( "lukujen summa " + summa );
    } else if ( komento.equals("erotus") ) {
        int erotus = eka-toka;
        System.out.println( "lukujen erotus " + erotus );
    } else {
        System.out.println( "tuntematon komento" );
    }

}
System.out.println("kiitos ja kuulemiin.");
</pre>
  <p>Screencast joka näyttää miten ohjelma syntyy:</p>
  <a class="ahy" href="http://www.youtube.com/watch?feature=player_embedded&v=ZPLBrgbxzqQ" height="300" target="_blank"><img src=" https://www.cs.helsinki.fi/group/java/k13/ohpe/img/youtube.jpg"/></a>
  <a class="amooc" href="http://www.youtube.com/watch?feature=player_embedded&v=ZPLBrgbxzqQ" height="300" target="_blank"><img src="https://www.cs.helsinki.fi/group/java/k13/ohpe/img/youtube.jpg"/></a>

<!--syntax ok-->
  <!--
<p><iframe allowfullscreen="" frameborder="0"  height="450" width="700" src="http://www.youtube.com/embed/cGxwzPF5s94"></iframe></p>
-->

  <div class="tehtavat">
    <div class="tehtava">
  <h3 class="req">Salasana</h3>
  <p>Tässä tehtävässä luodaan ohjelma joka kyselee käyttäjältä salasanaa. Jos salasana menee oikein, nähdään salainen viesti. </p>
<pre>
Anna salasana: <font color="red">nauris</font>
Väärin!
Anna salasana: <font color="red">lanttu</font>
Väärin!
Anna salasana: <font color="red">porkkana</font>
Oikein!

Salaisuus on: znvavbfgv grugl!
</pre>
  <p>Toteutetaan ohjelma kolmessa askeleessa.</p>
  <h4>Salasanan kysyminen</h4>
  <p>Testipalvelimelta tulevaan ohjelmarunkoon on määritelty muuttuja <code>String salasana</code>, jolle on asetettu arvoksi <code>porkkana</code> -- älä muuta tätä salasanaa. Toteuta lisätoiminnallisuus, jossa ohjelma kysyy käyttäjältä salasanaa ja vertailee sitä muuttujassa <code>salasana</code> olevaan arvoon. Muista mitä erityistä merkkijonojen vertailussa on!</p>
<pre>
Anna salasana: <font color="red">nauris</font>
Väärin!
</pre>
<pre>
Anna salasana: <font color="red">porkkana</font>
Oikein!
</pre>
<pre>
Anna salasana: <font color="red">bataatti</font>
Väärin!
</pre>
  <h4>Salasanan kysyminen kunnes käyttäjä vastaa oikein</h4>
  <p>Muokkaa ohjelmaa siten, että se kysyy salasanaa kunnes käyttäjä syöttää oikean salasanan. Toteuta salasanan jatkuva kysyminen <code>while-true</code> -toistolausekkeen avulla. Toistolausekkeesta pääsee pois, jos ja vain jos käyttäjän syöttämä salasana on sama kuin muuttujassa <code>salasana</code> oleva arvo.</p>
<pre>
Anna salasana: <font color="red">nauris</font>
Väärin!
Anna salasana: <font color="red">lanttu</font>
Väärin!
Anna salasana: <font color="red">porkkana</font>
Oikein!
</pre>
  <h4>Salainen viesti</h4>
  <p>Lisää ohjelmaan oma salainen viestisi joka näytetään kun käyttäjä kirjoittaa salasanan oikein. Se voi olla mitä tahansa!</p>
<pre>
Anna salasana: <font color="red">nauris</font>
Väärin!
Anna salasana: <font color="red">lanttu</font>
Väärin!
Anna salasana: <font color="red">porkkana</font>
Oikein!

Salaisuus on: znvavbfgv grugl!
</pre>
  <p>Ylläoleva salaisuus on salattu käyttäen <a href="http://fi.wikipedia.org/wiki/Rot13" target="_blank">Rot13</a>-algoritmia. Toteutamme myöhemmin tällä kurssilla oman salausohjelman.</p>
</div>
<div class="tehtava">
  <h3 class="req">Lämpötiloja</h3>
  <p>Saat tehtäväpohjan mukana komponentin nimeltään <code>Kuvaaja</code>. <code>Kuvaaja</code> piirtää
    sille annetuista luvuista kuvaajan. Lukuja annetaan kuvaajalle näin: </p>
<pre class="sh_java">
Kuvaaja.lisaaNumero(13.0);
</pre>
  <p>Teemme ohjelman, joka piirtää kuvaajan sille annetuista päivittäisistä lämpötiloista.</p>
  <h4>Kysely</h4>
  <p>Tee ohjelma, joka kysyy käyttäjältä liukulukuja (<code>double</code>) ja lisää ne kuvaajaan. Käytä jälleen <code>while-true</code>-rakennetta.</p>
  <p><strong>Huom:</strong><code>double</code>-luku luetaan seuraavasti <code>double luku = Double.parseDouble( lukija.nextLine() );</code></p>
  <p><strong>Huom2:</strong> ohjelmasi toimii "ikuisessa" silmukassa eli on tarkoitus että sen suoritus ei pääty koskaan. Saat ohjelmasi pysähtymään painamalla NetBeansin konsoli-ikkunan oikeassa laidassa olevaa punaista neliöä.</p>
  <p><strong>HUOM3:</strong> Tee kaikki muutokset tiedostoon <code>Lampotiloja.java</code>. Älä muokkaa tiedostoa <code>Kuvaaja.java</code></p>
  <h4>Tarkastus</h4>
  <p>Paranna edellistä ohjelmaasi niin, että lämpötilat jotka ovat alle -30 tai yli 40 jätetään lisäämättä.</p>
  </div>
  <div class="tehtava">

  <h3 class="req">Robottiohjain, versio 2</h3>

  <p>Robottimme on kehittynyt, sillä on silmät ja suunta! Huraa!</p>

  <p>Tässä tehtävässä ohjaamme robottia, jonka tehtävänä on työntää varastossa oleva laatikko rahtialueelle.</p>

  <p>Uusi robottimme ei enää kuuntele käskyjä "ylös", "alas", "vasemmalle" ja "oikealle", vaan se kulkee siihen suuntaan, mihin se osoittaa. Robottia voi kääntää komennoilla <code>Ohjain.vasen();</code> ja <code>Ohjain.oikea();</code>, jotka kääntävät robottia vastapäivään ja myötäpäivään. Robotin liikuttaminen tapahtuu komennoilla <code>Ohjain.liiku();</code>, joka siirtää robottia yhden askeleen robotin osoittamaan suuntaan, ja <code>Ohjain.liikuMonta(int montako);</code>, joka liikuttaa robottia annetun määrän askelia osoitettuun suuntaan.</p>

  <p>Robotin alkutilanteessa se suuntaa katseensa oikealle. Alla olevassa tilanteessa robottia on käännetty vasemmalle, jolloin sen katse suuntaa ylös, ja sitä on komennettu liikkumaan kolme kertaa.</p>

  <img src="http://www.cs.helsinki.fi/group/java/mooc-matsku/img/exercises/24-robotcontrol-start.png"/>

  <p>Tehtävä on jaettu useampaan osaan, joissa ensimmäisessä toteutetaan manuaalinen ohjaus robotille, ja seuraavissa kehitämme automaattista ohjausta.</p>

  <h4>Ohjaus komentoriviltä</h4>

  <p>Tässä tehtävässä tavoitteena on rakentaa robotille manuaalinen ohjaus. Rakenna ohjelma samalla tavalla kuin edellä oleva laskin-esimerkki. Ohjelman tulee seurata seuraavia komentoja:</p>

  <p>
    <ol>
      <li><em>sammuta</em> sammuttaa robottiohjaimen (komento <code>Ohjain.sammuta();</code>) ja poistuu ohjelmasta.</li>
      <li><em>vasen</em> kääntää robottia vasemmalle (komento <code>Ohjain.vasen();</code>).</li>
      <li><em>oikea</em> kääntää robottia oikealle (komento <code>Ohjain.oikea();</code>).</li>
      <li><em>liiku</em> liikuttaa robottia yhden askeleen (komento <code>Ohjain.liiku();</code>).</li>
      <li><em>liikuMonta</em> kysyy käyttäjältä askelten lukumäärää ja liikuttaa robottia halutun määrän (komento <code>Ohjain.liikuMonta(int montako);</code>).</li>
    </ol>
  </p>

  <p>Huom! Komento <code>Ohjain.sammuta()</code> sammuttaa vain robottiohjaimen, ei ohjelmaasi jonka kautta robottiohjainta käytetään. Avainsanasta <em>break</em> saattaa olla tässä hyötyä..</p>

  <p>Toteuta ohjelma siten, että ohjain suorittaa käyttäjän pyytämät komennot. Alla on esimerkki annetuista komennoista sekä kuva lopputilasta.</p>

<pre>
komento (sammuta, vasen, oikea, liiku, liikuMonta): liiku

komento (sammuta, vasen, oikea, liiku, liikuMonta): vasen

komento (sammuta, vasen, oikea, liiku, liikuMonta): liiku

komento (sammuta, vasen, oikea, liiku, liikuMonta): liiku

komento (sammuta, vasen, oikea, liiku, liikuMonta): oikea

komento (sammuta, vasen, oikea, liiku, liikuMonta): liikuMonta
Kuinka monta askelta: 3
</pre>

  <p><img src="http://www.cs.helsinki.fi/group/java/mooc-matsku/img/exercises/24-robotcontrol-keyboard.png"/></p>

  <p>Huom! Voit palauttaa tehtävän jo tässä välissä vaikka kaikki tehtävän osa-alueet eivät vielä menisikään läpi!</p>

  <h4>Automaattinen ohjaus</h4>

  <p>Lisää tekstikäyttöliittymään komento "ratkaise", joka siirtää laatikon loppualueelle. Ratkaisua ohjelmoidessa voit olettaa, että robotti aloittaa liikkumisen aina samasta ruudusta, ja että laatikko ja rahtialue ovat allaolevan kuvan näyttämissä kohdissa (sama kuin ohjelmassa).</p>

  <p><img src="http://www.cs.helsinki.fi/group/java/mooc-matsku/img/exercises/24-robotcontrol-init.png"/></p>

<pre>
komento (sammuta, vasen, oikea, liiku, liikuMonta, ratkaise): ratkaise
</pre>



  <h4>Parempi automaattinen ohjaus</h4>

  <p>Tehdään ohjauksesta parempi. Kuten aiemminkin, komennon "ratkaise" tulee siirtää laatikko rahtialueelle. Tässä tapauksessa tosin laatikko ei ole aina samassa paikassa, vaan se on tuotu satunnaisesti alueelle. Voit olettaa, että laatikko on aina robotin oikealla yläpuolella ja rahtialueen vasemmalla yläpuolella, robotti aloittaa liikkumisen aina samasta ruudusta, ja rahtialue on aina samassa ruudussa.</p>

  <p>Ohjelmoinnin mahdollistamiseksi Ohjaimeen on lisätty seuraavat komennot:</p>

<pre class="sh_java">
// kertoo robotin x- ja y-koordinaatit
int robottiX = Ohjain.robottiX();
int robottiY = Ohjain.robottiY();

// kertoo laatikon x- ja y-koordinaatit
int laatikkoX = Ohjain.laatikkoX();
int laatikkoY = Ohjain.laatikkoY();

// kertoo rahtialueen x- ja y-koordinaatit
int tavoiteX = Ohjain.tavoiteX();
int tavoiteY = Ohjain.tavoiteY();
</pre>

  <p>Yllä olevien optimaalisen reitin laskemista helpottavien komentojen lisäksi käytössä on komento <code>Ohjain.asetaLaatikkoSatunnaisesti();</code>, joka asettaa laatikon satunnaisesti pelialueelle. Kutsu sitä ennen käynnistystä seuraavasti:</p>

<pre class="sh_java">
public class Paaohjelma {

    public static void main(String[] args) {
        Scanner lukija = new Scanner(System.in);

        Ohjain.asetaLaatikkoSatunnaisesti();
        Ohjain.kaynnista();

        // toteuta ohjelma tänne

        // oma toteutuksesi, joka saattaa alkaa muodossa
        while (true) {
        // ...

</pre>


</div>
</div>
</div>
</section>
<div class="tyhja"></div>



<section class="viikkoraja" id="2">
<div class="viikkoraja">Viikko 2</div>
<div class="viikkoraja-mooc" id="Viikko 2" deadline="avautuu kun 85 %  1. viikosta tehty" data-first-chapter-index="11" data-first-exercise-index="25" data-first-week-index="2" data-first-chapter-index-mooc="11" data-first-exercise-index-mooc="25" data-first-week-index-mooc="2" tekija="Arto Vihavainen, Matti Luukkainen">



  <h2>Muuttuvat muuttujat</h2>
  <p>Olemassaolevan muuttujan arvoa halutaan usein muuttaa. Tämä onnistuu tavallisen sijoituslausekkeen avulla. Seuraavassa muuttujan <code>ika</code> arvoa kasvatetaan yhdellä:</p>
<pre class="sh_java">
int ika = 1;

System.out.println( ika );    // tulostuu 1
ika = ika + 1;                // ika:n uusi arvo on ika:n vanha arvo plus yksi
System.out.println( ika );    // tulostuu 2
</pre>
  <p>Komento <code>ika = ika + 1</code> siis kasvattaa muuttujan <code>ika</code> arvoa yhdellä. Muuttujan arvon kasvattaminen yhdellä onnistuu myös seuraavasti:</p>
<pre class="sh_java">
int ika = 1;

System.out.println( ika );    // tulostuu 1
ika++;                        // tarkoittaa samaa kuin ika = ika + 1;
System.out.println( ika );    // tulostuu 2
</pre>
  <p>Toinen esimerkki:</p>
<pre class="sh_java">
int pituus = 100;

System.out.println( pituus );   // tulostuu 100
pituus = pituus - 50;
System.out.println( pituus );   // tulostuu 50
pituus = pituus * 2;
System.out.println( pituus );   // tulostuu 100
pituus = pituus / 4;
System.out.println( pituus );   // tulostuu 25
pituus--;                       // sama kuin pituus = pituus-1;
System.out.println( pituus );   // tulostuu 24
</pre>
  <div class="tehtavat">
    <div class="tehtava" id="viikko2">

    <h3>Kolmen luvun summa</h3>
    <p>Tee ohjelma, joka kysyy käyttäjältä kolme lukua ja tulostaa niitten summan. Tee ohjelmastasi seuraavan muotoinen:</p>
<pre class="sh_java">
Scanner lukija = new Scanner(System.in);
int summa = 0;
int luettu;

// KIRJOITA OHJELMA TÄHÄN
// ÄLÄ KÄYTÄ MUITA MUUTTUJIA KUIN lukija, summa JA luettu!

System.out.println("Summa: "+summa);
</pre>
<pre>
Anna ensimmäinen luku: <font color="red">3</font>
Anna toinen luku: <font color="red">6</font>
Anna kolmas luku: <font color="red">12</font>

Summa: 21
</pre>
</div>
  <div class="tehtava">
    <h3>Useamman luvun summa</h3>
    <p>Tee ohjelma, joka lukee käyttäjältä lukuja ja tulostaa niiden summan. Ohjelma lopettaa kyselemisen kun syötetään luku 0. Käytä seuraavaa pohjaa, jonka saat myös palautusautomaatilta:</p>
<pre class="sh_java">
Scanner lukija = new Scanner(System.in);

int summa = 0;
System.out.print("Anna lukuja, nolla lopettaa: ");
while (true) {
    int luettu = Integer.parseInt(lukija.nextLine());
    if (luettu == 0) {
        break;
    }

    // TEE JOTAIN TÄÄLLÄ

    System.out.println("Summa nyt: "+summa);
}
System.out.println("Summa lopussa: "+summa);
</pre>
    <p>Ohjelman tulee toimia seuraavasti:</p>
    <pre>
Anna lukuja, nolla lopettaa:
<font color="red">3</font>
Summa nyt: 3
<font color="red">2</font>
Summa nyt: 5
<font color="red">1</font>
Summa nyt: 6
<font color="red">1</font>
Summa nyt: 7
<font color="red">0</font>
Summa lopussa: 7
</pre>
  </div>
</div>
  <h2 id="lisaa_toistoa">Lisää toistoa</h2>
  <p>Opimme aiemmin toteuttamaan <code>while(true)</code>-komennon avulla ohjelman, joka toistaa tiettyä komentosarjaa komennon <code>break</code> suorittamiseen asti.</p>
  <p>Komento <code>break</code> ei ole ainoa tapa lopettaa toistoa. Toistokomennon yleinen muoto on <code>while (ehto)</code>, jossa ehtona voi olla mikä tahansa totuusarvoinen lauseke, eli ehto voi olla täsmälleen samaa muotoa kuin <code>if</code>-komentojen ehdot.</p>
  <p>Seuraavassa esimerkissä tulostetaan luvut 1, 2, ..., 10.  Kun <code>luku</code>-muuttuja saa arvokseen yli 10, <code>while</code>-ehto ei ole enää voimassa ja toistaminen lopetetaan.</p>
<pre class="sh_java">
int luku = 1;

while (luku &lt; 11) {
    System.out.println(luku);
    luku++;    // luku++ tarkoittaa samaa kuin luku = luku + 1
}
</pre>
  <p>Lue ylläoleva "niin pitkään kuin luku on pienempi kuin 11, tulosta luku ja kasvata lukua yhdellä".</p>
  <p>Ylläolevassa koodissa ehdossa olevaa muuttujaa <code>luku</code> kasvatettiin jokaisella kierroksella
    yhdellä. Päivitys voi olla mikä tahansa, eli ehdossa olevan muuttujan ei tarvitse suinkaan aina kasvaa yhdellä, esim:</p>
<pre class="sh_java">
int luku = 1024;

while (luku &gt;= 1) {
    System.out.println(luku);
    luku = luku / 2;
}
</pre>
  <p>Screencast aiheesta:</p>
  <a class="ahy" href="http://www.youtube.com/watch?feature=player_embedded&v=us9GXUZ60ws" height="300" target="_blank"><img src=" https://www.cs.helsinki.fi/group/java/k13/ohpe/img/youtube.jpg"/></a>
  <a  class="amooc" href="http://www.youtube.com/watch?feature=player_embedded&v=us9GXUZ60ws" height="300" target="_blank"><img src="https://www.cs.helsinki.fi/group/java/k13/ohpe/img/youtube.jpg"/></a>

  <!--
<p>
  <iframe allowfullscreen="" frameborder="0"  height="450" width="700" src="http://www.youtube.com/embed/eZUaptgXwrU"></iframe></p>
-->

  <div class="help"> <big><b>Muutama NetBeans-vihje</b></big>
    <ul>
      <li> Kaikki NetBeans-vihjeet löytyvät
    <!-- BEGIN mini MOOC SNIP-->
    <a class="ahy" href="../../netbeans/">täältä</a>
    <!-- END mini MOOC SNIP-->
    <!-- BEGIN mini SNIP-->
    <a class="amooc" href="http://mooc.cs.helsinki.fi/ohjelmointi/ohjeita#netbeans">täältä</a>
    <!-- END mini SNIP-->
         </li>
      <li> <b>Koodin automaattinen täydennys</b>
        <p> Jos ohjelmassasi on käytössä esim. muuttuja <code>String sukunimi;</code>, ei koko muuttujan nimeä tarvitse välttämättä joka kerta kirjoittaa kokonaan. Kokeile mitä tapahtuu kun kirjoitat <code>s</code> ja sen jälkeen painat yhtäaikaa ctrl ja välilyönti. <b>HUOM:</b> laitoksen koneilla automaattinen täydennys saadaan aikaan painamalla yhtä aikaa ctrl, alt ja välilyönti.
          Vastaavalla tavalla NetBeans osaa täydentää muitakin nimiä, esim. komennon <code>while</code> aikaansaamiseksi riittää kirjoittaa w ja painaa ctrl+välilyönti... </p>
      <li> <b>sout</b>
        <p>Muista että saat ruudulle tekstin <em>System.out.println("")</em> kirjoittamalla <em>sout</em> ja painamalla <em>tabulaattoria</em> eli q:n vasemmalla puolella olevaa näppäintä </p>
      </li>
    </ul>
  </div>
  <!--syntax ok-->
  <!--div class="tehtavat"-->
  <div class="tehtavat">
    <p>Tee seuraavat tehtävät while-komennon avulla:</p>
    <div class="tehtava">
    <h3 class="req">Yhdestä sataan</h3>
    <p>Tee ohjelma, joka tulostaa kokonaisluvut väliltä 1&ndash;100.</p>
    <p>Ohjelman tulostus on seuraava:</p>
<pre>
1
2
3
(välissä paljon rivejä)
98
99
100
</pre>
</div>
<div class="tehtava">
    <h3 class="req">Sadasta yhteen</h3>
    <p>Tee ohjelma, joka tulostaa kokonaisluvut väliltä 100&ndash;1.</p>
    <p>Ohjelman tulostus on seuraava:</p>
<pre>
100
99
98
(välissä paljon rivejä)
3
2
1
</pre>
    <p><strong>Vihje:</strong> aseta toistossa käytettävän apumuuttujan arvoksi aluksi 100 ja vähennä muuttujan arvoa yhdellä toiston sisällä.</p>
    </div>
    <div class="tehtava">
    <h3 class="req">Parilliset luvut</h3>
    <p>Tee ohjelma, joka tulostaa parilliset kokonaisluvut väliltä 2&ndash;100.</p>
<pre>
2
4
6
(välissä paljon rivejä)
96
98
100
</pre>
</div>
<div class="tehtava">
    <h3 class="req">Lukuun asti</h3>
    <p>Kirjoita ohjelma, joka tulostaa kokonaisluvut 1:stä
      käyttäjän antamaan lukuun asti.</p>
<pre>
Mihin asti? <font color="red">3</font>
1
2
3
</pre>
<pre>
Mihin asti? <font color="red">5</font>
1
2
3
4
5
</pre>
    <p><strong>Vihje:</strong> käyttäjältä lukemasi luku toimii nyt whilen lopetusehdon ylärajana. Muista että Javassa <code>a &lt;= b</code> tarkoittaa <em>a pienempi tai yhtä suuri kuin b</em>.</p>
</div>
<div class="tehtava">
    <h3>Alaraja ja yläraja</h3>
    <p>Kirjoita ohjelma, joka kysyy käyttäjältä
      ensimmäisen ja viimeisen luvun
      ja tulostaa niiden välissä olevat luvut.</p>
<pre>
Ensimmäinen: <font color="red">5</font>
Viimeinen: <font color="red">8</font>
5
6
7
8
</pre>
    <p>Jos ensimmäinen on suurempi kuin viimeinen ei tulostu mitään:</p>
<pre>
Ensimmäinen: <font color="red">16</font>
Viimeinen: <font color="red">12</font>
</pre>
    <p><em>Huom!</em> muista että ala- ja yläraja voivat olla myös negatiivisia!</p>
  </div>
</div>
  <h3>Sijoitusoperaatiot</h3>
  <p>Koska vanhan muuttujan arvon muuttaminen on hyvin yleinen operaatio, on Javassa sitä varten
    erityiset sijoitusoperaatiot. </p>
<pre class="sh_java">
int pituus = 100;

pituus += 10;  // sama kuin pituus = pituus + 10;
pituus -= 50;  // sama kuin pituus = pituus - 50;
</pre>
  <p>Olemassaolevan muuttujan arvoa muuttava sijoitusoperaatio merkitään <code>muuttuja muutostyyppi= muutos</code>, esimerkiksi <code>muuttuja += 5</code>. Huomaa, että muuttujan tyyppi pitää aina kertoa ennen kuin sille voidaan asettaa arvo. Muuttuja tulee siis aina esitellä ennen kuin se on käytettävissä. Muuttujan esittely tapahtuu kertomalla muuttujan tyyppi ja nimi.</p>
  <p>Seuraava esimerkki ei toimi, sillä muuttujan <code>pituus</code> tyyppiä ei ole kerrottu.</p>
<pre class="sh_java">
pituus = pituus + 100;   // ei toimi!
pituus += 100;           // ei toimi!
</pre>
  <p>Kun tyyppi on kerrottu, laskutkin toimivat oikein.</p>
<pre class="sh_java">
int pituus = 0;
pituus = pituus + 100;
pituus += 100;

// muuttujan pituus arvo on 200
</pre>
  <p>Myös muille kuin yhteen- ja vähennyslaskuille on Javassa vastaavat sijoitusoperaatiot.</p>
<pre class="sh_java">
int pituus = 100;

pituus *= 10; // sama kuin pituus = 10 * pituus;
pituus /= 100; //sama kuin pituus = pituus / 100;
pituus %= 3;  // sama kuin pituus = pituus % 3;

// muuttujan pituus arvo 1
</pre>
  <p>Usein ohjelmissa esiintyy toisto jonka aikana muuttujaan lasketaan jokin toistosta riippuvainen arvo. Seuraava ohjelma laskee tulon 4*3 hieman kömpelöllä tavalla eli summana 3+3+3+3:</p>
<pre class="sh_java">
int tulos = 0;

int i = 0;
while ( i &lt; 4 ) {
    tulos = tulos + 3;
    i++;   // tarkoittaa samaa kuin i = i+1;
}
</pre>
  <p>Alussa <code>tulos = 0</code>. Toistossa muuttujan arvo nousee joka kierroksella 3:lla. Ja koska toistoja on 4, on lopulta muuttujan arvona siis 3*4. </p>
  <p>Käyttämällä yllä esiteltyä sijoitusoperaattoria, sama saadaan aikaan seuraavasti:</p>
<pre class="sh_java">
int tulos = 0;

int i = 0;
while ( i &lt; 4 ) {
    tulos += 3;      // tämä on siis sama kuin tulos = tulos + 3;
    i++;             // tarkoittaa samaa kuin i = i+1;
}
</pre>
<div class="tehtavat">
  <div class="tehtava">
    <h3 class="req">Lukusarjan summa</h3>
    <p>Tee ohjelma, joka laskee summan 1+2+3+...+n, missä n on käyttäjän syöttämä luku.</p>
    <p>Esimerkkitulostuksia:</p>
<pre>
Mihin asti? <font color="red">3</font>
Summa on 6
</pre>
    <p>Edellisessä esimerkissä laskettiin 1+2+3 = 6</p>
<pre>
Mihin asti? <font color="red">7</font>
Summa on 28
</pre>
    <p>Ja nyt laskettiin 1+2+3+4+5+6+7 = 28</p>
    <p><strong>Vihje:</strong> Tee ohjelma <code>while</code>-komennon avulla. Käytä ohjelmassasi apumuuttujaa toistokertojen muistamiseen. Lisää jokaisella toistokerralla toistokerrat muistavan muuttujan arvo apumuuttujaan johon lasket summan arvon.</p>
</div>
<div class="tehtava">
    <h3 class="req">Rajoitetun lukusarjan summa</h3>
    <p>Muuta edellistä tehtävää siten,
      että käyttäjä määrää summan laskemisen aloituskohdan.
      Voit olettaa, että käyttäjä antaa
      ensin pienemmän luvun ja sitten suuremman luvun.</p>
<p>Esimerkkitulostuksia:</p>
<pre>
Ensimmäinen: <font color="red">3</font>
Viimeinen: <font color="red">5</font>
Summa on 12
</pre>
<pre>
Ensimmäinen: <font color="red">2</font>
Viimeinen: <font color="red">8</font>
Summa on 35
</pre>
</div>
<div class="tehtava">
    <h3>Kertoma</h3>
    <p>Tee ohjelma, joka laskee luvun n kertoman.
      Kertoma n! lasketaan kaavalla 1*2*3*...*n.
      Esimerkiksi 4! = 1*2*3*4 = 24.
      Lisäksi on määritelty, että 0! = 1.</p>
<p>Esimerkkitulostuksia:</p>
<pre>
Anna luku: <font color="red">3</font>
Kertoma on 6
</pre>
<pre>
Anna luku: <font color="red">10</font>
Kertoma on 3628800
</pre>
</div>
<div class="tehtava">
    <h3>Potenssien summa</h3>
    <p>Tee ohjelma, joka laskee summan 2<sup>0</sup>+2<sup>1</sup>+2<sup>2</sup>+...+2<sup>n</sup>,
      missä n on käyttäjän syöttämä luku.
      Merkintä 2<sup>i</sup> tarkoittaa luvun 2 korottamista potenssiin i,
      esimerkiksi 2<sup>4</sup> = 2*2*2*2 = 16.
      Javassa merkintä a<sup>b</sup> ei ole käytössä,
      mutta potenssin voi laskea komennolla <code>Math.pow(luku, potenssi)</code>. Huom. komento palauttaa <code>double</code>-tyyppisen eli liukulukutyyppisen luvun. Liukulukutyyppisen luvun voi muuttaa kokonaisluvuksi ( <code>int</code>-tyyppiseksi ) seuraavasti: <code>int tulos = (int) Math.pow(2, 3)</code>. Lasku asettaa muuttujaan tulos laskun 2 potenssiin 3 arvon.</p>
    <p>Esimerkkitulostuksia:</p>
<pre>
Anna luku: <font color="red">3</font>
Tulos on 15
</pre>
<pre>
Anna luku: <font color="red">7</font>
Tulos on 255
</pre>
</div>
</div>
  <h3>Ikuinen silmukka</h3>
  <p>Yksi <em>suosituimmista</em> ohjelmointivirheistä toistolauseissa on tehdä vahingossa ikuinen silmukka. Seuraavassa yritetään tulostaa ruudulle 10 kertaa "En enää ikinä ohjelmoi ikuista silmukkaa":</p>
<pre class="sh_java">
int i = 0;

while( i&lt;10 ) {
    System.out.println("En enää ikinä ohjelmoi ikuista silmukkaa");
}
</pre>
  <p>Toistokertojen määrää kontrolloiva muuttuja <code>i</code> on aluksi 0 ja toistoja on tarkoitus tehdä niin kauan kuin <code>i&lt;10</code>. Käy kuitenkin hieman hassusti: muuttujan <code>i</code> arvoa ei muuteta missään, joten toistoehto pysyy ikuisesti totena.</p>
  <h3>while ja lopetus</h3>
  <p>Olemme tehneet peräkkäin jo muutamia toistotehtäviä, joissa toistoehto on muotoa:</p>
<pre class="sh_java">
int i = 1;
while ( i &lt; 10 ) {
    // ...
    i++;
}
</pre>
  <p>Ylläolevassa rungossa muuttuja <code>i</code> muistaa toistokertojen määrän, ja lopetusehto perustuu <code>i</code>:n vertailuun.</p>
  <p>Muistellaan taas toiston lopetusta. Toiston lopetuksen ei tarvitse perustua toistokertojen laskemiseen. Katsotaan esimerkkiä jossa kysytään käyttäjän ikää. Jos ikä ei ole välillä 5-85, annetaan huomautus ja kysytään ikä uudelleen. Toistolauseen <em>while</em>-lauseen ehto voi siis olla mitä tahansa totuusarvon tuottavaa.</p>
<pre class="sh_java">
System.out.println("ikäsi: ");

int ika = Integer.parseInt(lukija.nextLine());

while( ika &lt; 5 || ika  &gt; 85 ) {   // ikä pienempi kuin 5 TAI suurempi kuin 85
    System.out.println("Valehtelet");
    if ( ika &lt; 5 ) {
        System.out.println("Olet niin nuori ettet osaa kirjoittaa");
    } else if ( ika &gt; 85 ) {
        System.out.println("Olet niin vanha ettet osaa käyttää tietokonetta");
    }

    System.out.println("syötä ikäsi uudelleen: ");
    ika = Integer.parseInt(lukija.nextLine();
}

System.out.println("Ikäsi on siis "+ ika);
</pre>
  <p>Ohjelman olisi voinut tehdä myös vanhaa tuttua <code>while(true)</code> -rakennetta käyttäen:</p>
<pre class="sh_java">
System.out.println("ikäsi: ");

while( true ) {
    int ika = Integer.parseInt(lukija.nextLine());

    if ( ika &gt;= 5 &amp;&amp; ika &lt;= 85 ) {   // ikä 5:n JA 85:n välillä
        break;                              // lopetetaan toisto
    }

    System.out.println("Valehtelet");
    if ( ika &lt; 5 ) {
        System.out.println("Olet niin nuori ettet osaa kirjoittaa");
    } else {  // ikä siis yli 85
        System.out.println("Olet niin vanha ettet osaa käyttää tietokonetta");
    }

    System.out.println("syötä ikäsi uudelleen: ");
}

System.out.println("Ikäsi on siis "+ ika);
</pre>
  <div class="tehtavat">
  <div class="tehtava">
    <h3>Silmukat, lopetus ja muistaminen</h3>
    <p>Tämä tehtäväsarja muodostaa yhden isomman ohjelman, jonka toiminnallisuus toteutetaan pienissä paloissa. <strong>Jos et tee tehtäväsarjaa loppuun asti, voit lähettää sen tarkastettavaksi vajaatekoisenakin. Tämä onnistuu painamalla testausnapin oikealla puolella olevasta "submit"-napista eli pienestä ylöspäinosoittavasta nuolesta</strong>. Vaikka palautusautomaatti valittaakin vielä tekemättä olevien tehtävänosien testeistä, kirjautuvat jo tekemiesi osien pisteet. </p>
    <p>Huom: nyt (ja jatkossa) jokainen isomman tehtävän "alitehtävä" (kuten 36.1) on saman arvoinen tehtävä kuin alikohdaton tehtävä. Tehtävä 36 siis vastaa viittä normaalia tehtävää.</p>
    <h4 class="req">Lukujen lukeminen</h4>
    <p> Tee ohjelma, joka kysyy käyttäjältä lukuja (ohjelma tulostaa käyttäjälle aluksi "Syötä luvut:"), kunnes käyttäjä antaa luvun -1. Kun käyttäjä syöttää luvun -1, ohjelma tulostaa "Kiitos ja näkemiin!" ja päättyy. </p>
<pre>
Syötä luvut:
<font color="red">5</font>
<font color="red">2</font>
<font color="red">4</font>
<font color="red">-1</font>
Kiitos ja näkemiin!
</pre>
    <h4 class="req">Lukujen summa</h4>
    <p>Laajenna edellistä ohjelmaa siten, että ohjelma ilmoittaa käyttäjän syöttämien lukujen summan.
      (Lukua -1 ei lasketa mukaan.)</p>
<pre>
Syötä luvut:
<font color="red">5</font>
<font color="red">2</font>
<font color="red">4</font>
<font color="red">-1</font>
Kiitos ja näkemiin!
Summa: 11
</pre>
    <h4 class="req">Lukujen summa ja lukumäärä</h4>
    <p>Laajenna edellistä ohjelmaa siten, että ohjelma ilmoittaa myös
      käyttäjien antamien lukujen lukumäärän.
      (Lukua -1 ei lasketa mukaan.)</p>
<pre>
Syötä luvut:
<font color="red">5</font>
<font color="red">2</font>
<font color="red">4</font>
<font color="red">-1</font>
Kiitos ja näkemiin!
Summa: 11
Lukuja: 3
</pre>
    <h4 class="req">Lukujen keskiarvo</h4>
    <p>Muuta edellistä ohjelmaa siten, ohjelma ilmoittaa lukujen keskiarvon.
      (Lukua -1 ei lasketa mukaan.)</p>
<pre>
Syötä luvut:
<font color="red">5</font>
<font color="red">2</font>
<font color="red">4</font>
<font color="red">-1</font>
Kiitos ja näkemiin!
Summa: 11
Lukuja: 3
Keskiarvo: 3.666666666666
</pre>
    <h4 class="req">Parilliset ja parittomat</h4>
    <p>Laajenna edellistä ohjelmaa siten, että  ohjelma ilmoittaa parillisten ja
      parittomien lukujen määrän.
      (Lukua -1 ei lasketa mukaan.)</p>
<pre>
Syötä luvut:
<font color="red">5</font>
<font color="red">2</font>
<font color="red">4</font>
<font color="red">-1</font>
Kiitos ja näkemiin!
Summa: 11
Lukuja: 3
Keskiarvo: 3.666666666666
Parillisia: 2
Parittomia: 1
</pre>
</div>
</div>
  <div> <big><b>Huomio: Ohjelmien tekeminen pienissä paloissa</b></big>
    <p>Edeltävissä tehtävissä tehtiin oikeastaan ainoastaan yksi ohjelma, mutta ohjelman rakentaminen tapahtui hyvin pienissä paloissa. Tämä on ehdottoman suositeltava tapa <b>AINA</b> kun ohjelmoit. </p>
    <p>Eli kun teet ohjelmaa, oli se sitten harjoitustehtävä tai oma projektisi, kannattaa edetä hyvin pienissä paloissa. Älä koskaan yritä ratkaista koko ongelmaa kerralla. Aloita jollain helpolla asialla jonka tiedät varmasti osaavasi. Esim. edellisessä tehtäväsarjassa keskityttiin aluksi pelkästään siihen, että osataan pysäyttää ohjelma käyttäjän syöttäessä luvun -1. Kun yksi ohjelman osa on saatu toimimaan, voidaan siirtyä ratkaisemaan jotain seuraavaa varsinaisen ongelman osaongelmaa. </p>
    <p>Osa kurssin tehtäviä on edellisten tapaan valmiiksi osiin pilkottuja. Usein osat pitää vielä pilkkoa ohjelmoinnin kannalta vieläkin pienempiin paloihin. Kannattaa tehdä siten, että suoritat ohjelman lähes jokaisen uuden koodirivin jälkeen. Tällöin varmistat, että ratkaisu on etenemässä haluttuun suuntaan.</p>
  </div>

  <div class="ekstra">
    <p> <big><strong>Lisätietoa: toisto for-lauseen avulla</strong></big> </p>
    <p>Edellä esitellyn while-toistolauseen lisäksi Javassa toiston voi hoitaa myös for-toistolauseen avulla. Varsinaisesti rupeamme käyttämään for:ia vasta hieman myöhemmin kurssilla, mutta jo tässä vaiheessa mainittakoon, että toistolause</p>
<pre class="java">
int i = 0;
while ( i &lt; 10 ) {
    System.out.println( i );
    i++;
}
</pre>
    <p>tehtäisiin for:in avulla seuraavasti:</p>
<pre class="java">
for ( int i = 0; i &lt; 10 ; i ++ ) {
    System.out.println( i );
}
</pre>
    <p>eli for-komento sisältää samalla rivillä indeksimuuttujan alustuksen, toistoehton ja indeksimuuttujan kasvatuksen puolipistein eroteltuna. Voit unohtaa for:in olemassaolon toistaiseksi jos et halua sekoittaa päätäsi sen olemassaololla.</p>
  </div>
  <h2 id="metodit1">Metodit</h2>
  <p> Olemme käyttäneet useita erilaisia komentoja Javassa: sijoitusta, laskutoimituksia, vertailuja, if:iä ja whileä. Ruudulle tulostaminen on tehty "komentoa" <code>System.out.println()</code> käyttäen. Kahden luvun maksimi osataan laskea "komennolla" <code>Math.max()</code>. Tuttuja ovat myös <code>lukija.nextLine()</code> ja sen kanssa usein nähty <code>Integer.parseInt()</code>. </p>
  <p> Huomaamme, että jälkimmäinen joukko edellä lueteltuja komentoja poikkeaa if:istä ja while:stä ym. siinä, että komennon perässä on sulut ja joskus sulkujen sisällä komennolle annettava syöte. "Sulkuihin päättyvät" eivät oikeastaan olekaan komentoja vaan <strong>metodeja</strong>. </p>
  <p> Teknisesti ottaen metodi tarkoittaa koodinpätkää, jota voi kutsua muualta ohjelmakoodista. Koodirivi <code>System.out.println("olen metodille annettava parametri!")</code> siis tarkoittaa, että kutsutaan metodia, joka suorittaa ruudulle tulostamisen. Metodin suorituksen jälkeen palataan siihen kohtaa missä ennen metodikutsua oltiin menossa. Metodille suluissa annettua syötettä kutsutaan <i>metodin parametriksi</i>. </p>
  <p> Parametrin lisäksi metodilla voi olla <i>paluuarvo</i>. Esim. tuttu koodinpätkä: </p>
<pre class="java">
int luku = Integer.parseInt( lukija.nextLine() );
</pre>
  <p> sisältää kaksi metodikutsua. Ensin kutsutaan sisempänä olevaa metodia <code>lukija.nextLine</code>. Metodilla on paluuarvonaan käyttäjän syöttämä merkkijono. Seuraavaksi
    kutsutaan metodia <code>Integer.parseInt</code>. Metodikutsun parametrina on merkkijono jonka <code>lukija.nextLine</code>:n kutsu palautti ja metodin paluuarvona on merkkijonoa vastaava kokonaisluku.</p>
  <p> Metodin nimeen näyttää liittyvän piste, esim. <code>lukija.nextLine()</code>. Oikeastaan tässä metodin nimi onkin pisteen oikeanpuoleinen osa, eli <code>nextLine()</code>. Pisteen vasemmanpuoleinen osa, eli tässä <code>lukija</code> kertoo <strong>kenen metodista on kyse</strong>.
    Eli kyseessä on <em>lukijan</em> metodi nextLine. Opimme hiukan myöhemmin tarkemmin mistä tässä pisteen vasemmanpuoleisessa
    osassa on kyse. Tarkka lukija tietysti huomaa, että <code>System.out.println()</code>:ssa on "kaksi pistettä". Metodin nimi tässä
    on println, ja <code>System.out</code> on se kenen metodista on kyse. Karkeasti ottaen <code>System.out</code> tarkoittaa koneen näyttöä. </p>
  <p> Tähän mennessä käyttämämme metodit ovat kaikki olleet Javan valmiita metodeita. Nyt opettelemme tekemään omia metodeita. </p>
  <h2 id="metodit">Omat metodit</h2>
  <p>Olemme tähän mennessä ohjelmoineet ohjelmamme siten, että kaikki tapahtuu yhdessä jatkumossa ja koodia luetaan ylhäältä alas. </p>
  <p>Edellä mainittiin että "metodi tarkoittaa koodinpätkää, jota voi kutsua muualta ohjelmakoodista". Javan valmiita metodeja on käytetty jo oikeastaan ensimmäisestä ohjelmasta lähtien. </p>
  <p>Javan valmiiden metodien käytön lisäksi ohjelmoija voi kirjoittaa itse metodeja joita sovellus kutsuu. Oikeastaan on hyvin poikkeuksellista jos ohjelmassa ei ole yhtään itse kirjoitettua metodia. Tästälähtien lähes jokainen kurssilla tehty ohjelma sisältääkin itsekirjoitettuja metodeja.</p>
  <p>Ohjelmarunkoon metodit kirjoitetaan main:in aaltosulkeiden ulkopuolelle mutta kuitenkin "uloimmaisten" aaltosulkeiden sisäpuolelle, joko mainin ylä- tai alapuolelle</p>
<pre class="sh_java">
import java.util.Scanner;

public class OhjelmaRunko {
    // omia metodeja tänne

    public static void main(String[] args) {
        Scanner lukija = new Scanner(System.in);
        // ohjelmakoodi
    }

    // omia metodeja tai tänne
}
</pre>
  <p>Luodaan metodi <code>tervehdi</code>.</p>
<pre class="sh_java">
public static void tervehdi() {
    System.out.println("Terveiset metodimaailmasta!");
}
</pre>
  <p>Ja asetetaan se metodeille kuuluvalle paikalle.</p>
  <pre class="sh_java">
import java.util.Scanner;

public class OhjelmaRunko {
    public static void main(String[] args) {
        Scanner lukija = new Scanner(System.in);
        // ohjelmakoodi
    }

    // omat metodit
    public static void tervehdi() {
        System.out.println("Terveiset metodimaailmasta!");
    }
}
</pre>
  <p>Metodin määrittely sisältää kaksi osaa. Metodimäärittelyn ensimmäisellä rivillä on metodin nimi eli <i>tervehdi</i>. Nimen vasemmalla puolella tässä vaiheessa määreet <code>public static void</code>. Metodin nimen sisältävän rivin alla on aaltosulkeilla erotettu koodilohko, jonka sisälle kirjoitetaan metodin koodi, eli ne komennot jotka metodia kutsuttaessa suoritetaan. Metodimme <code>tervehdi</code> ei tee muuta kuin kirjoittaa rivillisen tekstiä ruudulle.</p>
  <p>Itsekirjoitetun metodin kutsu on helppoa, kirjoitetaan metodin nimi ja perään sulut ja puolipiste. Seuraavassa main eli pääohjelma kutsuu metodia ensin kerran ja sen jälkeen useita kertoja. </p>
<pre class="sh_java">
import java.util.Scanner;

public class OhjelmaRunko {
    public static void main(String[] args) {
        Scanner lukija = new Scanner(System.in);

        // ohjelmakoodi
        System.out.println("Kokeillaan pääsemmekö metodimaailmaan:");
        tervehdi();

        System.out.println("Näyttää siltä, kokeillaan vielä:");
        tervehdi();
        tervehdi();
        tervehdi();
    }

    // omat metodit
    public static void tervehdi() {
        System.out.println("Terveiset metodimaailmasta!");
    }
}
</pre>
  <p>Ohjelman suoritus saa aikaan seuraavan tulosteen: </p>
<pre>
Kokeillaan pääsemmekö metodimaailmaan:
Terveiset metodimaailmasta!
Näyttää siltä, kokeillaan vielä:
Terveiset metodimaailmasta!
Terveiset metodimaailmasta!
Terveiset metodimaailmasta!
</pre>
  <p>Huomionarvoista tässä on koodin suoritusjärjestys. Koodin suoritus etenee siten, että pääohjelman --  eli main:in -- rivit suoritetaan ylhäältä alas yksi kerrallaan. Koodirivin ollessa metodikutsu, mennään suorittamaan metodin koodirivit, jonka jälkeen palataan kohtaan, josta metodin kutsu tapahtui. Tarkemmin ottaen metodikutsun jälkeiselle riville. </p>
  <p>Jos ollaan tarkkoja on pääohjelma eli main itsekin metodi. Kun ohjelma käynnistyy, kutsuu käyttöjärjestelmä main:ia. Metodi main on siis ohjelman käynnistyspiste, jonka ylimmältä riviltä ohjelman suoritus lähtee liikkeelle. Ohjelman suoritus loppuu kun päädytään mainin loppuun. </p>
  <p>Jatkossa kun esittelemme metodeja, emme erikseen mainitse että niiden täytyy sijaita omalla paikallaan.  Metodia ei esimerkiksi voi määritellä toisen metodin sisällä.</p>
<div class="tehtavat">
  <div class="tehtava">
    <h3 class="req">Tekstin tulostus</h3>
    <p>Tee metodi <code>tulostaTeksti</code>, joka tulostaa
      tekstin "Alussa olivat suo, kuokka ja Java." sekä rivinvaihdon.</p>
<pre class="sh_java">
public static void main(String[] args) {
    tulostaTeksti();
}

public static void tulostaTeksti() {
    // kirjoita koodia tähän
}
</pre>
    <p>Ohjelman tulostus:</p>
<pre>
Alussa olivat suo, kuokka ja Java.
</pre>
    </div>
    <div class="tehtava">
    <h3 class="req">Monta tulostusta</h3>
    <p>Laajenna edellistä ohjelmaa siten, että pääohjelma kysyy
      käyttäjältä, montako kertaa teksti tulostetaan eli montako kertaa
      metodia kutsutaan.</p>
<pre class="sh_java">
public static void main(String[] args) {
    // kysy käyttäjältä, montako kertaa teksti tulostetaan
    // kutsu metodia tulostaTeksti while-komennon avulla useita kertoja
}

public static void tulostaTeksti() {
    // kirjoita koodia tähän
}
</pre>
<p>Ohjelman tulostus:</p>
<pre>
Kuinka monta?
<font color="red">7</font>
Alussa olivat suo, kuokka ja Java.
Alussa olivat suo, kuokka ja Java.
Alussa olivat suo, kuokka ja Java.
Alussa olivat suo, kuokka ja Java.
Alussa olivat suo, kuokka ja Java.
Alussa olivat suo, kuokka ja Java.
Alussa olivat suo, kuokka ja Java.
</pre>
    <p><strong>huom:</strong> tulosta kehote <em>Kuinka monta?</em> omalle rivilleen!</p>
  </div>
</div>

  <h3>Metodin parametrit</h3>
  <p>Metodista saa huomattavasti monikäyttöisemmän antamalla sille <em>parametreja</em>. Parametrit ovat muuttujia, jotka määritellään metodin ylimmällä rivillä metodin nimen jälkeen olevien sulkujen sisällä.  Kun metodia kutsutaan, sen parametreille annetaan arvot kutsuvaiheessa.</p>
  <p>Seuraavassa esimerkissä määritellään parametrillinen metodi <code>tervehdi</code>, jolla on String-tyyppinen parametri <code>nimi</code>.</p>
<pre class="sh_java">
public static void tervehdi(String nimi) {
    System.out.println("Hei " + nimi + ", terveiset metodimaailmasta!");
}
</pre>
  <p>Kutsutaan metodia <code>tervehdi</code> siten, että parametrin <code>nimi</code> arvoksi asetetaan ensimmäisellä kutsulla <code>Matti</code> ja toisella kutsulla <code>Arto</code>.</p>
<pre class="sh_java">
public static void main(String[] args) {
    tervehdi("Matti");
    tervehdi("Arto");
}
</pre>
<pre>
Hei Matti, terveiset metodimaailmasta!
Hei Arto, terveiset metodimaailmasta!
</pre>
  <p>Aivan kuten kutsuttaessa Javan valmista <code>System.out.println()</code>-metodia, voi oman metodin kutsussa parametrina käyttää monimutkaisempaa ilmausta: </p>
<pre class="sh_java">
public static void main(String[] args) {
    String nimi1 = "Antti";
    String nimi2 = "Mikkola";
    tervehdi( nimi1 + " " + nimi2 );

    int ika = 24;
    tervehdi("Juhana " + ika + " vuotta");
}
</pre>
<pre>
Hei Antti Mikkola, terveiset metodimaailmasta!
Hei Juhana 24 vuotta, terveiset metodimaailmasta!
</pre>
  <p>Molemmissa tapauksissa metodilla on edelleen vain 1 parametri. Parametrin arvo lasketaan ennen metodin kutsumista. Ensimmäisessä tapauksessa parametrin arvo saadaan merkkijonokatenaationa <code>nimi1 + " " + nimi2</code> joka siis on arvoltaan <i>Antti Mikkola</i> ja jälkimmäisessä tapauksessa merkkijonokatenaatiosta <code>"Juhana " + ika + " vuotta"</code>. </p>
  <h3>Monta parametria</h3>
  <p>Metodille voidaan määritellä useita parametreja.  Tällöin metodin kutsussa parametrit annetaan samassa järjestyksessä.</p>
<pre class="sh_java">
public static void tervehdi(String nimi, String mistaTerveiset) {
    System.out.println("Hei " + nimi + ", terveiset " + mistaTerveiset);
}
</pre>
<pre class="sh_java">
String kuka = "Matti";
String terveiset = "Kyröjoelta";

tervehdi(kuka, terveiset);
tervehdi(kuka, terveiset + " ja Kumpulasta");
</pre>
  <p>Jälkimmäisessä <code>tervehdi</code>-funktion kutsussa toinen parametri muodostetaan katenoimalla muuttujaan <code>terveiset</code> teksti <code>" ja Kumpulasta"</code>.  Tämä suoritetaan ennen varsinaista funktion suoritusta.</p>
<pre>
Hei Matti, terveiset Kyröjoelta
Hei Matti, terveiset Kyröjoelta ja Kumpulasta
</pre>
  <h3>Metodi kutsuu toista metodia</h3>
<p>main ei ole suinkaan ainoa joka voi kutsua metodeita. Metodit voivat kutsua myös toisiaan. Tehdään metodi <code>tervehdiMontaKertaa</code>, joka tervehtii käyttäjää useasti metodin <code>tervehdi</code> avulla:</p>
<pre class="sh_java">
public static void tervehdi(String nimi) {
    System.out.println("Hei " + nimi + ", terveiset metodimaailmasta!");
}

public static void tervehdiMontaKertaa(String nimi, int kerrat) {
    int i = 0;
    while ( i &lt; kerrat ) {
        tervehdi(nimi);
        i++;
    }

}

public static void main(String[] args) {
    tervehdiMontaKertaa("Antti", 3);
    System.out.println("ja");
    tervehdiMontaKertaa("Martin", 2);
}
</pre>
<p>Tulostuu:</p>
<pre>
Hei Antti, terveiset metodimaailmasta!
Hei Antti, terveiset metodimaailmasta!
Hei Antti, terveiset metodimaailmasta!
ja
Hei Martin, terveiset metodimaailmasta!
Hei Martin, terveiset metodimaailmasta!
</pre>
  <p>Screencast aiheesta:</p>
  <p><a class="ahy" href="http://www.youtube.com/watch?feature=player_embedded&v=sIosUNnRJVo" height="300" target="_blank"><img src=" https://www.cs.helsinki.fi/group/java/k13/ohpe/img/youtube.jpg"/></a>
  <a class="amooc" href="http://www.youtube.com/watch?feature=player_embedded&v=sIosUNnRJVo" height="300" target="_blank"><img src="https://www.cs.helsinki.fi/group/java/k13/ohpe/img/youtube.jpg"/></a> </p>
<div class="tehtavat">
 <div class="tehtava">
    <h3>Tulostelua</h3>
    <h4 class="req">Tähtien tulostus</h4>
    <p>Tee metodi <code>tulostaTahtia</code>,
      joka tulostaa annetun määrän tähtiä ja rivinvaihdon.</p>
    <p>Tee metodi seuraavaan runkoon:</p>
<pre class="sh_java">
private static void tulostaTahtia(int maara) {
    // yhden tähden saat tulostettua komennolla
    // System.out.print("*");
    // kutsu tulostuskomentoa n kertaa
    // tulosta lopuksi rivinvaihto komennolla
    // System.out.println("");
}

public static void main(String[] args) {
    tulostaTahtia(5);
    tulostaTahtia(3);
    tulostaTahtia(9);
}
</pre>
    <p>Ohjelman tulostus:</p>
<pre>
*****
***
*********
</pre>
    <p><b>huom:</b> moniosaisen tehtävät voi palauttaa palvelimelle (painamalla testausnapin oikealla puolella olevaa nappia) vaikka kaikki osat eivät olisikaan tehty. Palvelin valittelee tällöin tekemättömien osien testeistä, tehdyt osat palvelin kirjaa. </p>

    <h4>Neliön tulostus</h4>
    <p>Tee metodi <code>tulostaNelio(int sivunpituus)</code> joka tulostaa neliön käyttäen <code>tulostaTahtia</code>-metodia. Siis esimerkiksi kutsu <code>tulostaNelio(4)</code> tulostaa seuraavaa:</p>
<pre>
****
****
****
****
</pre>
    <p><b>Huom: </b> tehtävässä ei riitä että tulostus näyttää oikealta, tulostaNelio-metodin sisällä neliön "rivien" tulostus tulee tehdä tulostaTahtia-metodia käyttäen.</p>
    <p>Ohjelmaa tehdessäsi kannattaa varmistaa main:iin kirjoitetun testikoodin avulla että metodit toimivat vaaditulla tavalla.</p>
    <h4>Suorakulmion tulostus</h4>
    <p>Tee metodi <code>tulostaSuorakulmio(int leveys, int korkeus)</code> joka tulostaa suorakulmion käyttäen <code>tulostaTahtia</code>-metodia. Siis esimerkiksi kutsu <code>tulostaSuorakulmio(17,3)</code> tulostaa seuraavaa:</p>
<pre>
*****************
*****************
*****************
</pre>
    <h4>Vasemmalle nojaavan kolmion tulostus</h4>
    <p>Tee metodi <code>tulostaKolmio(int koko)</code> joka tulostaa kolmion käyttäen <code>tulostaTahtia</code>-metodia. Siis esimerkiksi kutsu <code>tulostaKolmio(4)</code> tulostaa seuraavaa:</p>
<pre>
*
**
***
****
</pre>
  </div>
  <div class="tehtava">
    <h3>Tulostelua Like A Boss</h3>
    <h4>Tähtirivin ja tyhjien tulostus</h4>
    <p>Tee metodi <code>tulostaTyhjaa(int maara)</code> joka tulostaa <code>maara</code> kappaletta välilyöntejä. Metodi ei tulosta rivinvaihtoa. </p>
    <p>Joudut myös joko kopioimaan edellisen tehtävän vastauksestasi metodin <code>tulostaTahtia</code> tai toteuttamaan sen uudelleen tämän tehtävän tehtäväpohjaan.</p>
    <h4>Oikealle nojaavan kolmion tulostus</h4>
    <p>Tee metodi <code>tulostaKolmio(int koko)</code> joka tulostaa kolmion käyttäen <code>tulostaTyhjaa</code>- ja <code>tulostaTahtia</code>-metodeja. Siis esimerkiksi kutsu <code>tulostaKolmio(4)</code> tulostaa seuraavaa:</p>
<pre>
   *
  **
 ***
****
</pre>
    <h4>Joulukuusen tulostus</h4>
    <p>Tee metodi <code>jouluKuusi(int korkeus)</code> joka tulostaa joulukuusen. Joulukuusi koostuu annetun korkuisesta kolmiosta ja jalasta. Jalka on kaksi tähteä korkea ja kolme tähteä leveä ja se on keskellä kolmion pohjaa.
      Kuusi tulee rakentaa käyttämällä tulostukseen metodeja <code>tulostaTyhjaa</code> ja <code>tulostaTahtia</code></p>
    <p>Esimerkiksi kutsu <code>jouluKuusi(4)</code> tulostaa seuraavaa:</p>
<pre>
   *
  ***
 *****
*******
  ***
  ***
</pre>
    <p>Kutsu <code>jouluKuusi(10)</code> tulostaa:</p>
      <pre>
         *
        ***
       *****
      *******
     *********
    ***********
   *************
  ***************
 *****************
*******************
        ***
        ***
</pre>
    <p><em>Huom:</em> Korkeuksien jotka ovat alle 3 ei tarvitse toimia!</p>
  </div>
<div class="tehtava">
    <h3 class="req">Numerovisa</h3>
    <p>Tässä tehtävässä luodaan seuraavanlainen numerovisa:</p>
<pre>
Arvaa luku: <font color="red">73</font>
Luku on pienempi, tehtyjä arvauksia: 1
Arvaa luku: <font color="red">22</font>
Luku on suurempi, tehtyjä arvauksia: 2
Arvaa luku: <font color="red">51</font>
Luku on suurempi, tehtyjä arvauksia: 3
Arvaa luku: <font color="red">62</font>
Luku on suurempi, tehtyjä arvauksia: 4
Arvaa luku: <font color="red">68</font>
Luku on suurempi, tehtyjä arvauksia: 5
Arvaa luku: <font color="red">71</font>
Luku on pienempi, tehtyjä arvauksia: 6
Arvaa luku: <font color="red">70</font>
Onneksi olkoon, oikein arvattu!
</pre>
    <h4>Numeron arvaaminen</h4>
    <p>Tehtävänannon mukana tulevassa ohjelmassa tulee mukana komento <code>arvoLuku</code>, joka arpoo luvun suljetulta väliltä [0, 100] (0 ja 100 ovat myös mahdollisia). Toteuta ohjelma jossa arvataan arvottua lukua kerran. Ohjelman tulee tulostaa joko "Luku on pienempi", "Luku on suurempi" tai "Onneksi olkoon, oikein arvattu!" riippuen käyttäjän antamasta luvusta.</p>
<pre>
Arvaa luku: <font color="red">12</font>
Luku on suurempi
</pre>
<pre>
Arvaa luku: <font color="red">66</font>
Luku on pienempi
</pre>
<pre>
Arvaa luku: <font color="red">42</font>
Onneksi olkoon, oikein arvattu!
</pre>
    <h4>Toistuva arvaaminen</h4>
    <p>Lisää ohjelmaan toiminnallisuus jossa arvausta tehdään toistuvasti kunnes käyttäjä syöttää oikean numeron. Huomaa, että sinun tulee arpoa numero komentoa <code>arvoLuku</code> <em>ennen toistolauseketta</em>. Miksi? Mitä tapahtuu, jos luku arvotaan toistolausekkeen sisällä?</p>
    <p>Alla olevassa esimerkissä kutsu komentoon <code>arvoLuku</code> palautti arvon 83.</p>
<pre>
Arvaa luku: <font color="red">55</font>
Luku on suurempi
Arvaa luku: <font color="red">85</font>
Luku on pienempi
Arvaa luku: <font color="red">77</font>
Luku on suurempi
Arvaa luku: <font color="red">81</font>
Luku on suurempi
Arvaa luku: <font color="red">83</font>
Onneksi olkoon, oikein arvattu!
</pre>
    <h4>Arvauskertojen laskeminen</h4>
    <p>Lisää ohjelmaan kokonaislukutyyppinen muuttuja, jonka avulla pidetään kirjaa tehtyjen arvausten määrästä. Tulosta arvausten määrä aina arvauksen yhteydessä.</p>
<pre>
Arvaa luku: <font color="red">55</font>
Luku on suurempi, tehtyjä arvauksia: 1
Arvaa luku: <font color="red">85</font>
Luku on pienempi, tehtyjä arvauksia: 2
Arvaa luku: <font color="red">77</font>
Luku on suurempi, tehtyjä arvauksia: 3
Arvaa luku: <font color="red">81</font>
Luku on suurempi, tehtyjä arvauksia: 4
Arvaa luku: <font color="red">83</font>
Onneksi olkoon, oikein arvattu!
</pre>
  </div>
<div class="tehtava">
  <h3 class="req">Tekstikäyttöliittymä hirsipuu-pelille</h3>
  <p>Kaverisi ohjelmoi käyttöösi Hirsipuu-pelin, jolta puuttuu vielä käyttöliittymätoiminnallisuus. Hirsipuulla on seuraavat metodit:</p>
  <ul>
    <li><em>hirsipuu.peliKaynnissa()</em><br />
      Kertoo onko peli käynnissä. </li>
    <li><em>hirsipuu.tulostaTilanne()</em><br />
      Tulostaa pelin tilanteen. Kertoo tehtyjen arvausten määrän ja käyttämättömät kirjaimet.</li>
    <li><em>hirsipuu.tulostaSana()</em><br />
      Tulostaa arvattavan sanan. Pelin aikana arvaamattomat kirjaimet on piilotettu kysymysmerkein, esimerkiksi "muu??uja".</li>
    <li><em>hirsipuu.tulostaUkko()</em><br />
      Piirtää hirsipuun.</li>
    <li><em>hirsipuu.arvaa(String kirjain)</em><br />
      Arvaa onko sanassa parametrina annettava kirjain.</li>
  </ul>
  <p>Käytössäsi on palautusautomaatista tuleva ohjelmarunko, jossa on jo hieman toiminnallisuutta:</p>
<pre class="sh_java">
Scanner lukija = new Scanner(System.in);
Hirsipuu hirsipuu = new Hirsipuu();

System.out.println("************");
System.out.println("* HIRSIPUU *");
System.out.println("************");
System.out.println("");
tulostaValikko();
System.out.println("");

// OHJELMOI TOTEUTUKSESI TÄNNE

System.out.println("Kiitos pelistä!");
</pre>
  <p>Rungon lisäksi käytössäsi on metodi <code>tulostaValikko</code>:</p>
<pre class="sh_java">
public static void tulostaValikko() {
    System.out.println(" * valikko *");
    System.out.println("lopeta   - lopettaa pelin");
    System.out.println("tilanne  - tulostaa tarkemman tilanteen");
    System.out.println("yksittäinen kirjain arvaa annettua kirjainta");
    System.out.println("tyhjä rivi tulostaa tämän valikon");
}
</pre>
  <p>Tehtävä toteutetaan pienissä osissa.</p>
  <h4>Toistolauseke ja siitä poistuminen</h4>
  <p>Luo ohjelmaan toistolauseke, joka toimii käyttöliittymän pohjana. Lue toistolausekkeen sisällä käyttäjältä komento. Jos komento on "lopeta", poistu toistolauseesta.</p>
  <p>Käytä whilen ehtona komentoa <code>hirsipuu.peliKaynnissa()</code>, eli toisto on muotoa:</p>
<pre class="sh_java">
while (hirsipuu.peliKaynnissa()) {
  String komento = lukija.nextLine();
  // ...
}
</pre>
  <p>Ensi viikolla ymmärrämme mistä tässä hieman erikoiselta näyttävässä toiston lopetusehdossa on tarkkaan ottaen kysymys.</p>
  <p>Tässä vaiheessa ohjelman tulisi toimia seuraavasti:</p>
<pre>
************
* HIRSIPUU *
************

* valikko *
lopeta   - lopettaa pelin
tilanne  - tulostaa tarkemman tilanteen
yksittäinen kirjain arvaa annettua kirjainta
tyhjä rivi tulostaa tämän valikon

Anna komento:
<font color="red">ei lopeta</font>

Anna komento:
<font color="red">lopeta</font>
Kiitos pelistä!
</pre>
  <h4>Tilanteen näyttäminen</h4>
  <p>Jos käyttäjä syöttää merkkijonon "tilanne", tulosta tilanne  metodin <code>hirsipuu.tulostaTilanne()</code> avulla.</p>
<pre>
************
* HIRSIPUU *
************

* valikko *
lopeta   - lopettaa pelin
tilanne  - tulostaa tarkemman tilanteen
yksittäinen kirjain arvaa annettua kirjainta
tyhjä rivi tulostaa tämän valikon

Anna komento:
<font color="red">tilanne</font>
Et ole vielä tehnyt yhtään arvausta.
Käyttämättömät kirjaimet: abcdefghijklmnopqrstuvwxyzåäö

Anna komento:
<font color="red">lopeta</font>
Kiitos pelistä!
</pre>
  <h4>Arvauksen tekeminen</h4>
  <p>Jos käyttäjä kirjoittaa komentona yhden merkin pituisen merkkijonon, eli yksittäisen kirjaimen, käytä syötettä arvaamiseen. Arvaaminen tapahtuu metodilla <code>hirsipuu.arvaa(komento)</code>. Arvauskomennolla on oma tulostustoiminnallisuus, jolla se tulostaa lisätietoa arvauksen onnistumisesta.</p>
  <p><b>Vihje:</b> komennon toteaminen yksittäiseksi kirjaimeksi onnistuu seuraavasti:</p>
  <pre class="sh_java">
String komento = lukija.nextLine();

if(komento.length() == 1) {  // komento on vain yksi kirjain, eli kyseessä on arvaus
    hirsipuu.arvaa(komento);
}
</pre>
<pre>
...
Anna komento:
<font color="red">a</font>
Kirjainta a ei löytynyt sanasta.

Anna komento:
<font color="red">b</font>
Kirjainta b ei löytynyt sanasta.

Anna komento:
<font color="red">c</font>
Kirjain c löytyi sanasta!

Anna komento:
<font color="red">lopeta</font>
Kiitos pelistä!
</pre>
  <h4>Valikon tulostaminen</h4>
  <p>Jos käyttäjä syöttää tyhjän merkkijonon, eli merkkijonon jonka pituus on nolla, kutsu metodia <code>tulostaValikko</code>. Huomaa, että metodi <code>tulostaValikko</code> ei liity Hirsipuu-peliin, vaan omaan ohjelmaasi.</p>
  <p><b>Vihje:</b> merkkijonon tyhjyyden tarkastaminen onnistuu seuraavasti:</p>
<pre class="sh_java">
String nalle = "puh";
if(nalle.isEmpty()) {
    System.out.println("Tyhjä merkkijono");
} else {
    System.out.println("Löytyipäs sieltä jotain!");
}
</pre>
  <h4>Pelitilanteen tulostaminen</h4>
  <p>Jos käyttäjä ei ole syöttänyt komentoa <code>lopeta</code>, kutsu toistolausekkeen lopussa hirsipuupelin komentoja <code>hirsipuu.tulostaUkko()</code> ja <code>hirsipuu.tulostaSana()</code>.</p>
<pre>
...
Anna komento:
<font color="red">a</font>
Kirjainta a ei löytynyt sanasta.
____
|
|
|
|
/|\
Arvattava sana: ????

Anna komento:
<font color="red">m</font>
Kirjain m löytyi sanasta!
____
|
|
|
|
/|\
Arvattava sana: m???

Anna komento:
<font color="red">lopeta</font>
Kiitos pelistä!
</pre></div>
</div>
</div>
</section>
<div class="tyhja"></div>



<section class="viikkoraja" id="3">
<div class="viikkoraja">Viikko 3</div>
<div class="viikkoraja-mooc" id="Viikko 3" deadline="avautuu kun 85 %  2. viikosta tehty" data-first-chapter-index="13" data-first-exercise-index="43" data-first-week-index="3" data-first-chapter-index-mooc="13" data-first-exercise-index-mooc="43" data-first-week-index-mooc="3" tekija="Arto Vihavainen, Matti Luukkainen">


  <h2>Lisää metodeista</h2>
  <p>Edellisellä viikolla opettelimme kirjoittamaan omia metodeja. Metodien avulla voimme jäsennellä ohjelmaa pienemmiksi hyvin nimetyiksi. selkeän tehtävän omaaviksi loogisiksi kokonaisuuksiksi. Tämä sekä helpottaa ongelmanratkaisua että parantaa ohjelman luettavuutta niin ohjelmoijan kuin ohjelmaa myöhemmin mahdollisesti ylläpitävänkin osalta. Tästä lähtien oikeastaan jokainen tekemämme ohjelma sisältää metodeita.</p>
  <p>Jatketaan edelleen metodien parissa.</p>
  <h3>Metodit ja muuttujien näkyvyys</h3>
  <p>Yritetään muuttaa metodin sisältä pääohjelman muuttujan arvoa.</p>
  <pre class="sh_java">
// pääohjelma
public static void main(String[] args) {
    int luku = 1;
    kasvataKolmella();
}

// metodi
public static void kasvataKolmella() {
    luku = luku + 3;
}
</pre>
  <p>Ohjelma ei kuitenkaan toimi, sillä metodi ei näe pääohjelman muuttujaa <code>luku</code>.</p>
  <p>Yleisemminkin voi todeta, että pääohjelman muuttujat eivät näy metodien sisään, ja metodin muuttujat eivät näy muille metodeille tai pääohjelmalle. Ainoa keino viedä metodille tietoa ulkopuolelta on parametrin avulla.</p>
  <pre class="sh_java">
// pääohjelma
public static void main(String[] args) {
    int luku = 1;
    System.out.println("Pääohjelman muuttujan luku arvo: " + luku);
    kasvataKolmella(luku);
    System.out.println("Pääohjelman muuttujan luku arvo: " + luku);
}

// metodi
public static void kasvataKolmella(int luku) {
    System.out.println("Metodin parametrin luku arvo: " + luku);
    luku = luku + 3;
    System.out.println("Metodin parametrin luku arvo: " + luku);
}
</pre>
  <p>Yllä metodilla kasvataKolmella on parametri <code>luku</code>. Parametri luku <em>kopioidaan</em> metodin käyttöön. Kun yllä oleva ohjelma suoritetaan, nähdään seuraavanlainen tulostus.</p>
  <pre>
Pääohjelman muuttujan luku arvo: 1
Metodin parametrin luku arvo: 1
Metodin parametrin luku arvo: 4
Pääohjelman muuttujan luku arvo: 1
</pre>
  <p>Parametrina annettu luku siis <em>kopioitiin</em> metodin käyttöön. Jotta saisimme luvun uuden arvon myös pääohjelmaan, tulee metodin palauttaa arvo.</p>
  <h3>Metodin paluuarvot</h3>
  <p>Metodi voi palauttaa arvon. Tähän mennessä kurssilla olleissa esimerkeissä ja tehtävissä metodit eivät palauttaneet mitään. Tämä on merkitty kirjoittamalla metodin ylimmälle riville heti nimen vasemmalle puolelle <em>void</em>.</p>
  <pre class="sh_java">
public static void kasvataKolmella() {
...
</pre>
  <p> Arvon palauttavaa metodia määriteltäessä täytyy määritellä myös palautettavan arvon tyyppi. Paluuarvon tyyppi merkitään metodin nimen vasemmalle puolelle. Seuraavassa metodi joka palauttaa aina kokonaisluvun 10, metodin tyyppi on <code>int</code>. Palautus tapahtuu komennolla return: </p>
  <pre class="sh_java">
public static int palautetaanAinaKymppi() {
    return 10;
}
</pre>
  <p>Jotta metodin palauttamaa arvoa voisi käyttää, tulee paluuarvo ottaa talteen muuttujaan:</p>
  <pre class="sh_java">
public static void main(String[] args) {
    int luku = palautetaanAinaKymppi();

    System.out.println( "metodi palautti luvun " + luku );
}
</pre>
  <p>Metodin paluuarvo sijoitetaan <code>int</code>-tyyppiseen muuttujaan aivan kuin mikä tahansa muukin int-arvo. Paluuarvo voi toimia myös osana mitä tahansa lauseketta: </p>
  <pre class="sh_java">
double luku = 4 * palautetaanAinaKymppi() + (palautetaanAinaKymppi() / 2) - 8;

System.out.println( "laskutoimituksen tulos " + luku );
</pre>
  <p> Kaikki muuttujatyypit, mitä olemme tähän mennessä nähneet, voidaan palauttaa metodista:</p>
  <pre class="sh_java">
public static void metodiJokaEiPalautaMitaan() {
    // metodin runko
}

public static int metodiJokaPalauttaaKokonaisLuvun() {
    // metodin runko, tarvitsee return-komennon
}

public static String metodiJokaPalauttaaTekstin() {
    // metodin runko, tarvitsee return-komennon
}

public static double metodiJokaPalauttaaLiukuluvun() {
    // metodin runko, tarvitsee return-komennon
}
</pre>
  <p>Jos metodille määritellään paluuarvo, on sen myös pakko palauttaa arvo, esimerkiksi seuraava metodi on virheellinen.</p>
  <pre class="sh_java">
public static String virheellinenMetodi() {
    System.out.println("Väitän palauttavani merkkijonon, mutten palauta sitä.");
}
</pre>
  <p>Seuraavassa esimerkissä määritellään metodi summan laskemiseen.  Tämän jälkeen metodia käytetään laskemaan luvut 2 ja 7 yhteen. Metodikutsusta saatava paluuarvo asetetaan muuttujaan <code>lukujenSumma</code>.</p>
  <pre class="sh_java">
public static int summa(int eka, int toka) {
    return eka + toka;
}
</pre>
  <p>Metodin kutsu:</p>
  <pre class="sh_java">
int lukujenSumma = summa(2, 7);
// lukujenSumma on nyt 9
</pre>
  <p>Laajennetaan edellistä esimerkkiä siten, että käyttäjä syöttää luvut.</p>
  <pre class="sh_java">
public static void main(String[] args) {
    Scanner lukija = new Scanner(System.in);

    System.out.print("Anna ensimmäinen luku: ");
    int eka = Integer.parseInt( lukija.nextLine() );

    System.out.print("Anna toinen luku: ");
    int toka = Integer.parseInt( lukija.nextLine() );

    System.out.print("Luvut ovat yhteensä: " + summa(eka,toka) );
}

public static int summa(int eka, int toka) {
    return eka + toka;
}
</pre>
  <p> Kuten huomataan, metodin paluuarvoa ei tarvitse välttämättä sijoittaa muuttujaan, se voi olla osana tulostuslausetta aivan kuten mikä tahansa muukin int-arvo.</p>
  <p>Huomaa, että metodin parametrien nimillä ja metodin kutsujan puolella määritellyillä muuttujan nimillä ei ole mitään tekemistä keskenään. Edellisessä esimerkissä sekä pääohjelman muuttujat että metodin parametrit olivat "sattumalta" nimetty samoin (eli <code>eka</code> ja <code>toka</code>). Seuraava toimisi aivan yhtä hyvin:</p>
  <pre class="sh_java">
public static void main(String[] args) {
    Scanner lukija = new Scanner(System.in);

    System.out.print("Anna ensimmäinen luku: ");
    int luku1 = Integer.parseInt( lukija.nextLine() );

    System.out.print("Anna toinen luku: ");
    int luku2 = Integer.parseInt( lukija.nextLine() );

    System.out.print("Luvut ovat yhteensä: " + summa(luku1, luku2) );
}

public static int summa(int eka, int toka) {
    return eka + toka;
}
</pre>
  <p>Nyt pääohjelman muuttujan <code>luku1</code> arvo kopioituu metodin parametrin <code>eka</code> arvoksi ja pääohjelman muuttujan <code>luku2</code> arvo kopioituu metodin parametrin <code>toka</code> arvoksi.</p>
  <p>Seuraavassa esimerkissä metodia summa kutsutaan kokonaisluvuilla, jotka saadaan <code>summa</code>-metodin paluuarvoina. </p>
  <pre class="sh_java">
int eka = 3;
int toka = 2;

int monenLuvunSumma = summa(summa(1, 2), summa(eka, toka));
// 1) suoritetaan sisemmät metodit:
//    summa(1, 2) = 3   ja summa(eka, toka) = 5
// 2) suoritetaan ulompi metodi:
//    summa(3, 5) = 8
// 3) muuttujan monenLuvunSumma arvoksi siis tulee 8

</pre>
  <h3>Metodin omat muuttujat</h3>
  <p>Seuraava metodi laskee syötteinään saamiensa lukujen keskiarvon. Metodi käyttää apumuuttujia <code>summa</code> ja <code>ka</code>. Metodin sisäisen muuttujan määrittely tapahtuu tutulla tavalla.</p>
  <pre class="sh_java">
public static double keskiarvo(int luku1, int luku2, int luku3) {

    int summa = luku1 + luku2 + luku3;
    double ka = summa / 3.0;

    return ka;
}
</pre>
  <p>Metodin kutsu voi tapahtua esim seuraavasti</p>
  <pre class="sh_java">
public static void main(String[] args) {
    Scanner lukija = new Scanner(System.in);

    System.out.print("Anna ensimmäinen luku: ");
    int eka = Integer.parseInt( lukija.nextLine() );

    System.out.print("Anna toinen luku: ");
    int toka = Integer.parseInt( lukija.nextLine() );

    System.out.print("ja kolmas luku: ");
    int kolmas = Integer.parseInt( lukija.nextLine() );

    double keskiarvonTulos = keskiarvo(eka, toka, kolmas);

    System.out.print("Lukujen keskiarvo: " + keskiarvonTulos );
}
</pre>
  <p>Huomaa että metodin sisäiset muuttujat <code>summa</code> ja <code>ka</code> eivät näy pääohjelmaan. Yksi yleinen aloittelijan virhe olisikin yrittää käyttää metodia seuraavasi:</p>
  <pre class="sh_java">
public static void main(String[] args) {
    // annetaan arvot muuttujille eka, toka ja kolmas

    keskiarvo(eka, toka, kolmas);

    // yritetään käyttää metodin sisäistä muuttujaa, EI TOIMI!
    System.out.print("Lukujen keskiarvo: " + ka );
}
</pre>
  <p>Myös seuraavanlaista virhettä näkee usein:</p>
  <pre class="sh_java">
public static void main(String[] args) {
    // annetaan arvot muuttujille eka, toka ja kolmas

    keskiarvo(eka, toka, kolmas);

    // yritetään käyttää pelkkää metodin nimeä, EI TOIMI!
    System.out.print("Lukujen keskiarvo: " + keskiarvo );
}
</pre>
  <p>Eli tässä yritettiin käyttää pelkkää metodin nimeä muuttujamaisesti. Toimiva tapa metodin tuloksen sijoittamisen apumuuttujaan lisäksi on suorittaa metodikutsu suoraan tulostuslauseen sisällä:</p>
  <pre class="sh_java">
public static void main(String[] args) {
    int eka = 3;
    int toka = 8;
    int kolmas = 4;

    // kutsutaan metodia tulostuslauseessa, TOIMII!
    System.out.print("Lukujen keskiarvo: " + keskiarvo(eka, toka, kolmas) );
}
</pre>
  <p>Tässä siis ensin tapahtuu metodikutsu joka palauttaa arvon 5.0 joka sitten tulostetaan tulostuskomennon avulla.</p>
  <p>Screencast aiheesta:</p>
  <a href="http://www.youtube.com/watch?feature=player_embedded&v=zEHvycTo81c" height="300" target="_blank"><img src=" https://www.cs.helsinki.fi/group/java/k13/ohpe/img/youtube.jpg"/></a>



  <div class="tehtavat" id="viikko3">
    <div class="tehtava">
    <h3 class="req">Lukujen summa</h3>
    <p>Tee metodi <code>summa</code>, joka laskee parametrina olevien lukujen summan.</p>
    <p>Tee metodi seuraavaan runkoon:</p>
<pre class="sh_java">
public static int summa(int luku1, int luku2, int luku3, int luku4) {
    // kirjoita koodia tähän
    // muista että metodissa on oltava (lopussa) return!
}

public static void main(String[] args) {
    int vastaus = summa(4, 3, 6, 1);
    System.out.println("Summa: " + vastaus);
}
</pre>
    <p>Ohjelman tulostus:</p>
<pre>
Summa: 14
</pre>
    <p><b>Huom:</b> kun tehtävässä sanotaan että metodin pitää <em>palauttaa</em> jotain, tarkoittaa tämä sitä että metodissa tulee olla määritelty paluutyyppi ja <code>return</code>-komento jolla haluttu asia palautetaan. Metodi ei itse tulosta (eli käytä komentoa <code>System.out.println(..)</code>), tulostuksen hoitaa metodin kutsuja, eli tässä tapauksessa pääohjelma.</p>
  </div>
  <div class="tehtava">
    <h3 class="req">Pienin</h3>
    <p>Tee metodi <code>pienin</code>, joka palauttaa parametrina saamistaan luvuista pienemmän arvon. Jos lukujen arvo on sama, voidaan palauttaa kumpi tahansa luvuista.</p>
    <pre class="sh_java">
public static int pienin(int luku1, int luku2) {
    // kirjoita koodia tähän
    // älä tulosta metodin sisällä mitään

    // lopussa oltava komento return
}

public static void main(String[] args) {
    int vastaus =  pienin(2, 7);
    System.out.println("Pienin: " + vastaus);
}
</pre>
    <p>Ohjelman tulostus:</p>
<pre>
Pienin: 2
</pre>
</div>
<div class="tehtava">
    <h3>Suurin</h3>
    <p>Tee metodi <code>suurin</code>, joka saa kolme lukua ja palauttaa niistä suurimman. Jos suurimpia arvoja on useita, riittää niistä jonkun palauttaminen. Tulostus tapahtuu pääohjelmassa.</p>
    <pre class="sh_java">
public static int suurin(int luku1, int luku2, int luku3) {
    // kirjoita koodia tähän
}

public static void main(String[] args) {
    int vastaus =  suurin(2, 7, 3);
    System.out.println("Suurin: " + vastaus);
}
</pre>
    <p>Ohjelman tulostus:</p>
    <pre>
Suurin: 7
</pre>
</div>
<div class="tehtava">
    <h3 class="req">Lukujen keskiarvo</h3>
    <p>Tee metodi <code>keskiarvo</code>, joka laskee parametrina olevien lukujen keskiarvon. Metodin sisällä tulee käyttää apuna tehtävän 43 metodia <code>summa</code>!</p>
    <p>Tee metodi seuraavaan runkoon:</p>
    <pre class="sh_java">
public static int summa(int luku1, int luku2, int luku3, int luku4) {
    // kopioi koodi tehtävästä 43
}

public static double keskiarvo(int luku1, int luku2, int luku3, int luku4) {
    // kirjoita koodia tähän
    // laske alkioiden summa kutsumalla metodia summa
}

public static void main(String[] args) {
    double vastaus = keskiarvo(4, 3, 6, 1);
    System.out.println("Keskiarvo: " + vastaus);
}

</pre>
    <p>Ohjelman tulostus:</p>
<pre>
Keskiarvo: 3.5
</pre>
    <p>Muistathan miten kokonaisluku (<tt>int</tt>) muutetaan desimaaliluvuksi (<tt>double</tt>)!</p>
  </div>
</div>
  <h2 id="merkkijonot">Merkkijonot</h2>
  <p> Tässä luvussa tutustaan tarkemmin Javan merkkijonoihin, eli <code>String</code>:eihin.
    Olemme jo käyttäneet <code>String</code>-tyyppisiä muuttujia tulostuksen yhteydessä sekä
    oppineet vertailemaan merkkijonoja toisiinsa. Merkkijonoja vertailtiin toisiinsa <em>kutsumalla</em> merkkijonon <code>equals()</code>-metodia. </p>
  <pre class="sh_java">
String elain = "Koira";

if( elain.equals("Koira") ) {
    System.out.println(elain + " sanoo vuh vuh");
} else if ( elain.equals("Kissa") ) {
    System.out.println(elain + " sanoo miau miau");
}
</pre>
  <p>Merkkijonoilta voi kysyä niiden pituutta kirjoittamalla merkkijonon perään <code>.length()</code> eli kutsumalla merkkijonolle sen pituuden kertovaa metodia. </p>
  <pre class="sh_java">
String banaani = "banaani";
String kurkku = "kurkku";
String yhdessa = banaani + kurkku;

System.out.println("Banaanin pituus on " + banaani.length());
System.out.println("Kurkku pituus on " + kurkku.length());
System.out.println("Sanan " + yhdessa + " pituus on " + yhdessa.length());
</pre>
  <p> Edellä kutsutaan metodia <code>length()</code> kolmelle eri merkkijonolle. Kutsu <code>banaani.length()</code> kutsuu nimenomaan merkkijonon <code>banaani</code> pituuden kertovaa metodia, kun taas <code>kurkku.length()</code> on merkkijonon <code>kurkku</code> pituuden kertovan metodin kutsu, jne.Pisteen vasemman puoleinen osa kertoo kenen metodia kutsutaan.</p>
  <p>Javassa on erillinen <code>char</code>-tietotyyppi kirjaimia varten. Yksittäiseen <code>char</code>-muuttujaan voi tallentaa yhden kirjaimen. Merkkijonolta voidaan kysyä sen kirjaimia kirjaimen paikan perusteella käyttämällä <code>charAt()</code>-metodia. <strong>Huomaa</strong> että laskeminen alkaa nollasta!</p>
  <pre class="sh_java">
String kirja = "Kalavale";

char merkki = kirja.charAt(3);
System.out.println("Kirjan neljäs kirjain on " + merkki); //tulostaa "a"
  </pre>
  <p>Koska merkkijonon kirjaimet numeroidaan (eli teknisemmin ilmaistuna merkkijonoja indeksoidaan) alkaen paikasta 0, on merkkijonon viimeisen kirjaimen numero eli indeksi "merkkijonon pituus miinus yksi", eli <code>kirja.charAt(kirja.length()-1)</code>. Esimerkiksi seuraava kaataa ohjelman: yritämme hakea kirjainta kohdasta jota ei ole olemassa.</p>
  <pre class="sh_java">
char merkki = kirja.charAt(kirja.length());
  </pre>
  <div class="help"> <big><b>NetBeans-vihje</b></big>
    <ul>
      <li> Kaikki NetBeans-vihjeet löytyvät

    <a class="ahy" href="../../netbeans/">täältä</a>
    <a class="amooc" href="http://mooc.cs.helsinki.fi/ohjelmointi/ohjeita#netbeans">täältä</a>
      <li> <b>Uudelleennimentä</b>
        <p>Muuttujat, metodit ja ensi viikolla opittavat luokat kannattaa nimetä kuvaavasti. Usein käy, että valittu nimi on hieman epäkuvaava ja tulee tarve nimen muuttamiselle. NetBeans:issa tämä on todella helppoa. Maalaa huono nimi jostain kohtaa koodiasi hiirellä. Paina (yhtäaikaa) ctrl ja r ja kirjoita muuttujalle/metodille uusi nimi. </p>
      </li>
    </ul>
  </div>
  <div class="tehtavat">
    <div class="tehtava">
    <h3 class="req">Nimen pituus</h3>
    <p>Tee ohjelma, joka kysyy käyttäjän nimen ja ilmoittaa,
      kuinka monta kirjainta siinä on.</p>
<pre>
Anna nimi: <font color="red">Pekka</font>
Kirjainmäärä: 5
</pre>
<pre>
Anna nimi: <font color="red">Katariina</font>
Kirjainmäärä: 9
</pre>
    <p><strong>Huom!</strong> Rakenna ohjelmasi niin että laitat pituuden
      laskemisen omaan metodiinsa: <code>public static int laskeKirjaimet(String merkkijono)</code>. Testit testaavat sekä
      metodia <code>laskeKirjaimet</code> että koko ohjelman toimintaa.</p>
    </div>
    <div class="tehtava">
    <h3 class="req">Ensimmäinen kirjain</h3>
    <p>Tee ohjelma, joka kysyy käyttäjän nimen ja ilmoittaa
nimen ensimmäisen kirjaimen.</p>
<pre>
Anna nimi: <font color="red">Pekka</font>
Ensimmäinen kirjain: P
</pre>
<pre>
Anna nimi: <font color="red">Katariina</font>
Ensimmäinen kirjain: K
</pre>
    <p><strong>Huom!</strong> Rakenna ohjelmasi niin että laitat
      ensimmäisen kirjaimen hakemisen omaan metodiinsa: <code>public static char
      ensimmainenKirjain(String merkkijono)</code>. Testit testaavat sekä
      metodia <code>ensimmainenKirjain</code> että koko ohjelman
      toimintaa.</p>
    </div>
    <div class="tehtava">
    <h3>Viimeinen kirjain</h3>
    <p>Tee ohjelma, joka kysyy käyttäjän nimen ja ilmoittaa
      nimen viimeisen kirjaimen.</p>
<pre>
Anna nimi: <font color="red">Pekka</font>
Viimeinen kirjain: a
</pre>
<pre>
Anna nimi: <font color="red">Katariina</font>
Viimeinen kirjain: a
</pre>
    <p><strong>Huom!</strong> Rakenna ohjelmasi niin että laitat
      viimeisen kirjaimen hakemisen omaan metodiinsa: <code>public static char
      viimeinenKirjain(String merkkijono)</code>. Testit testaavat sekä
      metodia <code>viimeinenKirjain</code> että koko ohjelman
      toimintaa.</p>
    </div>
    <div class="tehtava">
    <h3 class="req">Ensimmäiset kirjaimet erikseen</h3>
    <p>Tee ohjelma, joka kysyy käyttäjän nimen ja ilmoittaa
      sen kolme ensimmäistä kirjainta erikseen. Jos nimen pituus on alle kolme, ei ohjelma tulosta mitään. Tehtävässä ei edellytetä erillisten metodien luomista.</p>
<pre>
Anna nimi: <font color="red">Pekka</font>
1. kirjain: P
2. kirjain: e
3. kirjain: k
</pre>
<pre>
Anna nimi: <font color="red">me</font>
</pre>
    <p><strong>Huom:</strong> ole tässä ja seuraavassa tehtävässä erityisen tarkka tulostusasun suhteen! Tulostuksessa tulee olla yksi välilyönti sekä pisteen että kaksoispisteen jälkeen!</p>
  </div>
  <div class="tehtava">
    <h3 class="req">Kirjaimet erikseen</h3>
    <p>Tee ohjelma, joka kysyy käyttäjän nimen ja ilmoittaa
      sen kirjaimet erikseen. Tehtävässä ei edellytetä erillisen metodin luomista.</p>
<pre>
Anna nimi: <font color="red">Pekka</font>
1. kirjain: P
2. kirjain: e
3. kirjain: k
4. kirjain: k
5. kirjain: a
</pre>
    <p><b>Vihje: <code>while</code>-toistolauseesta on tässä apua!</b></p>
<pre>
Anna nimi: <font color="red">Katariina</font>
1. kirjain: K
2. kirjain: a
3. kirjain: t
4. kirjain: a
5. kirjain: r
6. kirjain: i
7. kirjain: i
8. kirjain: n
9. kirjain: a
</pre>
</div>
<div class="tehtava">
    <h3 class="req">Nimen kääntäminen</h3>
    <p>Tee ohjelma, joka kysyy käyttäjän nimen ja
      tulostaa sen väärinpäin. Erillistä metodia nimen kääntämiselle ei tarvitse tehdä.</p>
<pre>
Anna nimi: <font color="red">Pekka</font>
Väärinpäin: akkeP
</pre>
<pre>
Anna nimi: <font color="red">Katariina</font>
Väärinpäin: aniirataK
</pre>
    <p><b>Vihje: Yksittäisen merkin saa tulostettua komennolla <code>System.out.print()</code></b></p>
  </div>
</div>
  <h3 id="merkkijonon_muita">Muita merkkijonojen metodeja</h3>
  <p> Merkkijonosta halutaan usein lukea jokin tietty osa. Tämä onnistuu mekkkijonojen eli String-luokan metodilla <code>substring</code>. Sitä voidaan käyttää kahdella tavalla: yksiparametrisenä palauttamaan merkkijonon loppuosa tai kaksiparametrisena palauttamaan parametrien valitsema osajono merkkijonosta: </p>
<pre class="sh_java">
String kirja = "Kalavale";

System.out.println(kirja.substring(4)); //tulostaa "vale"
System.out.println(kirja.substring(2,6)); //tulostaa "lava"
</pre>
  <p>Koska <code>substring</code>-metodin <em>paluuarvo</em> on <code>String</code>-tyyppinen,
    voidaan metodin paluuarvo ottaa talteen String-tyyppiseen muuttujaan kirja.. </p>
<pre class="sh_java">
String kirja = "8 veljestä";

String loppuosa = kirja.substring(2);
System.out.println("7 " + loppuosa); // tulostaa: 7 veljestä
</pre>
  <p> String-luokan metodit tarjoavat myös mahdollisuuden etsiä tekstistä tiettyä sanaa.
    Esimerkiksi sana "erkki" sisältyy tekstiin "merkki".
    Metodi <code>indexOf()</code> etsii parametrinaan annettua sanaa merkkijonosta.
    Jos sana löytyi, se palauttaa sanan ensimmäisen kirjaimen indeksin, eli paikan (muista että paikkanumerointi alkaa nollasta!). Jos taas sanaa ei löytynyt merkkijonosta palautetaan arvo -1. </p>
<pre class="sh_java">
String sana = "merkkijono";

int indeksi = sana.indexOf("erkki"); //indeksin arvoksi tulee 1
System.out.println(sana.substring(indeksi)); //tulostetaan "erkkijono"

indeksi = sana.indexOf("jono"); //indeksin arvoksi tulee 6
System.out.println(sana.substring(indeksi)); //tulostetaan "jono"

indeksi = sana.indexOf("kirja"); //sana "kirja" ei sisälly sanaan "merkkijono"
System.out.println(indeksi); //tulostetaan -1
System.out.println(sana.substring(indeksi)); //virhe!
</pre>
  <p>Screencast aiheesta:</p>
  <p><a href="http://www.youtube.com/watch?feature=player_embedded&v=Ax2bhnJxS4Y" height="300" target="_blank"><img src="https://www.cs.helsinki.fi/group/java/k13/ohpe/img/youtube.jpg"/></a> </p>


  <div class="tehtavat">
    <div class="tehtava">
    <h3 class="req">Alkuosa</h3>
    <p>Tee ohjelma, joka tulostaa sanan alkuosan.
      Ohjelma kysyy käyttäjältä sanan ja alkuosan pituuden.
      Käytä ohjelmassa metodia <code>substring</code>.</p>
<pre>
Anna sana: <font color="red">esimerkki</font>
Alkuosan pituus: <font color="red">4</font>
Tulos: esim
</pre>
<pre>
Anna sana: <font color="red">esimerkki</font>
Alkuosan pituus: <font color="red">7</font>
Tulos: esimerk
</pre>
</div>
<div class="tehtava">
    <h3>Loppuosa</h3>
    <p>Tee ohjelma, joka tulostaa sanan loppuosan.
      Ohjelma kysyy käyttäjältä sanan ja loppuosan pituuden.
      Käytä ohjelmassa merkkijonon metodia <code>substring</code>.</p>
<pre>
Anna sana: <font color="red">esimerkki</font>
Loppuosan pituus: <font color="red">4</font>
Tulos: rkki
</pre>
<pre>
Anna sana: <font color="red">esimerkki</font>
Loppuosan pituus: <font color="red">7</font>
Tulos: imerkki
</pre>
</div>
<div class="tehtava">
    <h3 class="req">Sana sanassa</h3>
    <p>Tee ohjelma, joka kysyy käyttäjältä kaksi sanaa.
      Sitten ohjelma kertoo, onko toinen sana
      ensimmäisen sanan osana. Käytä ohjelmassa
      merkkijonon metodia <code>indexOf</code>.</p>
<pre>
Anna 1. sana: <font color="red">suppilovahvero</font>
Anna 2. sana: <font color="red">ilo</font>
Sana 'ilo' on sanan 'suppilovahvero' osana.
</pre>
<pre>
Anna 1. sana: <font color="red">suppilovahvero</font>
Anna 2. sana: <font color="red">suru</font>
Sana 'suru' ei ole sanan 'suppilovahvero' osana.
</pre>
    <p><strong>Huom:</strong> tulosta ohjelmassasi täsmälleen samassa muodossa kuin esimerkissä!</p>
  </div>
  <div class="tehtava">
    <h3>Merkkijonon kääntäminen</h3>
    <p>Tee metodi <code>kaanna</code>, joka kääntää annetun merkkijonon. Käytä metodille seuraavaa runkoa:</p>
<pre class="sh_java">
public static String kaanna(String merkkijono) {
    // kirjoita koodia tähän
}

public static void main(String[] args) {
    System.out.print("Anna merkkijono: ");
    String merkkijono = lukija.nextLine();
    System.out.println("Väärinpäin: " + kaanna(merkkijono));
}
    </pre>
    <p><b>Vihje: </b>joudut todennäköisesti kokoamaan metodin sisällä käänteisen merkkijonon merkki kerrallaan. Kokoamisessa kannattaa käyttää apuna String-tyyppistä apumuuttujaa. Aluksi apumuuttujan arvo on tyhjä merkkijono. Tämän jälkeen merkkijonon perään laitetaan uusia merkkejä merkki kerrallaan.</p>
<pre>
String apu = "";

// ...
// lisätään merkki apu-nimisen muuttujan perään
apu = apu + merkki;

</pre>
    <p>Ohjelman tulostus:</p>
    <pre>
Anna merkkijono: <font color="red">esimerkki</font>
ikkremise
    </pre>
  </div>
</div>
  <h2>Oliot ja metodit</h2>
  <p>Merkkijonot poikkeavat luonteeltaan hieman esim. kokonaisluvuista. Kokonaisluvut ovat "pelkkiä arvoja", niiden avulla voi laskea ja niitä voi tulostella ruudulle:</p>
  <pre class="sh_java">
int x = 1;
int y = 3;

y = 3*x + 2;

System.out.println( "y:n arvo nyt: " + y );
  </pre>
  <p>Merkkijonot ovat hieman "älykkäämpiä" ja tietävät esimerkiksi pituutensa:</p>
  <pre class="sh_java">
String sana1 = "Ohjelmointi";
String sana2 = "Java";

System.out.println( "merkkijonon "+ sana1 +" pituus: " + sana1.length() );

System.out.println( "merkkijonon "+ sana2 +" pituus: " + sana2.length() );
  </pre>
  <p>Tulostuu:</p>
  <pre>
merkkijonon Ohjelmointi pituus on 11
merkkijonon Java pituus on 4
</pre>
  <p>Pituus saadaan selville kutsumalla merkkijonon metodia <code>length()</code>. Merkkijonoilla on joukko muitakin metodeja. Kokonaisluvuilla eli <code>int</code>:eillä ei ole metodeja ollenkaan, ne eivät itsessään "osaa" mitään.</p>
  <p>Merkkijonot ovat <em>olioita</em> eli "asioita joihin liittyy metodeja sekä arvo". Jatkossa tulemme näkemään hyvin paljon muitakin olioita kuin merkkijonoja.</p>
  <p>Kuten edellisestä esimerkistä huomaamme, kutsutaan olion metodia lisäämällä olion nimen perään piste ja metodikutsu:</p>
  <pre class="sh_java">
sana1.length()    // kutsutaan merkkijono-olion sana1 metodia length()
sana2.length()    // kutsutaan merkkijono-olion sana2 metodia length()
</pre>
  <p>Metodikutsu kohdistuu nimenomaan sihen olioon, mille metodia kutsutaan. Yllä kutsumme ensin <code>sana1</code>-nimisen merkkijonon <code>length()</code>-metodia, sitten merkkijonon <code>sana2</code> metodia <code>length()</code>.</p>
  <p>Vanha tuttumme <code>lukija</code> on myös olio:</p>
<pre class="sh_java">
Scanner lukija = new Scanner(System.in);
</pre>
  <p>Lukijat ja merkkijonot ovat molemmat oliota, ne ovat kuitenkin varsin erilaisia. Lukijoilla on mm. metodi <code>nextLine()</code> jota merkkijonoilla ei ole. Javassa oliot "synnytetään" eli luodaan melkein aina komennolla <code>new</code>, merkkijonot muodostavat tässä suhteessa poikkeuksen! -- Merkkijonoja voi luoda kahdella tavalla:</p>
<pre class="sh_java">
String banaani = new String("Banaani");
String porkkana = "porkkana";
</pre>
  <p>Kumpikin ylläolevista riveistä luo uuden merkkijono-olion. Merkkijonojen luonnissa <code>new</code>-komentoa käytetään hyvin harvoin.</p>
  <p>Olion "tyyppiä" sanotaan <em>luokaksi</em>. Merkkijonojen luokka on <code>String</code>, lukijoiden luokka taas on <code>Scanner</code>. Opimme jatkossa luokista ja olioista paljon lisää.</p>
  <h2>ArrayList eli "oliosäiliö"</h2>
  <p>Ohjelmoidessa tulee usein vastaan tilanteita joissa haluaisimme pitää muistissa esimerkiksi useita erilaisia merkkijonoja. Todella huono tapa olisi määritellä jokaiselle oma muuttujansa:</p>
<pre class="sh_java">
String sana1;
String sana2;
String sana3;
// ...
String sana10;
</pre>
  <p>Tämä olisi aivan kelvoton ratkaisu ja sen huonoutta ei kannata oikeastaan edes perustella -- ajattele ylläoleva esimerkki vaikkapa sadalla tai tuhannella sanalla.</p>
  <p>Java, kuten kaikki modernit ohjelmointikielet, tarjoaa erilaisia apuvälineitä joiden avulla on helppo säilyttää ohjelmassa monia olioita. Tutustumme nyt Javan ehkä eniten käytettyyn oliosäiliöön <em>ArrayList</em>:iin.</p>
  <p>Seuraava ohjelmanpätkä ottaa käyttöönsä merkkijono-olioita tallentavan ArrayList:in sekä tallettaa listalle pari merkkijonoa.</p>
<pre class="sh_java">
import java.util.ArrayList;

public class ListaOhjelma {

    public static void main(String[] args) {
        ArrayList&lt;String&gt; sanaLista = new ArrayList&lt;String&gt;();

        sanaLista.add("Ensimmäinen");
        sanaLista.add("Toinen");
    }
}
</pre>
  <p>Yllä olevan pääohjelman ensimmäinen rivi luo <code>sanaLista</code>-nimisen merkkijonoja tallettavan arraylistin.  Listamuuttujan tyypin nimi on <code>ArrayList&lt;String&gt;</code>, eli merkkijonoja tallettava ArrayList. Itse lista luodaan sanomalla <code>new ArrayList&lt;String&gt;();</code>. </p>
  <p><b>Huom:</b> Jotta ArrayList toimisi, on ohjelman ylälaitaan kirjoitettava <code>import java.util.ArrayList;</code> tai <code>import java.util.*;</code></p>
  <p>Kun lista on luotu, siihen lisätään kaksi merkkijonoa kutsumalla listan metodia <code>add</code>.  Tila ei lopu listalla missään vaiheessa kesken, eli periaatteessa listalle saa lisätä niin monta merkkijonoa kun "koneen" muistiin mahtuu.</p>
  <p>Sisäisesti ArrayList on nimensä mukaisesti lista. Lisätyt merkkijonot menevät automaattisesti ArrayList:in loppuun.</p>
  <h3>ArrayList:in metodeja</h3>
  <p>ArrayList tarjoaa monia hyödyllisiä metodeita:</p>
  <pre class="sh_java">
public static void main(String[] args) {
    ArrayList&lt;String&gt; opettajat = new ArrayList&lt;String&gt;();

    opettajat.add("Antti");
    opettajat.add("Arto");
    opettajat.add("Pekka");
    opettajat.add("Juhana");
    opettajat.add("Martin");
    opettajat.add("Matti");

    System.out.println("opettajien lukumäärä " + opettajat.size() );

    System.out.println("listalla ensimmäisenä " + opettajat.get(0));
    System.out.println("listalla kolmantena " + opettajat.get(2));

    opettajat.remove("Arto");

    if ( opettajat.contains("Arto") ) {
        System.out.println("Arto on opettajien listalla");
    } else {
        System.out.println("Arto ei ole opettajien listalla");
    }
}
</pre>
  <p>Ensin luodaan merkkijonolista jolle lisätään 6 nimeä. <code>size</code> kertoo listalla olevien merkkijonojen lukumäärän. <b>Huom:</b> kun metodia kutsutaan, on kutsu muotoa <code>opettajat.size()</code>, eli metodin nimeä edeltää piste ja sen listan nimi kenen metodia kutsutaan.</p>
  <p>Merkkijonot ovat listalla siinä järjestyksessä missä ne listalle laitettiin. Metodilla <code>get(i)</code> saadaan tietoon listan paikan <code>i</code> sisältö. Listan alkioiden paikkanumerointi alkaa nollasta, eli ensimmäisenä lisätty on paikassa numero 0, toisen a lisätty paikassa numero 1 jne.</p>
  <p>Metodin <code>remove</code> avulla voidaan listalta poistaa merkkijonoja. Jos käytetään metodia muodossa <code>remove("merkkejä")</code>, poistetaan parametrina annettu merkkijono. Metodia voi käyttää myös siten, että annetaan parametriksi tietty luku. Esim. jos sanotaan <code>remove(3)</code> poistuu listalla neljäntenä oleva merkkijono.</p>
  <p>Esimerkin lopussa kutsutaan metodia <code>contains</code> jonka avulla kysytään listalta sisältääkö se parametrina annettavan merkkijonon. Jos sisältää, palauttaa metodi arvon <code>true</code>. </p>
  <p>Ohjelman tulostus:</p>
<pre>
opettajien lukumäärä 6
listalla ensimmäisena Antti
listalla kolmantena Pekka
Arto ei ole opettajien listalla
</pre>
  <p><strong>Huom!</strong> Metodit <code>remove</code> ja <code>contains</code> olettavat että listaan tallennetuilla olioilla on metodi <code>equals</code>. Palaamme tähän myöhemmin kurssilla.</p>
  <h3>ArrayList:in läpikäynti</h3>
  <p>Seuraavassa esimerkissä lisätään listalle 4 nimeä ja tulostetaan listan sisältö:</p>
  <pre class="sh_java">
public static void main(String[] args) {
    ArrayList&lt;String&gt; opettajat = new ArrayList&lt;String&gt;();

    opettajat.add("Antti");
    opettajat.add("Pekka");
    opettajat.add("Juhana");
    opettajat.add("Martin");

    System.out.println( opettajat.get(0) );
    System.out.println( opettajat.get(1) );
    System.out.println( opettajat.get(2) );
    System.out.println( opettajat.get(3) );
}
</pre>
  <p>Ratkaisu on kuitenkin erittäin kömpelö. Entäs jos listalla olisi enemmän alkiota? Tai vähemmän? Entäs jos ei olisi edes tiedossa listalla olevien alkioiden määrää?</p>
  <p>Tehdään ensin välivaiheen versio jossa pidetään:</p>
  <pre class="sh_java">
public static void main(String[] args) {
    ArrayList&lt;String&gt; opettajat = new ArrayList&lt;String&gt;();

    opettajat.add("Antti");
    opettajat.add("Pekka");
    opettajat.add("Juhana");
    opettajat.add("Martin");
    opettajat.add("Matti");

    int paikka = 0;
    System.out.println( opettajat.get(paikka) );
    paikka++;
    System.out.println( opettajat.get(paikka) );  // paikka = 1
    paikka++;
    System.out.println( opettajat.get(paikka) );  // paikka = 2
    paikka++;
    System.out.println( opettajat.get(paikka) );  // paikka = 3
}
</pre>
  <p>Vanhan tutun <code>while</code>-komennon avulla voimme kasvataa muuttujaa <code>paikka</code> niin kauan kunnes se kasvaa liian suureksi:</p>
  <pre class="sh_java">
public static void main(String[] args) {
    ArrayList&lt;String&gt; opettajat = new ArrayList&lt;String&gt;();

    opettajat.add("Antti");
    opettajat.add("Pekka");
    opettajat.add("Juhana");
    opettajat.add("Martin");
    opettajat.add("Matti");

    int paikka = 0;
    while ( paikka &lt; opettajat.size() )  // muistatko miksi paikka &lt;= opettajat.size() ei toimi?
        System.out.println( opettajat.get(paikka) );
        paikka++;
    }
}
</pre>
  <p>Nyt tulostus toimii riippumatta listalla olevien alkioiden määrästä.</p>
  <p>While-toistolauseen käyttö ja listan paikkojen "indeksointi" ei kuitenkaan ole yleensä järkevin tapa listan läpikäyntiin. Suositeltavampi on seuraavassa esiteltävä for-each -toistolauseke.</p>
  <h3>for-each</h3>
  <p>Vaikka komennosta käytetään nimitystä for-each, komennon nimi on pelkästään <code>for</code>.
    for:ista on olemassa kaksi versiota, perinteinen (jonka nopea esittely oli jo viimeviikolla mutta mitä alame varsinaisesti käyttämään vasta viikolla 6) ja "for-each" jota käytämme nyt.</p>
  <p>ArrayList:in alkioiden läpikäynti for-each:illa on lasten leikkiä:</p>
  <pre class="sh_java">
public static void main(String[] args) {
    ArrayList&lt;String&gt; opettajat = new ArrayList&lt;String&gt;();

    opettajat.add("Antti");
    opettajat.add("Pekka");
    opettajat.add("Juhana");
    opettajat.add("Martin");
    opettajat.add("Matti");

    for (String opettaja : opettajat) {
        System.out.println( opettaja );
    }
}
</pre>
  <p>Kuten huomaame, ei listalla olevien merkkijonojen paikkanumeroista tarvitse välittää, for käy listan sisällön läpi "automaattisesti".
  <p>Komennon for aaltosulkujen sisällä olevassa koodissa käytetään muuttujaa <code>opettaja</code>, joka on määritelty for-rivillä kaksoispisteen vasemmalla puolella. Käy niin, että kukin listalla <code>opettajat</code> oleva merkkijono tulee vuorollaan muuttujan <code>opettaja</code> arvoksi. Eli kun for:iin mennään, on <code>opettaja</code> ensin <em>Antti</em>, forin toisella toistolla <code>opettaja</code> on <em>Pekka</em>, jne </p>
  <p>Vaikka <code>for</code>-komento voi tuntua aluksi hieman oudolta sitä kannattaa ehdottomasti totutella käyttämään!</p>
  <p>Screencast aiheesta:</p>
  <a href="http://www.youtube.com/watch?feature=player_embedded&v=-y67VJ68Izs" height="300" target="_blank"><img src="https://www.cs.helsinki.fi/group/java/k13/ohpe/img/youtube.jpg"/></a>

  <div class="tehtavat">
    <div class="tehtava">
    <h3 class="req">Sanat</h3>
    <p>Tee ohjelma, joka kysyy käyttäjältä sanoja, kunnes käyttäjä antaa tyhjän merkkijonon. Sitten ohjelma tulostaa käyttäjän antamat
      sanat uudestaan. <em>Kokeile tässä for-toistolauseketta</em>. Käytä ohjelmassa <code>ArrayList</code>-rakennetta, joka määritellään seuraavasti:</p>
<pre class="sh_java">
ArrayList&lt;String&gt; sanat = new ArrayList&lt;String&gt;();
</pre>
<pre>
Anna sana: <font color="red">Mozart</font>
Anna sana: <font color="red">Schubert</font>
Anna sana: <font color="red">Bach</font>
Anna sana: <font color="red">Sibelius</font>
Anna sana: <font color="red">Liszt</font>
Anna sana:
Annoit seuraavat sanat:
Mozart
Schubert
Bach
Sibelius
Liszt
</pre>
    <p><b>Vihje:</b> tyhjä merkkijono voidaan havaita seuraavasti
    <pre class="sh_java">
String sana = lukija.nextLine();

if ( sana.isEmpty() ) {  // myös tämä tomisi: sana.equals("")
    // sana oli tyhjä eli pelkkä enterin painallus
}
</pre>
    </p>
  </div>
  <div class="tehtava">
    <h3 class="req">Toistuva sana</h3>
    <p>Tee ohjelma, joka kysyy käyttäjältä sanoja, kunnes käyttäjä antaa saman sanan uudestaan.
      Käytä ohjelmassa <code>ArrayList</code>-rakennetta, joka määritellään seuraavasti:</p>
<pre class="sh_java">
ArrayList&lt;String&gt; sanat = new ArrayList&lt;String&gt;();
</pre>
    <p>Kun sama sana toistuu, ilmoittaa ohjelma asiasta seuraavasti:</p>
<pre>
Anna sana: <font color="red">porkkana</font>
Anna sana: <font color="red">selleri</font>
Anna sana: <font color="red">nauris</font>
Anna sana: <font color="red">lanttu</font>
Anna sana: <font color="red">selleri</font>
Annoit uudestaan sanan selleri
</pre>
    <p><b>Vihje: </b> Muista arraylistin metodi <code>.contains()</code></p>
  </div>
</div>
  <h3>Listan järjestäminen, kääntäminen ja sekoittaminen</h3>
  <p>ArrayList:n sisältö on helppo järjestää suuruusjärjestykseen. Suuruusjärjestys merkkijonojen yhteydessä tarkoittaa aakkosjärjestystä. Järjestäminen tapahtuu seuraavasti:</p>
<pre class="sh_java">
public static void main(String[] args) {
    ArrayList&lt;String&gt; opettajat = new ArrayList&lt;String&gt;();

    // ...

    Collections.sort(opettajat);

    for (String opettaja : opettajat) {
        System.out.println( opettaja );
    }
}
</pre>
  <p>Tulostuu:</p>
<pre>
Antti
Arto
Juhana
Martin
Matti
Pekka
</pre>
  <p>Annetaan siis lista parametriksi metodille <code>Collections.sort</code>. Jotta Collections:in apuvälineet toimisivat, on ohjelman yläosassa oltava <code>import java.util.Collections;</code> tai <code>import java.util.*;</code></p>
  <p>Collections:ista löytyy muutakin hyödyllistä:</p>
  <ul>
    <li> <code>shuffle</code> sekoittaa listan sisällön, metodista voi olla hyötyä esimerkiksi peleissä</li>
    <li> <code>reverse</code> kääntää listan sisällön</li>
  </ul>
  <div class="tehtavat">
  <div class="tehtava">
    <h3 class="req">Sanat käänteisesti</h3>
    <p> Tee ohjelma, joka kysyy käyttäjältä sanoja, kunnes käyttäjä antaa tyhjän merkkijonon.
      Sitten ohjelma tulostaa käyttäjän antamat sanat päinvastaisessa järjestyksessä, eli viimeinen syötetty sana ensin jne.</p>
<pre>
Anna sana: <font color="red">Mozart</font>
Anna sana: <font color="red">Schubert</font>
Anna sana: <font color="red">Bach</font>
Anna sana: <font color="red">Sibelius</font>
Anna sana: <font color="red">Liszt</font>
Anna sana:
Annoit seuraavat sanat:
Liszt
Sibelius
Bach
Schubert
Mozart
</pre>
</div>
<div class="tehtava">
    <h3 class="req">Sanat aakkosjärjestyksessä</h3>
    <p>Tee edellistä tehtävää vastaava ohjelma,
      jossa sanat tulostetaan aakkosjärjestyksessä.</p>
<pre>
Anna sana: <font color="red">Mozart</font>
Anna sana: <font color="red">Schubert</font>
Anna sana: <font color="red">Bach</font>
Anna sana: <font color="red">Sibelius</font>
Anna sana: <font color="red">Liszt</font>
Anna sana:
Annoit seuraavat sanat:
Bach
Liszt
Mozart
Schubert
Sibelius
</pre>
  </div>
  </div>
  <h3>ArrayList metodin parametrina</h3>
  <p>ArrayList:in voi antaa metodille parametrina:</p>
  <pre class="sh_java">
public static void tulosta(ArrayList&lt;String&gt; lista) {
    for (String sana : lista) {
        System.out.println( sana );
    }
}

public static void main(String[] args) {
    ArrayList&lt;String&gt; lista = new ArrayList&lt;String&gt;();
    lista.add("Java");
    lista.add("Python");
    lista.add("Ruby");
    lista.add("C++");

    tulosta(lista);
}
</pre>
  <p>Parametrin tyyppi siis määritellään listaksi täsmälleen samalla tavalla eli <code>ArrayList&lt;String&gt;</code> kuin listamuuttujan määrittely tapahtuu.</p>
  <p>Huomaa, että parametrin nimellä ei ole merkitystä:</p>
<pre class="sh_java">
public static void tulosta(ArrayList&lt;String&gt; tulostettava) {
    for (String sana : tulostettava) {
        System.out.println( sana );
    }
}

public static void main(String[] args) {
    ArrayList&lt;String&gt; ohjelmointikielet = new ArrayList&lt;String&gt;();
    ohjelmointikielet.add("Java");
    ohjelmointikielet.add("Python");
    ohjelmointikielet.add("Ruby");
    ohjelmointikielet.add("C++");

    ArrayList&lt;String&gt; maat = new ArrayList&lt;String&gt;();
    maat.add("Suomi");
    maat.add("Ruotsi");
    maat.add("Norja");

    tulosta(ohjelmointikielet);    // annetaan metodille parametriksi lista ohjelmointikielet

    tulosta(maat);                 // annetaan metodille parametriksi lista maat
}
</pre>
  <p>Ohjelmassa on nyt kaksi listaa <em>ohjelmointikielet</em> ja <em>maat</em>. Metodille annetaan ensin tulostettavaksi lista <em>ohjelmointikielet</em>. Metodi <code>tulosta</code> käyttää parametriksi saamastaan listasta sisäisesti nimellä <em>tulostettava</em>! Seuraavaksi metodille annetaan tulostettavaksi lista <em>maat</em>. Jälleen metodi käyttää parametrinaan saamasta listasta sisäisesti nimeä <em>tulostettava</em>. </p>
  <div class="tehtavat">
  <div class="tehtava">
    <h3 class="req">Listan alkioiden lukumäärä</h3>
    <p>Tee metodi <code>public static int
      laskeAlkiot(ArrayList&lt;String&gt; lista)</code> joka palauttaa listan alkioiden määrän. Metodisi ei siis tulosta mitään vaan
      palauttaa <code>return</code>:illa alkioiden lukumäärän seuraavan esimerkin mukaisesti</p>
<pre class="sh_java">
ArrayList&lt;String&gt; lista = new ArrayList&lt;String&gt;();
lista.add("Moi");
lista.add("Ciao");
lista.add("Hello");
System.out.println("Listalla on alkioita:");
System.out.println(laskeAlkiot(lista));
</pre>
<pre>
Listalla on alkioita:
3
</pre>
</div>
</div>
  <p>Metodin sisällä on mahdollisuus vaikuttaa parametrina saadun listan sisältöön. Seuraavassa esimerkissä metodi <code>poistaEnsimmainen</code> nimensä mukaisesti poistaa listalla ensimmäisenä olevan merkkijonon (mitähän tapahtuu jos listalla ei ole mitään?).</p>
  <pre class="sh_java">
public static void tulosta(ArrayList&lt;String&gt; tulostettava) {
    for (String sana : tulostettava) {
        System.out.println( sana );
    }
}

public static void poistaEnsimmainen(ArrayList&lt;String&gt; lista) {
    lista.remove(0);  // poistetaan listalta ensimmäinen eli "nollas"
}

public static void main(String[] args) {
    ArrayList&lt;String&gt; ohjelmointikielet = new ArrayList&lt;String&gt;();
    ohjelmointikielet.add("Pascal");
    ohjelmointikielet.add("Java");
    ohjelmointikielet.add("Python");
    ohjelmointikielet.add("Ruby");
    ohjelmointikielet.add("C++");


    tulosta(ohjelmointikielet);

    poistaEnsimmainen(ohjelmointikielet);

    System.out.println();  // tulostetaan tyhjä rivi

    tulosta(ohjelmointikielet);
}
</pre>
<p>Tulostuu:</p>
<pre>
Pascal
Java
Python
Ruby
C++

Java
Python
Ruby
C++
</pre>
  <p>Vastaavalla tavalla metodi voisi esim. lisätä parametrina saamaansa listaan lisää merkkijonoja.</p>
  <div class="tehtavat">
    <div class="tehtava">
    <h3 class="req">Poista viimeinen</h3>
    <p>Tee metodi <code>public static void poistaViimeinen(ArrayList&lt;String&gt;
      lista)</code> joka poistaa listalla viimeisenä olevan alkion. Tällöin
      esimerkiksi seuraava koodi:</p>
<pre class="sh_java">
ArrayList&lt;String&gt; tyypit = new ArrayList&lt;String&gt;();
tyypit.add("Pekka");
tyypit.add("Mauri");
tyypit.add("Jore");
tyypit.add("Simppa");

System.out.println("Tyypit:");
System.out.println(tyypit);

// tyypit järjestykseen!
tyypit.sort();

// heitetään viimeinen mäkeen!
poistaViimeinen(tyypit);

System.out.println(tyypit);
</pre>
<p>Tulostaa:</p>
<pre>
Tyypit:
[Pekka, Mauri, Jore, Simppa]
[Jore, Mauri, Pekka]
</pre>
</div>
</div>
  <p>Kuten edellisen tehtävän esimerkkitulostuksesta näemme, voi ArrayList:in tulostaa sellaisenaan. Tulostusmuoto ei kuitenkaan yleensä ole halutun kaltainen ja tulostus joudutaan hoitamaan itse esim. <code>for</code>-komennon avulla.</p>
  <h3>Lukuja ArrayList:issä</h3>
  <p>ArrayList:eihin voi tallettaa minkä tahansa tyyppisiä arvoja. Jos talletetaan kokonaislukuja eli <code>int</code>:ejä, tulee muistaa pari detaljia. int:ejä tallettava lista tulee määritellä <code>ArrayList&lt;Integer&gt;</code>, eli <code>int</code>:n sijaan tulee kirjoittaa <code>Integer</code>. </p>
  <p>Kun listalle talletetaan <code>int</code>-lukuja, ei metodi <code>remove</code> toimi aivan odotetulla tavalla:
  <pre class="sh_java">
public static void main(String[] args) {
    ArrayList&lt;Integer&gt; luvut = new ArrayList&lt;Integer&gt;();

    luvut.add(4);
    luvut.add(8);

    // yrittää poistaa luvun listan kohdasta 4, eli ei toimi odotetulla tavalla!
    luvut.remove(4);

    // tämä poistaa listalta luvun 4
    luvut.remove( Integer.valueOf(4) );
}
</pre>
  <p>Eli <code>luvut.remove(4)</code> yrittää poistaa listalla kohdassa 4 olevan alkion. Listalla on vain 2 alkiota, joten komento aiheuttaa virheen. Jos halutaan poistaa luku 4, täytyy käyttää hieman monimutkaisempaa muotoa: <code>luvut.remove( Integer.valueOf(4) );</code></p>
  <p>Listalle voi tallettaa myös liukulukuja eli <code>double</code>:ja ja merkkejä eli <code>char</code>:eja. Tällöin listat luodaan seuraavasti:</p>
  <pre class="sh_java">
ArrayList&lt;Double&gt; doublet = new ArrayList&lt;Double&gt;();
ArrayList&lt;Character&gt; merkit = new ArrayList&lt;Character&gt;();
    </pre>
  <div class="tehtavat">
    <div class="tehtava">
    <h3 class="req">Lukujen summa</h3>
    <p>Tee metodi <code>summa</code>, joka laskee parametrinaan saamansa kokonaislukuja sisältävän, eli tyyppiä <code>ArrayList&lt;Integer&gt;</code> olevan listan summan.</p>
    <p>Tee metodi seuraavaan runkoon:</p>
<pre class="sh_java">
public static int summa(ArrayList&lt;Integer&gt; lista) {
    // kirjoita koodia tähän
}

public static void main(String[] args) {
    ArrayList&lt;Integer&gt; lista = new ArrayList&lt;Integer&gt;();
    lista.add(3);
    lista.add(2);
    lista.add(7);
    lista.add(2);

    System.out.println("Summa: " + summa(lista));

    lista.add(10);

    System.out.println("Summa: " + summa(lista));
}
  </pre>
    <p>Ohjelman tulostus:</p>
<pre>
Summa: 14
Summa: 24
</pre>
</div>
<div class="tehtava">
    <h3 class="req">Lukujen keskiarvo</h3>
    <p>Tee metodi <code>keskiarvo</code>, joka laskee parametrinaan saamansa kokonaislukuja sisältävän listan lukujen keskiarvon. Metodin on laskettava parametriensa summa käyttäen apuna edellisen tehtävän metodia <code>summa</code>.</p>
    <p>Tee metodi seuraavaan runkoon:</p>
    <pre class="sh_java">
public static double keskiarvo(ArrayList&lt;Integer&gt; lista) {
    // kirjoita koodia tähän
}

public static void main(String[] args) {
    ArrayList&lt;Integer&gt; lista = new ArrayList&lt;Integer&gt;();
    lista.add(3);
    lista.add(2);
    lista.add(7);
    lista.add(2);

    System.out.println("Keskiarvo: " + keskiarvo(lista));
}
</pre>
    <p>Ohjelman tulostus:</p>
    <pre>
Keskiarvo: 3.5
</pre>
  </div>
  <div class="tehtava">
    <h3>Suurin</h3>
    <p>Tee metodi <code>suurin</code>, joka palauttaa parametrina saamansa kokonaislukuja sisältävän listan suurimman luvun.</p>
    <pre class="sh_java">
public static int suurin(ArrayList&lt;Integer&gt; lista) {
    // kirjoita koodia tähän
}

public static void main(String[] args) {
    ArrayList&lt;Integer&gt; lista = new ArrayList&lt;Integer&gt;();
    lista.add(3);
    lista.add(2);
    lista.add(7);
    lista.add(2);

    System.out.println("Suurin: " + suurin(lista));
}
</pre>
    <p>Ohjelman tulostus:</p>
<pre>
Suurin: 7
</pre>
</div>
<div class="tehtava">
    <h3>Varianssi</h3>
    <p>Tee metodi <code>varianssi</code>, joka laskee palauttaa saamansa kokonaislukuja sisältävän listan otosvarianssin.
      Ohjeen varianssin laskemiseksi voit katsoa esimerkiksi <a href="http://fi.wikipedia.org/wiki/Varianssi#Populaatio-_ja_otosvarianssi">Wikipediasta</a> kohdasta populaatio- ja otosvarianssi.</p>
    <p> Tee metodi käytäen apuna tehtävän 64 metodia <code>keskiarvo</code>, kutsu metodia kuitenkin vain kertaalleen yhden varianssin laskemisen aikana. </p>
    <pre class="sh_java">
public static double varianssi(ArrayList&lt;Integer&gt; lista) {
    // kirjoita koodia tähän
}

public static void main(String[] args) {
    ArrayList&lt;Integer&gt; lista = new ArrayList&lt;Integer&gt;();
    lista.add(3);
    lista.add(2);
    lista.add(7);
    lista.add(2);

    System.out.println("Varianssi: " + varianssi(lista));
}
</pre>
    <p>Ohjelman tulostus:</p>
    <pre>
  Varianssi: 5.666667
</pre>
    <p>(Lukujen keskiarvo on 3.5, joten otosvarianssi on
      ((3 - 3.5)² + (2 - 3.5)² + (7 - 3.5)² + (2 - 3.5)²)/(4 - 1) ˜ 5,666667.) </p>
    <p><strong>Huom!</strong> Muistathan kokeillessasi ohjelmaa, että
      yhden alkion kokoisen listan (otos)varianssia ei ole määritelty!
      Kaavassa tapahtuu tällöin nollalla jakaminen. Java esittää
      nollalla jakamisen tuloksen <em>epänumerona</em> <code>NaN</code></p>
  </div>
</div>
  <h2>Totuusarvojen käyttö</h2>
  <p>Totuusarvoinen eli <code>boolean</code>-muuttuja voi saada vain kaksi arvoa <em>true</em> tai <em>false</em>. Seuraavassa esimerkki booleanin käytöstä:</p>
  <pre class="sh_java">
int luku1 = 1;
int luku2 = 5;

boolean ekaSuurempi = true;

if (luku1 &lt;= luku2) {
    ekaSuurempi = false;
}

if (ekaSuurempi==true) {
    System.out.println("luku1 suurempi");
} else {
    System.out.println("luku1 ei ollut suurempi");
}
</pre>
  <p>Eli ensin asetetaan totuusarvon <code>ekaSuurempi</code> arvoksi tosi eli <em>true</em>. Ensimmäinen if tarkastaa onko <code>luku1</code> pienempi tai yhtä pieni kuin <code>luku2</code>. Jos näin on, vaihdetaan totuusarvon arvoksi epätosi eli <em>false</em>. Myöhempi if valitsee tulostuksen totuusarvoon perustuen.</p>
  <p>Totuusarvon käyttö ehtolauseessa on itseasiassa edellistä esimerkkiä yksinkertaisempaa, jälkimmäinen if voidaan kirjoittaa seuraavasti:</p>
  <pre class="sh_java">
if (ekaSuurempi) {  // tarkoittaa samaa kuin ekaSuurempi==true
    System.out.println("luku1 suurempi");
} else {
    System.out.println("luku1 ei ollut suurempi");
}
</pre>
  <p>Eli jos halutaan tarkistaa että booleanmuuttujan arvo on tosi, eli ole tarvetta kirjoittaa <code>==true</code>, pelkkä muuttujan nimi riittää!</p>
  <p>Epätoden tarkastaminen onnistuu negaatio-operaation eli huutomerkin avulla:</p>
  <pre class="sh_java">
if (!ekaSuurempi) {  // tarkoittaa samaa kuin ekaSuurempi==false
    System.out.println("luku1 ei ollut suurempi");
} else {
    System.out.println("luku1 suurempi");
}
</pre>
  <h3>totuusarvon palauttava metodi</h3>
  <p>Totuusarvot ovat erityisen käteviä jonkun asian voimassaolon tarkistavien metodien paluuarvoina. Tehdään metodi joka tarkastaa sisältääkö sen parametrina saama lista ainoastaan positiivisia lukuja (tulkitaan 0 positiiviseksi). Tieto positiivisuudesta palautetaan totuusarvona.</p>
  <pre class="sh_java">
public static boolean kaikkiPositiivisia(ArrayList&lt;Integer&gt; luvut) {
    boolean eiNegatiivisia = true;

    for (int luku : luvut) {
        if (luku &lt; 0) {
            eiNegatiivisia = false;
        }
    }
    // jos jonkun listan luvuista arvo oli pienempi kuin 0, on eiNegatiivisia nyt false
    return eiNegatiivisia;
}
</pre>
  <p>Metodilla on totuusarvoinen apumuuttuja <code>eiNegatiivisia</code>. Apumuuttujan arvoksi asetetaan ensin true. Metodi käy läpi kaikki listan luvut. Jos jonkun (siis vähintään yhden) luvun arvo on pienempi kuin nolla, asetetaan apumuuttujan arvoksi false. Lopuksi palautetaan apumuuttujan arvo. Apumuuttuja on edelleen true jos yhtään negatiivista lukua ei löytynyt, muuten false.</p>
  <p>Metodia käytetään seuraavasti:</p>
  <pre class="sh_java">
public static void main(String[] args) {

    ArrayList&lt;Integer&gt; luvut = new ArrayList&lt;Integer&gt;();
    luvut.add(3);
    luvut.add(1);
    luvut.add(-1);

    boolean vastaus = kaikkiPositiivisia(luvut);

    if (vastaus) {  // tarkoittaa siis samaa kuin vastaus == true
        System.out.println("luvut positiivisia");
    } else {
        System.out.println("joukossa oli ainakin yksi negatiivinen");
    }
}
</pre>
  <p>Vastauksen tallettaminen ensin muuttujaan ei yleensä ole tarpeen, ja metodikutsu voidaan kirjottaa suoraan ehdoksi:</p>
  <pre class="sh_java">
ArrayList&lt;Integer&gt; luvut = new ArrayList&lt;Integer&gt;();
luvut.add(4);
luvut.add(7);
luvut.add(12);
luvut.add(9);

if (kaikkiPositiivisia(luvut)) {
    System.out.println("luvut positiivisia");
} else {
    System.out.println("joukossa oli ainakin yksi negatiivinen");
}

</pre>
  <h3>Komento return ja metodin lopetus</h3>
  <p>Metodin suoritus loppuu välittömästi kun metodissa suoritetaan <code>return</code>-käsky. Käyttämällä tätä tietoa hyväksi voimme kirjoittaa <code>kaikkiPositiivisia</code>-metodin
    hiukan suoraviivaisemmin ja selkeämmin. </p>
  <pre class="sh_java">
public static boolean kaikkiPositiivisia(ArrayList&lt;Integer&gt; luvut) {
    for (int luku : luvut) {
        if (luku &lt; 0) {
            return false;
        }
    }

    // jos tultiin tänne asti, ei yhtään negatiivista löytynyt
    // siispä palautetaan true
    return true;
    }
}
</pre>
  <p>Eli jos lukujen listaa läpikäydessä törmätään negatiiviseen lukuun, voidaan metodista poistua heti palauttamalla false. Jos listalla ei ole yhtään negatiivista, päädytään loppuun ja voidaan palauttaa true. Olemme päässeet metodissa kokonaan eroon apumuuttujan käytöstä!</p>
  <div class="tehtavat">
    <div class="tehtava">
    <h3 class="req">Onko luku listalla monta kertaa</h3>
    <p>Tee metodi <code>onkoListallaUseasti</code>, joka saa parametrinaan
      kokonaislukuja sisältävän listan ja int-luvun. Jos luku esiintyy
      listalla <em>yli yhden kerran</em>, metodi
      palauttaa <code>true</code> ja muulloin <code>false</code>.</p>
    <p>Ohjelman rakenne on seuraava:</p>
    <pre class="sh_java">
public static boolean onkoListallaUseasti(ArrayList&lt;Integer&gt; lista, int luku) {
    // kirjoita koodia tähän
}

public static void main(String[] args) {
    ArrayList&lt;Integer&gt; lista = new ArrayList&lt;Integer&gt;();
    lista.add(3);
    lista.add(2);
    lista.add(7);
    lista.add(2);

    System.out.println("Anna luku: ");
    int luku = Integer.parseInt(lukija.nextLine());
    if (onkoListallaUseasti(luvut, luku)) {
        System.out.println(luku + " on listalla useasti.");
    } else {
        System.out.println(luku + " ei ole listalla useasti.");
    }
}
</pre>
    <pre>
  Anna luku: <font color="red">2</font>
  Luku on on listalla useasti.
</pre>
    <pre>
  Anna luku: <font color="red">3</font>
  Luku ei ole listalla useasti.
</pre>
</div>
<div class="tehtava">
    <h3>Palindromi</h3>
    <p>Tee metodi <code>palindromi</code>, joka kertoo, onko merkkijono palindromi (merkkijonon sisältö on sama alusta loppuun ja lopusta alkuun luettuna).</p>
    <p>Metodi voi käyttää apuna metodia <code>kaanna</code> tehtävästä 56. Metodin tyyppi on <code>boolean</code>, joten se pa lauttaa jokoarvon <code>true</code> (merkkijono on palindromi) tai <code>false</code> (merkkijono ei ole palindromi).</p>
    <pre class="sh_java">
public static boolean palindromi(String merkkijono) {
    // kirjoita koodia tähän
}

public static void main(String[] args) {
    Scanner lukija = new Scanner(System.in);

    System.out.println("Anna merkkijono: ");
    String merkkijono = lukija.nextLine();
    if (palindromi(merkkijono)) {
        System.out.println("Merkkijono on palindromi!");
    } else {
        System.out.println("Merkkijono ei ole palindromi!");
    }
}
</pre>
    <p>Ohjelman tulostuksia:</p>
<pre>
Anna merkkijono: <font color="red">saippuakauppias</font>
Merkkijono on palindromi!
</pre>
<pre>
Anna merkkijono: <font color="red">esimerkki</font>
Merkkijono ei ole palindromi!
</pre>
</div>
  </div>
  <h3>ArrayListin kopioiminen</h3>
  <p>Joskus on tarpeen muodostaa ArrayLististä kopio, johon voi tehdä muutoksia vaikuttamatta alkuperäisen ArrayListin sisältöön. Kopion voi muodostaa luomalla uuden ArrayListin käyttäen vanhaa ArrayListiä parametrina:</p>
<pre class="sh_java">
ArrayList&lt;String&gt; nimet = new ArrayList&lt;String&gt;();
nimet.add("Kyösti");
nimet.add("Risto");
nimet.add("Carl");
nimet.add("Urho");

//luodaan kopio nimet-listasta
ArrayList&lt;String&gt; kopio = new ArrayList&lt;String&gt;(nimet);
//järjestetään kopio
Collections.sort(kopio);

System.out.println(kopio);  //tulostuu [Carl, Kyösti, Risto, Urho]
System.out.println(nimet);  //tulostuu [Kyösti, Risto, Carl, Urho]
</pre>
  <div class="tehtavat">
    <div class="tehtava">
    <h3>KaikkiEri</h3>
    <p>Tee metodi <code>kaikkiEri</code>, joka palauttaa true jos sen parametrina saamassa kokonaislukuja sisältävässä listassa olevat luvut ovat kaikki erisuuruisia. Metodi ei saa muuttaa listan sisältöä.</p>
    </pre>
    <p>Seuraavassa kaksi esimerkkiä metodin toiminnasta:</p>
    <pre class="sh_java">
public static void main(String[] args) {
    ArrayList&lt;Integer&gt; lista1 = new ArrayList&lt;Integer&gt;();
    lista1.add(3);
    lista1.add(7);
    lista1.add(1);

    boolean eri = kaikkiEri(lista1);
    // muuttujan eri arvo true

    ArrayList&lt;Integer&gt; lista2 = new ArrayList&lt;Integer&gt;();
    lista2.add(2);
    lista2.add(3);
    lista2.add(7);
    lista2.add(1);
    lista2.add(3);
    lista2.add(99);

    eri = kaikkiEri(lista2);
    // muuttujan eri arvo false sillä luku 3 on listalla kahteen kertaan
}
</pre>
</div>
  </div>
  <h2>Metodit ja parametrien kopioituminen</h2>
  <p>Tarkastellaan muutamaa metodeihin liittyvää tärkeää yksityiskohtaa.</p>
  <p>Luvussa 15 oli esimerkki, jossa yritettiin muuttaa pääohjelmassa olevan muuttujan arvoa metodin sisällä.</p>
  <pre class="sh_java">
public static void main(String[] args) {
    int luku = 1;
    kasvataKolmella();
    System.out.println("luku on " + luku);
}

public static void kasvataKolmella() {
    luku = luku + 3;
}
</pre>
  <p>Ohjelma ei toimi, sillä metodi ei pääse käsiksi pääohjelman muuttujaan <code>luku</code>.</p>
  <p>Tämä johtuu siitä, että pääohjelman muuttujat eivät näy metodien sisään. Ja yleisemmin: minkään metodin muuttujat eivät näy muille metodeille. Koska pääohjelma <code>main</code> on myös metodi, pätee sääntö myös pääohjelmalle. Ainoa keino viedä metodille tietoa ulkopuolelta on parametrin avulla.</p>
  <p>Yritetään korjata edellinen esimerkki välittämällä pääohjelman muuttuja <code>luku</code> parametrina metodille.</p>
  <pre class="sh_java">
public static void main(String[] args) {
    int luku = 1;
    kasvataKolmella(luku);
    System.out.println(luku);  // tulostaa 1, eli arvo luku ei muuttunut
}

public static void kasvataKolmella(int luku) {
    luku = luku + 3;
}
</pre>
  <p>Ohjelma ei toimi toivotulla tavalla. Metodissa olevat parametrit ovat eri muuttujia kuin pääohjelmassa esitellyt muuttujat.  Edellä metodi siis kasvattaa samannimistä, mutta ei samaa parametria <code>luku</code>.</p>
  <p>Kun metodille annetaan parametri, parametrin arvo <em>kopioidaan uuteen muuttujaan</em> metodissa käytettäväksi. Yllä olevassa esimerkissä metodille <code>kasvataKolmella</code> annetusta muuttujasta <code>luku</code> luodaan kopio, jota metodin sisällä lopulta käsitellään.  Metodi käsittelee siis pääohjelmassa olevan muuttujan kopiota, ei alkuperäistä muuttujaa -- pääohjelmametodissa olevalle muuttujalle <code>luku</code> ei tehdä mitään.</p>
  <p>Voidaan ajatella, että pääohjelmametodi <code>main</code> ja metodi <code>kasvataKolmella</code> toimivat kumpikin omassa kohtaa tietokoneen muistia. Allaolevassa kuvassa on <code>main</code>:in muuttujaa <code>luku</code> varten oma "lokero". Kun metodia kutsutaan, tehdään tälle oma muuttuja <code>luku</code> jonka arvoksi kopioituu <code>main</code>:in <code>luku</code>-muuttujan arvo eli 1. Molemmat <code>luku</code>-nimiset muuttujat ovat kuitenkin täysin erillisiä, eli kun metodissa <code>kasvataKolmella</code> muutetaan sen <code>luku</code>-muuttujan arvoa, ei muutos vaikuta millään tavalla pääohjelman muuttujaan <code>luku</code>.</p>
  <p>Allaoleva kuva antaa lisävalaisua tilanteeseen.</p>
  <p> <img src="https://www.cs.helsinki.fi/group/java/k13/ohpe/img/metodi1.png"/> </p>
  <p>Metodista saa toki välitettyä tietoa kutsujalle käyttäen paluuarvoa, eli palauttamalla arvon <code>return</code>-komennolla. Edellinen saadaan toimimaan muuttamalla koodia hiukan:</p>
  <pre class="sh_java">
public static void main(String[] args) {
    int luku = 1;
    luku = kasvataKolmellaJaPalauta(luku);

    System.out.println(luku);  // tulostaa 4, sillä luku on saanut arvokseen metodin palauttaman arvon
}

public static int kasvataKolmellaJaPalauta(int luku) {
    luku = luku + 3;

    return luku;
}
</pre>
  <p>Edelleen on niin, että metodi käsittelee pääohjelman <code>luku</code>-muuttujan arvon kopiota. Pääohjelmassa metodin palauttama arvo sijoitetaan muuttujaan <code>luku</code>, joten muutos tulee tämän takia voimaan myös pääohjelmassa. Huomaa, että edellisessä ei ole mitään merkitystä sillä, mikä nimi metodin parametrilla on. Koodi toimii täysin samoin oli nimi mikä tahansa, esim. </p>
  <pre class="sh_java">
public static void main(String[] args) {
    int luku = 1;
    luku = kasvataKolmellaJaPalauta(luku);

    System.out.println(luku);
}

public static int kasvataKolmellaJaPalauta(int kasvatettavaLuku) {
    kasvatettavaLuku = kasvatettavaLuku + 3;

    return kasvatettavaLuku;
}
</pre>
  <p>Huomasimme että metodissa olevat parametrit ovat eri muuttujia kuin metodin kutsujassa esitellyt muuttujat. Ainoastaan parametrin arvo kopioituu kutsujasta metodiin.</p>
  <p>Asia ei kuitenkaan ole ihan näin yksinkertainen. Jos metodille annetaan parametrina <code>ArrayList</code>, käy niin että sama lista näkyy metodille ja kaikki metodin listalle tekemät muutokset tulevat kaikkialla voimaan.</p>
  <pre class="sh_java">
public static void poistaAlussaOleva(ArrayList&lt;Integer&gt; lista) {
    lista.remove(0); // poistaa paikassa 0 olevan luvun
}
</pre>
  <pre class="sh_java">
ArrayList&lt;Integer&gt; luvut = new ArrayList&lt;Integer&gt;();
luvut.add(4);
luvut.add(3);
luvut.add(7);
luvut.add(3);

System.out.println(luvut); // tulostuu [4,3,7,3]

poistaAlussaOleva(luvut);

System.out.println(luvut); // tulostuu [3,7,3]
</pre>
  <p>Toisin kuin <code>int</code>-tyyppinen parametri, lista ei kopioidu vaan metodi käsittelee suoraan parametrina annettua listaa. </p>
  <p>Tilannetta valaisee allaoleva kuva. Toisin kuin <code>int</code>-tyyppinen muuttuja, <code>ArrayList</code> ei sijaitsekaan samalla tapaa "lokerossa", vaan muuttujan nimi, eli mainin tapauksessa <code>luvut</code> onkin ainoastaan <em>viite</em> paikkaan missä <code>ArrayList</code> sijaitsee. Yksi tapa ajatella asiaa, on että <code>ArrayList</code> on "langan päässä", eli listan nimi <code>luvut</code> on lanka jonka toisesta päästä lista löytyy. Kun metodikutsun parametrina on <code>ArrayList</code>, käykin niin että metodille annetaan "lanka" jonka päässä on sama lista jonka metodin kutsuja näkee. Eli main:illa ja metodilla on kyllä molemmilla oma lanka, mutta langan päässä on sama lista ja kaikki muutokset mitä metodi tekee listaan tapahtuvat täsmälleen samaan listaan jota pääohjelma käyttää. Tästä viikosta alkaen tulemme huomaamaan että Java:ssa hyvin moni asia on "langan päässä".</p>
  <p><img src="https://www.cs.helsinki.fi/group/java/k13/ohpe/img/metodi-lanka.PNG" height="400"/></p>
  <p>Huomaa jälleen että parametrin nimi metodin sisällä voi olla aivan vapaasti valittu, nimen ei tarvitse missään tapauksessa olla sama kuin kutsuvassa metodissa oleva nimi. Edellä listaa kutsutaan metodin sisällä nimellä <code>lista</code>, metodin kutsuja taas näkee saman listan <code>luvut</code>-nimisenä.</p>
  <p>Miksi <code>int</code>-parametrista ainoastaan arvo kopioituu metodille mutta parametrin ollessa <code>ArrayList</code> metodi käsittelee suoraan listan sisältöä? Javassa ainoastaan <strong><em>alkeistietotyyppisten</em></strong> eli tyyppien <code>int</code>, <code>double</code>, <code>char</code>, <code>boolean</code> (ja muutamien muiden joita emme ole käsitelleet) arvot kopioidaan metodille. Muun tyyppisten parametrien tapauksessa metodille kopioidaan <em>viite</em>, ja metodista käsitellään viitteen takana olevaa parametria suoraan. Ei-alkeistyyppiset muuttujat -- eli <strong><em>viittaustyyppiset</em></strong> muuttujat ovat siis edellisen kuvan tapaan "langan päässä" -- metodille välitetään lanka parametriin, ja näin metodi käsittelee parametria suoraan.</p>
  <div class="tehtavat">
    <div class="tehtava">
    <h3>ArrayListien yhdistäminen</h3>
    <p>Toteuta metodi <code>public static void yhdista(ArrayList&lt;Integer&gt; eka, ArrayList&lt;Integer&gt; toka)</code>, joka lisää toisena parametrina <code>toka</code> olevassa ArrayListissa olevat luvut ensimmäisenä parametrina olevaan ArrayList:iin <code>eka</code>. Alkioiden talletusjärjestyksellä ei ole väliä, ja sama alkio voi päätyä listalle useamman kerran. Esimerkki metodin toiminnasta:</p>
    <pre class="sh_java">
ArrayList&lt;Integer&gt; lista1= new ArrayList&lt;Integer&gt;();
ArrayList&lt;Integer&gt; lista2= new ArrayList&lt;Integer&gt;();

lista1.add(4);
lista1.add(3);

lista2.add(5);
lista2.add(10);
lista2.add(7);

yhdista(lista1, lista2);

System.out.println(lista1); // tulostuu [4, 3, 5, 10, 7]

System.out.println(lista2); // tulostuu [5, 10, 7]
  </pre>
    <p>Listalle voi lisätä toisen listan sisällön ArrayList-luokan tarjoaman <code>addAll</code>-metodin avulla. Lista saa parametrinä toisen listan, jonka alkiot listalle lisätään.</p>
  </div>
  <div class="tehtava">
    <h3>Joukkoyhdistäminen</h3>
    <p>Toteuta metodi <code>joukkoYhdista</code> joka toimii muuten samoin kuin edellisen tehtävän <code>yhdista</code>-metodi, mutta parantele sitä niin, että yhdistäminen lisää listaan <code>eka</code> lukuja vain, jos ne eivät jo ennestään löydy listalta. Tehtävässä kannattaa käyttää hyväkseen ArrayListin <code>contains</code>-metodia, jolla voit tarkistaa sisältääkö lista jo jonkin luvun.</p>
  </div>
</div>
  <h2>Ohjeita koodin kirjoittamiseen ja ongelmanratkaisuun</h2>
  <p>Kaksi maailman johtavaa ohjelmistonkehittäjää, <em>Martin Fowler</em> ja <em>Kent Beck</em> ovat lausunut kirjassa <em>Refactoring: Improving the Design of Existing Codeseuraavasti</em> seuraavasti:</p>
  <ul>
    <li>Fowler: <em>"Any fool can write code that a computer can understand.  Good programmers write code that humans can understand."</em> </li>
    <li>Beck: <em>"I'm not a great programmer, I'm just a good programmer with great habits."</em> </li>
  </ul>
  <p>[Päivitys: aiemmin molemmat lainaukset olivat merkitty Kent Beckille. Kiitos Esko Luontolalle <a href="http://sourceforge.net/p/mooc-issues/tickets/451/">tämän virheen ilmoittamisesta</a>.]</p>
  <p>Otamme viimeistään nyt ensimmäisiä askelia Fowlerin ja Beckin viitoittamalla tiellä.</p>
  <h3>Oikein sisennetty ja "hengittävä" koodi</h3>
  <p>Tarkastellaan koodia joka ensin lisää listalle lukuja ja tulostaa listan sisällön. Tämän jälkeen listalta poistetaan kaikki tietyn luvun esiintymät ja tulostetaan lista uudelleen.</p>
  <p>Kirjoitetaan koodi ensin huonosti ja jätetään se sisentämättä:</p>
  <pre class="sh_java">
public static void main(String[] args) {
ArrayList&lt;Integer&gt; luvut = new ArrayList&lt;Integer&gt;();
luvut.add(4);
luvut.add(3);
luvut.add(7);
luvut.add(3);
System.out.println("luvut alussa:");

for (int luku : luvut) {
System.out.println(luku);
}

while (luvut.contains(Integer.valueOf(3))) {
luvut.remove(Integer.valueOf(3));
}

System.out.println("luvut poiston jälkeen:");

for (int luku : luvut) {
System.out.println(luku);
}
}
</pre>
  <p>Vaikka sisentämätön koodi toimii, on sitä hyvin ikävä lukea. Sisennetään koodi oikein (NetBeansissa sisennyksen saa korjattua automaattisesti painamalla alt+shift+f), ja erotellaan loogiset kokonaisuudet rivinvaihdoin:</p>
  <pre class="sh_java">
public static void main(String[] args) {
    ArrayList&lt;Integer&gt; luvut = new ArrayList&lt;Integer&gt;();
    luvut.add(4);
    luvut.add(3);
    luvut.add(7);
    luvut.add(3);

    System.out.println("luvut alussa:");

    // tässä tulostetaan luvut
    for (int luku : luvut) {
        System.out.println(luku);
    }

    // tarkastetaan onko listalla luku 3
    while (luvut.contains(Integer.valueOf(3))) {
        luvut.remove(Integer.valueOf(3));  // jos löytyi, niin poistetaan se
    }
    // tehdään tämä whilessä jotta saadaan kaikki kolmoset poistetua!

    System.out.println("luvut poiston jälkeen:");

    // tässä tulostetaan luvut
    for (int luku : luvut) {
        System.out.println(luku);
    }
}
</pre>
  <p>Nyt koodissa alkaa olla jo järkeä. Esimerkiksi tulostus ja kolmosten poisto ovat omia loogisia kokonaisuuksia, joten ne on erotettu rivinvaihdolla. Koodissa on <em>ilmavuutta</em> ja koodin lukeminen alkaa olla miellyttävämpää.</p>
  <p>Koodiin on vieläpä kirjoitettu kommentteja selventämään muutaman kohdan toimintaa.</p>
  <h3>Copy-pasten eliminointi metodeilla</h3>
  <p>Ohjelmoijan lähes pahin mahdollinen perisynti on copy-paste -koodi, eli samanlaisen koodinpätkän toistaminen koodissa useaan kertaan. Esimerkissämme listan tulostus tapahtuu kahteen kertaan. Tulostuksen hoitava koodi on syytä erottaa omaksi metodikseen ja kutsua uutta metodia pääohjelmasta:</p>
  <pre class="sh_java">
public static void main(String[] args) {
    ArrayList&lt;Integer&gt; luvut = new ArrayList&lt;Integer&gt;();
    luvut.add(4);
    luvut.add(3);
    luvut.add(7);
    luvut.add(3);

    System.out.println("luvut alussa:");

    // tässä tulostetaan luvut
    tulosta(luvut);

    while (luvut.contains(Integer.valueOf(3))) {
      luvut.remove(Integer.valueOf(3));
    }

    System.out.println("luvut poiston jälkeen:");

    // tässä tulostetaan luvut
    tulosta(luvut);
}

public static void tulosta(ArrayList&lt;Integer&gt; luvut) {
    for (int luku : luvut) {
        System.out.println( luku );
    }
}
</pre>
  <h3>Erillisten tehtävien erottaminen omiksi, selkeästi nimetyiksi metodeiksi</h3>
  <p>Koodi alkaa olla jo selkeämpää. Selvästi erillinen kokonaisuus, eli listan tulostus on oma helposti ymmärrettävä metodinsa. Uuden metodin esittelyn myötä myös pääohjelman luettavuus on kasvanut. Huomaa että uusi metodi on nimetty mahdollisimman kuvaavasti, eli siten että metodin nimi kertoo mitä metodi tekee. Ohjelmaan kirjoitetut kommentit <em>tässä tulostetaan luvut</em> ovatkin tarpeettomia, joten poistetaan ne.</p>
  <p>Ohjelmassa on vielä hiukan siistimisen varaa. Pääohjelma on vielä sikäli ikävä, että siistien metodikutsujen seassa on vielä suoraan listaa käsittelevä "epäesteettinen" koodinpätkä. Erotetaan tämäkin omaksi metodikseen:</p>
  <pre class="sh_java">
public static void main(String[] args) {
    ArrayList&lt;Integer&gt; luvut = new ArrayList&lt;Integer&gt;();
    luvut.add(4);
    luvut.add(3);
    luvut.add(7);
    luvut.add(3);

    System.out.println("luvut alussa:");
    tulosta(luvut);

    poista(luvut, 3);

    System.out.println("luvut poiston jälkeen:");
    tulosta(luvut);
}

public static void tulosta(ArrayList&lt;Integer&gt; luvut) {
    for (int luku : luvut) {
        System.out.println( luku );
    }
}

public static void poista(ArrayList&lt;Integer&gt; luvut, int poistettava) {
    while (luvut.contains(Integer.valueOf(poistettava))) {
        luvut.remove(Integer.valueOf(poistettava));
    }
}
</pre>
  <p>Loimme yllä loogiselle kokonaisuudelle -- tietyn luvun kaikkien esiintymien poistolle -- oman kuvaavasti nimetyn metodin. Lopputuloksena oleva pääohjelma on nyt erittäin ymmärrettävä, lähes suomen kieltä. Molemmat metodit ovat myös erittäin yksinkertaisia ja selkeitä ymmärtää.</p>
  <p>Kent Beck olisi varmaan tyytyväinen aikaansaannokseemme, koodi on helposti ymmärrettävää, helposti muokattavaa eikä sisällä copy-pastea.</p>
</div>
</section>
<div class="tyhja"></div>



<section class="viikkoraja" id ="4">
<div class="viikkoraja">Viikko 4</div>
<div class="viikkoraja-mooc" id="Viikko 4" deadline="avautuu kun 85 %  3. viikosta tehty" data-first-chapter-index="20" data-first-exercise-index="72" data-first-week-index="4" data-first-chapter-index-mooc="20" data-first-exercise-index-mooc="72" data-first-week-index-mooc="4" tekija="Arto Vihavainen, Matti Luukkainen">


  <h2 id="olio_ohjelmointi">Olio-ohjelmointi</h2>
  <p>Pieni johdanto olio-ohjelmointiin ennen aloitusta.</p>
  <p>Proseduraalisessa ohjelmoinnissa, eli tähän asti opiskelemassamme ohjelmointityylissä, ohjelma jäsennellään jakamalla se pienempiin osiin eli metodeihin.  Metodi toimii ohjelman erillisenä osana, ja sitä voi kutsua mistä tahansa ohjelmastan sisältä.  Metodia kutsuttaessa ohjelman suoritus siirtyy metodin alkuun, ja suorituksen päätyttyä palataan takaisin siihen kohtaan mistä metodia kutsuttiin.</p>
  <p>Olio-ohjelmoinnissa, kuten proseduraalisessa ohjelmoinnissa, pyritään jakamaan ohjelma pieniin osiin.  Olio-ohjelmoinnissa pienet osat ovat olioita.  Jokaisella oliolla on oma yksittäinen vastuunsa eli se sisältää joukon yhteenkuuluvaa tietoa ja toiminnallisuutta.  Olio-ohjelmat koostuvat useista olioista, joiden yhteinen toiminta määrittelee järjestelmän toiminnan.</p>
  <h3>Olio</h3>
  <p>Olemme käyttäneet jo monia Javan valmiita olioita. Esimerkiksi <code>ArrayList</code>:it ovat olioita. Jokainen yksittäinen lista koostuu yhteenkuuluvasta tiedosta, eli <i>olion tilasta</i>. Listaolioihin liittyy toiminnallisuutta, eli metodt joilla olion tilaa voidaan muuttaa. Esimerkiksi seuraavassa ohjelmanpätkässä on kaksi <code>ArrayList</code>-olioa <code>kaupungit</code> ja <code>maat</code>:</p>
  <pre class="sh_java">
public static void main(String[] args) {
    ArrayList&lt;String&gt; kaupungit = new ArrayList&lt;String&gt;();
    ArrayList&lt;String&gt; maat = new ArrayList&lt;String&gt;();

    maat.add("Suomi");
    maat.add("Saksa");
    maat.add("Hollanti");

    kaupungit.add("Berliini");
    kaupungit.add("Nijmegen");
    kaupungit.add("Turku");
    kaupungit.add("Helsinki");

    System.out.println("maita " + maat.size() );
    System.out.println("kaupunkeja " + kaupungit.size() );
}
</pre>
  <p>Sekä <code>maat</code>-olio että <code>kaupungit</code>-olio elää omaa elämäänsä. Molempien "tila" on toisten olioiden tilasta riippumaton. Esim. olion <code>maat</code> tila koostuu listalla olevista merkkijonoista "Suomi", "Saksa" ja "Hollanti" ja todennäköisesti myös tiedosta kuinka monta maata listalla on.</p>
  <p>Olioon liittyvää metodikutsua tehdessä (esimerkiksi <code>maat.add("Suomi");</code>) pisteen vasemmalle puolelle tulee sen olion nimi, jolle metodia kutsutaan, oikealle metodin nimi. Kun kysytään montako merkkijonoa listalla <code>maat</code> on, kutsu on muotoa <code>maat.size()</code> eli kutsutaan <code>maat</code> oliolle sen metodia <code>size</code>. Metodin palauttama tulos riippuu olion <code>maat</code> tilasta, eli muut oliot kuten <code>kaupungit</code> eivät vaikuta metodin suoritukseen millään tavalla.</p>
  <p>Olemme jo useasti käyttämään komentoa <code>new</code>. Esimerkiksi listan (<code>ArrayList</code>) ja lukijan (<code>Scanner</code>) luominen on tapahtunut <code>new</code>-komennolla. Syy on se, että kumpikin näistä on <em>Luokkia</em>, joista olio luodaan. Java-kielessä oliot luodaan aina <code>new</code>-komennolla muutamaa poikkeusta lukuunottamatta.</p>
  <p>Yksi näistä poikkeuksista ovat merkkijonot, joiden luomiseen ei aina tarvita <code>new</code>:iä. Tuttu tapa merkkijonon luomiseen on oikeastaan Javan lyhennysmerkintä <code>new</code>:in käytölle. Merkkijonon voi luoda myös new:illä kuten muutkin oliot:</p>
<pre class="sh_java">
String teksti = "tekstiä";       // lyhennysmerkintä merkkijono-olion luomiselle
String toinenTeksti = new String("lisää tekstiä");
</pre>
  </p>
  <p>On myös tilanteita, missä Javan valmis kalusto kutsuu <code>new</code>:iä piilossa ohjelmoijalta.</p>
  <h3>Luokka</h3>
  <p>On selvää että kaikki oliot eivät ole keskenään samankaltaisia. Esim. <code>ArrayList</code>-oliot poikkeavat ratkaisevasti <code>String</code>-olioista. Kaikilla <code>ArrayList</code>:eillä on samat metodit (<code>add</code>, <code>contains</code>, <code>remove</code>, <code>size</code>, ...) ja vastaavasi kaikilla <code>String</code>-olioilla on samat metodit (<code>substring</code>, <code>length</code>, <code>charAt</code>, ...). <code>ArrayList</code>- ja <code>String</code>-olioiden metodit eivät ole samat sillä ne ovat eri <em>tyyppisiä</em> olioita.</p>
  <p>Tietyn olioryhmän tyyppiä kutsutaan <b>luokaksi</b>. <code>ArrayList</code> on luokka, <code>String</code> on luokka, <code>Scanner</code> on luokka, jne... Oliot taas ovat luokasta tehtyjä <em>ilmentymiä</em>.</p>
  <p>Luokan kaikilla olioilla on samat metodit, sekä samankaltainen tila. Esim. kaikkien <code>ArrayList</code>-olioiden tila koostuu listalle tallennetuista alkioista. <code>String</code>-olioiden tila taas koostuu merkkijonon muodostavista kirjaimista.</p>
  <h3>Luokka ja sen oliot</h3>
  <p><b>Luokka määrittelee</b> minkälaisia luokan oliot ovat:</p>
  <ul>
    <li><b>mitä metodeita olioilla on</b></li>
    <li><b>minkälainen olioiden tila on</b> tai toisinsanoen mitä ominaisuuksia olioilla on</li>
  </ul>
  <p>Luokka kuvaa siitä luotavien olioiden "rakennuspiirustukset".</p>
  <p>Otetaan analogia tietokoneiden ulkopuoleisesta maailmasta. Rintamamiestalot lienevät kaikille suomalaisille tuttuja. Voidaan ajatella, että jossain on olemassa piirustukset jotka määrittelevät minkälainen rintamamiestalo on. Piirrustukset ovat luokka, eli ne määrittelevät luokasta luotavien olioiden luonteen:</p>
  <p><img src=" https://www.cs.helsinki.fi/group/java/k13/ohpe/img/luokka.jpg"/></p>
  <p>Yksittäiset oliot eli rintamamiestalot on tehty samojen piirustusten perusteella, eli ne ovat saman luokan ilmentymiä. Yksittäisten olioiden tila eli ominaisuudet (esim. seinien väri, katon rakennusmateriaali ja väri, kivijalan väri, ovien rakennusmateriaali ja väri, ...) vaihtelevat. Seuraavassa yksi "rintamamiestalo-luokan olio":</p>
  <p><img src=" https://www.cs.helsinki.fi/group/java/k13/ohpe/img/olio.jpg" height=250 /></p>
  <p>Luokasta luodaan olio aina kutsumalla olion luovaa metodia eli <em>konstruktoria</em> komennon <code>new</code> avulla. Esimerkiksi <code>Scanner</code>-luokasta luodaan uusi ilmentymä eli olio kun kutsutaan <code>new Scanner(..)</code>:</p>
  <pre class="sh_java">
  Scanner lukija = new Scanner(System.in);
</pre>
  <p>Konstruktorit saavat parametreja kuten muutkin metodit.</p>
  <div class="tehtavat" id="viikko4">
    <div class="tehtava">
    <h3>Tilejä</h3>
    <p>Tehtäväpohjan mukana tulee valmis luokka <code>Tili</code>.
      Luokan <code>Tili</code> olio esittää pankkitiliä, jolla on saldo
      (eli jossa on jokin määrä rahaa). Tilejä käytetään näin:</p>
    <pre class="sh_java">
Tili artonTili = new Tili("Arton tili",100.00);
Tili artonSveitsilainenTili = new Tili("Arton tili Sveitsissä",1000000.00);

System.out.println("Alkutilanne");
System.out.println(artonTili);
System.out.println(artonSveitsilainenTili);

artonTili.otto(20);
System.out.println("Arton tilin saldo on nyt: "+artonTili.saldo());
artonSveitsilainenTili.pano(200);
System.out.println("Arton toisen tilin saldo on nyt: "+artonSveitsilainenTili.saldo());

System.out.println("Lopputilanne");
System.out.println(artonTili);
System.out.println(artonSveitsilainenTili);
</pre>
    <h4>Ensimmäinen tilisi</h4>
    <p>
      <large><b>Huom:</b> tämän tehtävän jokaista alikohtaa varten on oma tehtäväpohja, tee tämä tehtävä pohjaan 072.1</large>
    </p>
    <p>Tee ohjelma, joka luo tilin jonka saldo on 100.0, panee tilille
      20.0 ja tulostaa tilin. <strong>Huom!</strong> tee kaikki nämä
      operaatiot täsmälleen tässä järjestyksessä.</p>
    <h4>Ensimmäinen tilisiirtosi</h4>
    <p>
      <large><b>Huom:</b> tämän tehtävän jokaista alikohtaa varten on oma tehtäväpohja, tee tämä tehtävä pohjaan 072.2</large>
    </p>
    <p>Tee ohjelma joka:</p>
    <ol class="lista">
      <li>Luo tilin nimeltä <code>"Matin tili"</code> saldolla 1000</li>
      <li>Luo tilin nimeltä <code>"Oma tili"</code> saldolla 0</li>
      <li>Nostaa matin tililtä 100.0</li>
      <li>Panee omalle tilille 100.0</li>
      <li>Tulosta molemmat tilit</li>
    </ol>
    <h4>Tilisiirtoja</h4>
    <p>
      <large><b>Huom:</b> tämän tehtävän jokaista alikohtaa varten on oma tehtäväpohja, tee tämä tehtävä pohjaan 072.3</large>
    </p>
    <p>Yllä siirsit rahaa tililtä toiselle. Tehdään seuraavaksi metodi joka tekee saman!</p>
    <p>Toteuta ohjelmapohjaan metodi <code>public static void tilisiirto(Tili
      mista, Tili minne, double paljonko)</code> joka siirtää rahaa
      tililtä toiselle. Sinun ei tarvitse tarkistaa
      että <code>mista</code>-tilin saldo riittää.</p>
    <p>Tämän jälkeen tee <code>main</code>-metodissasi seuraavaa:</p>
    <ol class="lista">
      <li>Luo tili <code>"A"</code> saldolla 100.0</li>
      <li>Luo tili <code>"B"</code> saldolla 0.0</li>
      <li>Luo tili <code>"C"</code> saldolla 0.0</li>
      <li>Siirrä 50.0 tililtä A tilille B.</li>
      <li>Siirrä 25.0 tililtä B tilille C.</li>
    </ol>
  </div>
</div>
  <h3>Oman luokan määritteleminen - oliomuuttujat</h3>
  <p>Luokka määritellään jotain mielekästä kokonaisuutta varten. Usein "mielekäs kokonaisuus" kuvaa jotain reaalimaailman asiaa. Jos tietokoneohjelman pitää käsitellä henkilötietoja, voisi olla mielekästä määritellä erillinen luokka <code>Henkilo</code> joka kokoaa yhteen henkilöön liittyvät metodit ja ominaisuudet.</p>
  <p>Aloitetaan. Oletetaan että meillä on projektirunko jossa on tyhjä pääohjelma:</p>
  <pre class="sh_java">
public class Main {

    public static void main(String[] args) {

    }

}
  </pre>
  <div class="help">
  <p>Luomme nyt projektiimme eli ohjelmaamme uuden luokan. Tämä tapahtuu valitsemalla NetBeansissa vasemmalta <em>projects</em>-kohdasta hiiren oikealla napilla <em>new</em> ja <em>java class</em>. Avautuvaan dialogiin annetaan luokalle nimi.</p>
  <p>Kuten muuttujien ja metodien nimien, myös luokan nimen on aina oltava mahdollisimman kuvaava. Joskus ohjelmoinnin edetessä luokka elää ja muuttaa muotoaan. Tällaisissa tilanteissa luokan voi nimetä uudelleen (

        <!-- BEGIN mini MOOC SNIP-->
    <a class="ahy"  href="../../netbeans/">ks. NetBeans ohje</a>
    <!-- END mini MOOC SNIP-->
    <!-- BEGIN mini SNIP-->
    <a class="amooc"  href="http://mooc.cs.helsinki.fi/ohjelmointi/ohjeita#netbeans">ks. NetBeans ohje</a>
    <!-- END mini SNIP-->).</p>
  </div>
  <p>Luodaan luokka nimeltä <code>Henkilo</code>. Luokasta muodostuu oma tiedostonsa <code>Henkilo.java</code>. Eli ohjelma koostuu nyt kahdesta tiedostosta, sillä pääohjelma on omassa tiedostossaan. Aluksi luokka on tyhjä:</p>
  <pre class="sh_java">
public class Henkilo {

}
</pre>
  <p>Luokan tulee määritellä mitä metodeja ja ominaisuuksia luokan olioilla on. Päätetään, että jokaisella henkilöllä on nimi ja ikä. Nimi on luonnollista esittää merkkijonona, eli Stringinä, ja ikä taas kokonaislukuna. Lisätään nämä rakennuspiirustuksiimme:</p>
  <pre class="sh_java">
public class Henkilo {
    private String nimi;
    private int ika;
}
</pre>
  <p>Määrittelimme yllä että kaikilla <code>Henkilo</code>-luokan olioilla on <code>nimi</code> ja <code>ika</code>. Määritettely tapahtuu hiukan kuten normaalin muuttujan määrittely. Eteen on kuitenkin nyt laitettu avainsana <code>private</code>. Tämä tarkoittaa sitä, että nimi ja ikä eivät näy suoraan olion ulkopuolelle vaan ovat "piilossa" olion sisällä. Olion sisälle piilottamista kutsutaan <em>kapseloinniksi</em>.</p>
  <p>Luokan sisälle määriteltyjä muuttujia kutsutaan <i>oliomuuttujiksi</i> tai <i>olion kentiksi</i> tai <i>olion attribuuteiksi</i>. Rakkaalla lapsella on monta nimeä.</p>
  <p>Eli olemme määritelleet rakennuspiirustukset -- luokan -- henkilöoliolle. Kaikilla henkilöolioilla on muuttujat <code>nimi</code> ja <code>ika</code>. Henkilöiden "tila" koostuu niiden nimeen ja ikään asetetuista arvoista.</p>
  <h3>Oman luokan määritteleminen - konstruktori eli tilan alustus</h3>
  <p>Luotavalle oliolle halutaan asettaa luontivaiheessa jokin alkutila. Itse määritellyn olion luominen tapahtuu hyvin samaan tapaan kuin Javan valmiiden olioiden kuten <code>ArrayList</code>:ien luominen. Oliot siis luodaan <code>new</code>-komennolla. Olion synnyttämisen yhteydessä olisikin kätevä pystyä antamaan arvo joillekin olioiden muuttujille. Esim. henkilön synnytyksessä olisi kätevää pystyä antamaan nimi jo syntymähetkellä: </p>
  <pre class="sh_java">
public static void main(String[] args) {
    Henkilo pekka = new Henkilo("Pekka");
    // ...
}
</pre>
  <p>Tämä onnistuu määrittelemällä olion synnyttävä metodi, eli <em>konstruktori</em>. Seuraavassa on määritelty <code>Henkilo</code>-luokalle konstruktori, joka luo uuden <code>Henkilo</code>-olion. Konstruktorissa luotavan henkilön iäksi asetetaan 0 ja nimeksi parametrina tuleva merkkijono:</p>
  <pre class="sh_java">
public class Henkilo {
    private String nimi;
    private int ika;

    public Henkilo(String nimiAlussa) {
        this.ika = 0;
        this.nimi = nimiAlussa;
      }
}
</pre>
  <p>Konstruktori on siis nimeltään sama kuin luokan nimi. Yllä luokka (<em>class</em>) on <code>Henkilo</code>, ja konstruktori <code>public Henkilo(String nimiAlussa)</code>. Konstruktorille parametrina tuleva arvo tulee sulkuihin konstruktorin nimen perään. Konstruktorin voi ajatella olevan metodi, jonka Java suorittaa kun olio luodaan sanomalla <code>new Henkilo("Pekka");</code> Aina kun jostain luokasta luodaan olio, kutsutaan kyseisen luokan konstruktoria. </p>
  <p>Muutama huomio: konstruktorin sisällä on komento <code>this.ika = 0</code>. Tässä asetetaan arvo 0 <em>juuri tämän olion, eli "this"-olion</em> sisäiselle muuttujalle <code>ika</code>. Toinen komento <code>this.nimi = nimiAlussa;</code> taas asettaa juuri tämän olion sisäiselle muuttujalle <code>nimi</code> arvoksi parametrina annetun merkkijonon. Olion muuttujat <code>ika</code> ja <code>nimi</code> näkyvät konstruktorissa ja muuallakin olion sisällä automaattisesti. Niihin viitataan <code>this</code>-etuliitteellä. Koska niissä on private-määre, niin olion ulkopuolelle ne eivät näy.</p>
  <p>Vielä yksi huomio: jos ohjelmoija ei tee luokalle konstruktoria, tekee Java automaattisesti luokalle oletuskonstruktorin. Oletuskonstruktori on konstruktori joka ei tee mitään. Eli jos konstruktoria ei jostain syystä tarvita, ei sellaista tarvitse ohjelmoida.</p>
  <h3>Oman luokan määritteleminen - metodit</h3>
  <p>Alkaa olla korkea aika päästä käyttämään <code>Henkilo</code>-olioita. Osaamme luoda olion ja alustaa olion muuttujat. Järkevään toimintaan pystyäkseen olioilla on oltava myös metodeja. Tehdään <code>Henkilo</code>-luokalle metodi jonka avulla olio tulostaa itsensä ruudulle:</p>
  <pre class="sh_java">
public class Henkilo {
    private String nimi;
    private int ika;

    public Henkilo(String nimiAlussa) {
        this.ika = 0;
        this.nimi = nimiAlussa;
    }

    public void tulostaHenkilo() {
        System.out.println(this.nimi + ", ikä " + this.ika + " vuotta");
    }
}
</pre>
  <p>Metodi siis kirjoitetaan luokan sisälle, metodin nimen eteen tulee <code>public void</code> sillä metodin on tarkoitus näkyä ulkomaailmalle ja metodi ei palauta mitään. Huomaa, että sana <code>static</code> ei nyt ilmene missään. Olioiden yhteydessä <code>static</code>-määrettä ei käytetä. Selitämme ensi viikolla hieman tarkemmin mistä tässä on kysymys.</p>
  <p>Metodin <code>tulostaHenkilo</code> sisällä on yksi koodirivi joka käyttää hyvakseen oliomuuttujia <code>nimi</code> ja <code>ika</code>. Juuri tämän olion muuttujiin viitataan taas etuliitteellä <code>this</code>. Kaikki olion muuttujat ovat siis näkyvillä ja käytettävissä metodin sisällä.</p>
  <p>Luodaan pääohjelmassa kolme henkilöä ja pyydetään niitä tulostamaan itsensä:</p>
  <pre class="sh_java">
public class Main {

    public static void main(String[] args) {
        Henkilo pekka = new Henkilo("Pekka");
        Henkilo antti = new Henkilo("Antti");
        Henkilo martin = new Henkilo("Martin");

        pekka.tulostaHenkilo();
        antti.tulostaHenkilo();
        martin.tulostaHenkilo();
    }
}
</pre>
  <p>Tulostuu:</p>
<pre>
Pekka, ikä 0 vuotta
Antti, ikä 0 vuotta
Martin, ikä 0 vuotta
</pre>
  <p>Sama screencastina: </p>
  <a href="http://www.youtube.com/watch?feature=player_embedded&v=fWwXQ5n2gYo" height="300" target="_blank"><img src=" https://www.cs.helsinki.fi/group/java/k13/ohpe/img/youtube.jpg"/></a>


  <div class="tehtavat">
    <div class="tehtava">
    <h3>Tuote</h3>
    <p>Luo luokka <code>Tuote</code> joka esittää kaupan tuotetta jolla on hinta, lukumäärä ja nimi.</p>
    <p> Uuden luokan saa lisättyä seuraavasti: Ruudun vasemmalla reunalla on projektilistaus. Paina projektin nimen <em>073.Tuote</em> kohdalla hiiren oikeaa nappia. Valitse avautuvasta valikosta <em>New</em> ja <em>Java Class</em>. Anna luokan nimeksi (Class Name) <code>Tuote</code>. </p>
    <p>Luokalla tulee olla:</p>
    <ul>
      <li>Konstruktori <code>public Tuote(String nimiAlussa, double hintaAlussa, int maaraAlussa)</code></li>
      <li>Metodi <code>public void tulostaTuote()</code> joka tulostaa tuotteen tiedot tässä muodossa:
        <pre>
Banaani, hinta 1.1, 13 kpl
      </pre>
      </li>
    </ul>
  </div>
</div>
  <h3>lisää metodeja</h3>
  <p>Lisätään aiemmin rakentamallemme Henkilölle metodi, joka kasvattaa henkilön ikää vuodella:</p>
  <pre class="sh_java">
public class Henkilo {
    // ...

    public void vanhene() {
      this.ika = this.ika + 1;
    }
}
</pre>
  <p>Metodi siis kirjoitetaan <code>tulostaHenkilo</code>-metodin tapaan luokan <code>Henkilo</code> sisälle. Metodissa kasvatetaan oliomuuttujan <code>ika</code> arvoa yhdellä.</p>
  <p>Kutsutaan metodia ja katsotaan mitä tapahtuu:</p>
  <pre class="sh_java">
public class Main {

    public static void main(String[] args) {
        Henkilo pekka = new Henkilo("Pekka");
        Henkilo antti = new Henkilo("Antti");

        pekka.tulostaHenkilo();
        antti.tulostaHenkilo();

        System.out.println("");

        pekka.vanhene();
        pekka.vanhene();

        pekka.tulostaHenkilo();
        antti.tulostaHenkilo();
      }
}
</pre>
  <p>Ohjelman tulostus on seuraava:</p>
  <pre>
Pekka, ikä 0 vuotta
Antti, ikä 0 vuotta

Pekka, ikä 2 vuotta
Antti, ikä 0 vuotta
</pre>
  <p>Eli "syntyessään" molemmat oliot ovat nollavuotiaita (konstruktorissa suoritetaan mm. rivi <code>this.ika = 0;</code>). Olion <code>pekka</code> metodia <code>vanhene</code> kutsutaan kaksi kertaa. Kuten tulostus näyttää, tämä saa aikaan sen että Pekan ikä on vanhenemisen jälkeen 2 vuotta. Kutsumalla metodia Pekkaa vastaavalle oliolle, toisen henkilöolion ikä ei muutu.</p>
  <p>Jokaisella oliolla on siis oma sisäinen tilansa.</p>
  <p>Aivan kuiten edellisellä viikolla käsittelemämme olioihin liittymättömät metodit, myös olioihin liittyvät metodit voivat palauttaa arvon. Lisätään Henkilölle metodi joka palauttaa henkilön iän:</p>
  <pre class="sh_java">
public class Henkilo {
    // ...

    public int palautaIka() {
        return this.ika;
    }
}
</pre>
  <p>Eli koska kyseessä olioon liittyvä metodi, ei määrittelyssä ole sanaa static. Olioiden arvon palauttavia metodeja käytetään kuten mitä tahansa arvon palauttavia metodeja:</p>
  <pre class="sh_java">
public class Main {

    public static void main(String[] args) {
        Henkilo pekka = new Henkilo("Pekka");
        Henkilo antti = new Henkilo("Antti");

        pekka.vanhene();
        pekka.vanhene();

        antti.vanhene();

        System.out.println( "Pekan ikä: "+pekka.palautaIka() );
        System.out.println( "Antin ikä: "+antti.palautaIka() );

        int yht = pekka.palautaIka() + antti.palautaIka();

        System.out.println( "Pekka ja Antti yhteensä "+yht+ " vuotta" );
    }
}
</pre>
  <p>Ohjelman tulostus on seuraava:</p>
  <pre>
Pekan ikä 2
Antin ikä 1

Pekka ja Antti yhteensä 3 vuotta
</pre>
<div class="tehtavat">
  <div class="tehtava">
    <h3>Kertoja</h3>
    <p>Luo luokka <code>Kertoja</code> jolla on:</p>
    <ul>
      <li>Konstruktori <code>public Kertoja(int luku)</code>.</li>
      <li>Metodi <code>public int kerro(int toinenLuku)</code> joka palauttaa sille annetun luvun <code>toinenLuku</code> kerrottuna konstruktorille annetulla luvulla <code>luku</code>.</li>
    </ul>
    <p>Esimerkki luokan käytöstä:</p>
    <pre class="sh_java">
Kertoja kolmellaKertoja = new Kertoja(3);

System.out.println("kolmellaKertoja.kerro(2): " + kolmellaKertoja.kerro(2));

Kertoja neljallaKertoja = new Kertoja(4);

System.out.println("neljallaKertoja.kerro(2): " + neljallaKertoja.kerro(2));
System.out.println("kolmellaKertoja.kerro(1): " + kolmellaKertoja.kerro(1));
System.out.println("neljallaKertoja.kerro(1): " + neljallaKertoja.kerro(1));
  </pre>
    <p>Tulostus</p>
<pre>
kolmellaKertoja.kerro(2): 6
neljallaKertoja.kerro(2): 8
kolmellaKertoja.kerro(1): 3
neljallaKertoja.kerro(1): 4
</pre>
</div>
<div class="tehtava">
    <h3>Vähenevä laskuri</h3>
    <p>Tehtäväpohjan mukana tulee osittain valmiiksi toteutettu luokka <code>VahenevaLaskuri</code>:</p>
    <pre class="sh_java">
public class VahenevaLaskuri {
    private int arvo;   // oliomuuttuja joka muistaa laskurin arvon

    public VahenevaLaskuri(int arvoAlussa) {
        this.arvo = arvoAlussa;
    }

    public void tulostaArvo() {
        System.out.println("arvo: " + this.arvo);
    }

    public void vahene() {
        // kirjoita tänne metodin toteutus
        // laskurin arvon on siis tarkoitus vähentyä yhdellä
    }

    // ja tänne muut metodit
}
</pre>
    <p>Seuraavassa esimerkki miten pääohjelma käyttää vähenevää laskuria: </p>
    <pre class="sh_java">
public class Paaohjelma {
    public static void main(String[] args) {
        VahenevaLaskuri laskuri = new VahenevaLaskuri(10);

        laskuri.tulostaArvo();

        laskuri.vahene();
        laskuri.tulostaArvo();

        laskuri.vahene();
        laskuri.tulostaArvo();
    }
}
</pre>
    <p>Pitäisi tulostua:</p>
<pre>
arvo: 10
arvo: 9
arvo: 8
</pre>
    <p><code>VahenevaLaskuri</code>-luokan konstruktorille annetaan parametrina alkuarvo. Esimerkin oliota <code>laskuri</code> luodessa laskurille välitetään parametrina arvo <code>10</code>. Esimerkin <code>laskuri</code>-olioon liittyvään oliomuuttujaan <code>arvo</code> asetetaan siis aluksi arvo <code>10</code>. Laskurin arvon voi tulostaa metodilla <code>tulostaArvo()</code>. Laskurilla tulee myös olla metodi <code>vahene()</code> joka vähentää laskurin arvoa yhdellä.</p>
    <h4>Metodin vahene() toteutus</h4>
    <p>Täydennä luokan runkoon metodin <code>vahene()</code> toteutus sellaiseksi, että se vähentää kutsuttavan olion oliomuuttujan <code>arvo</code> arvoa yhdellä. Kun olet toteuttanut metodin <code>vahene()</code>, edellisen esimerkin pääohjelman tulee toimia esimerkkitulosteen mukaan.</p>
    <h4>Laskurin arvo ei saa olla negatiivinen</h4>
    <p>Täydennä metodin <code>vahene()</code> toteutus sellaiseksi, ettei laskurin arvo mene koskaan negatiiviseksi. Eli jos laskurin arvo on jo 0, ei vähennys sitä enää vähennä:</p>
    <pre class="sh_java">
public class Paaohjelma {
    public static void main(String[] args) {
        VahenevaLaskuri laskuri = new VahenevaLaskuri(2);

        laskuri.tulostaArvo();

        laskuri.vahene();
        laskuri.tulostaArvo();

        laskuri.vahene();
        laskuri.tulostaArvo();

        laskuri.vahene();
        laskuri.tulostaArvo();
    }
}
</pre>
    <p>Tulostuu:</p>
<pre>
arvo: 2
arvo: 1
arvo: 0
arvo: 0
</pre>
    <h4>Laskurin arvon nollaus</h4>
    <p>Tee laskurille metodi <code>public void nollaa()</code> joka nollaa laskurin arvon, esim:</p>
    <pre class="sh_java">
public class Paaohjelma {
    public static void main(String[] args) {
        VahenevaLaskuri laskuri = new VahenevaLaskuri(100);

        laskuri.tulostaArvo();

        laskuri.nollaa();
        laskuri.tulostaArvo();

        laskuri.vahene();
        laskuri.tulostaArvo();
    }
}
</pre>
    <p>Tulostuu:</p>
<pre>
arvo: 100
arvo: 0
arvo: 0
</pre>
    <h4>Laskurin arvon palautus</h4>
    <p>Tee laskurille metodi <code>public void palautaAlkuarvo()</code>, joka palauttaa laskurille arvon joka sillä oli alussa:</p>
    <pre class="sh_java">
public class Paaohjelma {
  public static void main(String[] args) {
      VahenevaLaskuri laskuri = new VahenevaLaskuri(100);

      laskuri.tulostaArvo();

      laskuri.vahene();
      laskuri.tulostaArvo();

      laskuri.vahene();
      laskuri.tulostaArvo();

      laskuri.nollaa();
      laskuri.tulostaArvo();

      laskuri.palautaAlkuarvo();
      laskuri.tulostaArvo();
    }
}
</pre>
<p>Tulostuu:</p>
<pre>
arvo: 100
arvo: 99
arvo: 98
arvo: 0
arvo: 100
</pre>
    <p><strong>Vihje</strong> jotta alkuarvon voi palauttaa, se täytyy "muistaa" toisen oliomuuttujan avulla! Joudut siis lisäämään ohjelmaan oliomuuttujan johon talletetaan laskurin alussa saama arvo.</p>
  </div>
  <div class="tehtava">
    <h3>Ruokalista</h3>
    <p>Kumpulan kampuksella Helsingissä toimivaan Unicafe-nimiseen gourmet-ravintolaan tarvitaan uusi ruokalista. Keittiömestari tietää ohjelmoinnista, ja haluaa listan hallinnointiin tietokonejärjestelmän. Toteutetaan tässä tehtävässä järjestelmän sydän, luokka Ruokalista.</p>
    <p>Tehtäväpohjan mukana tulee <code>Main</code>-luokka, jossa voit testata ruokalistan toimintaa. Ruokalistan toteuttamista varten saat seuraavanlaisen tehtäväpohjan:</p>
    <pre class="sh_java">
import java.util.ArrayList;

public class Ruokalista {

    private ArrayList&lt;String&gt; ateriat;

    public Ruokalista() {
        this.ateriat = new ArrayList&lt;String&gt;();
    }

    // toteuta tänne tarvittavat metodit
}
</pre>
    <p>Ruokalistaoliolla on siis oliomuuttujana ArrayList, jonka on tarkoitus tallentaa ruokalistalla olevien ruokalajien nimet.</p>
    <p>Ruokalistan tulee tarjota metodit <code>public void lisaaAteria(String ateria)</code>, <code>public void tulostaAteriat()</code>, ja <code>public void tyhjennaRuokalista()</code>.</p>
    <h4>Aterian lisääminen</h4>
    <p>Toteuta metodi <code>public void lisaaAteria(String ateria)</code>, joka lisää uuden aterian ruokalistan <code>ateriat</code>-listaan. Jos lisättävä ateria on jo listassa, sitä ei lisätä uudelleen.</p>
    <h4>Aterioiden tulostaminen</h4>
    <p>Toteuta metodi <code>public void tulostaAteriat()</code>, joka tulostaa ateriat. Esimerkiksi kolmen aterian lisäyksen jälkeen tulostuksen tulee olla seuraavanlainen.</p>
<pre>
ensimmäisenä lisätty ateria
toisena lisätty ateria
kolmantena lisätty ateria
</pre>
    <h4>Ruokalistan tyhjentäminen</h4>
    <p>Toteuta metodi <code>public void tyhjennaRuokalista()</code> joka tyhjentää ruokalistan. <code>ArrayList</code>-luokalla on metodi josta on tässä hyötyä. NetBeans osaa vihjata käytettävissä olevista metodeista kun kirjoitat olion nimen ja pisteen. Yritä kirjoittaa <code>ateriat.</code> metodirungon sisällä ja katso mitä käy.</p>
  </div>
</div>
  <h3>Henkilo-luokka laajenee</h3>
  <p>Jatketaan taas <code>Henkilo</code>-luokan laajentamista. Luokan tämänhetkinen versio on seuraava:</p>
  <pre class="sh_java">
public class Henkilo {
    private String nimi;
    private int ika;

    public Henkilo(String nimiAlussa) {
        this.ika = 0;
        this.nimi = nimiAlussa;
    }

    public void tulostaHenkilo() {
        System.out.println(this.nimi + ", ikä " + this.ika + " vuotta");
    }

    public void vanhene() {
        this.ika = this.ika + 1;
    }
}
</pre>
  <p>Tehdään henkilölle metodi, jonka avulla voidaan selvittää onko henkilö täysi-ikäinen. Metodi palauttaa totuusarvon -- joko <code>true</code> tai <code>false</code>:</p>
  <pre class="sh_java">
public class Henkilo {
  // ...

  public boolean taysiIkainen(){
      if ( this.ika &lt; 18 ) {
          return false;
      }

      return true;
    }

    /*
    huom. metodin voisi kirjoittaa lyhyemmin seuraavasti:

    public boolean taysiIkainen(){
        return this.ika >= 18;
    }
    */
}
</pre>
  <p>Ja testataan:</p>
  <pre class="sh_java">
public static void main(String[] args) {
    Henkilo pekka = new Henkilo("Pekka");
    Henkilo antti = new Henkilo("Antti");

    int i = 0;
    while ( i &lt; 30 ) {
        pekka.vanhene();
        i++;
    }

    antti.vanhene();

    System.out.println("");

    if ( antti.taysiIkainen() ) {
        System.out.print("täysi-ikäinen: ");
        antti.tulostaHenkilo();
    } else {
        System.out.print("alaikäinen: ");
        antti.tulostaHenkilo();
    }

    if ( pekka.taysiIkainen() ) {
        System.out.print("täysi-ikäinen: ");
        pekka.tulostaHenkilo();
    } else {
        System.out.print("alaikäinen: ");
        pekka.tulostaHenkilo();
    }
}
</pre>
  <pre>
alaikäinen: Antti, ikä 1 vuotta
täysi-ikäinen: Pekka, ikä 30 vuotta
</pre>
  <p>Viritellään ratkaisua vielä hiukan. Nyt henkilön pystyy "tulostamaan" ainoastaan siten, että nimen lisäksi tulostuu ikä. On tilanteita, joissa haluamme tietoon pelkän olion nimen. Eli tehdään tarkoitusta varten oma metodi:</p>
  <pre class="sh_java">
public class Henkilo {
    // ...

    public String getNimi() {
        return this.nimi;
      }
}
</pre>
  <p>Metodi <code>getNimi</code> palauttaa oliomuuttujan <code>nimi</code> kutsujalle. Metodin nimi on hieman erikoinen. Javassa on usein tapana nimetä oliomuuttujan palauttava metodi juuri näin, eli <code>getMuuttujanNimi</code>. Tälläisiä metodeja kutsutaan usein "gettereiksi".</p>
  <p>Muotoillaan pääohjelma käyttämään uutta "getteri"-metodia:</p>
  <pre class="sh_java">
public static void main(String[] args) {
    Henkilo pekka = new Henkilo("Pekka");
    Henkilo antti = new Henkilo("Antti");

    int i = 0;
    while ( i &lt; 30 ) {
        pekka.vanhene();
        i++;
    }

    antti.vanhene();

    System.out.println("");

    if ( antti.taysiIkainen() ) {
        System.out.println( antti.getNimi() + " on täysi-ikäinen" );
    } else {
        System.out.println( antti.getNimi() + " on alaikäinen" );
    }

    if ( pekka.taysiIkainen() ) {
        System.out.println( pekka.getNimi() + " on täysi-ikäinen" );
    } else {
        System.out.println( pekka.getNimi() + " on alaikäinen " );
    }
}
</pre>
  <p>Tulostus alkaa olla jo aika siisti:</p>
  <pre>
Antti on alaikäinen
Pekka on täysi-ikäinen
</pre>

  <h3>toString</h3>
  <p>Olemme syyllistyneet edellä osittain huonoon ohjelmointityyliin tekemällä metodin jonka avulla olio tulostetaan, eli metodin <code>tulostaHenkilo</code>. Suositeltavampi tapa on määritellä oliolle metodi jonka palauttaa olion "merkkijonoesityksen". Merkkijonoesityksen palauttavan metodin nimi on Javassa aina <code>toString</code>. Määritellään seuraavassa henkilölle tämä metodi:</p>
  <pre class="sh_java">
public class Henkilo {
    // ...

    public String toString() {
        return this.nimi + ", ikä " + this.ika + " vuotta";
    }
}
</pre>
  <p>Metodi <code>toString</code> toimii kuten <code>tulostaHenkilo</code>, mutta se ei itse tulosta mitään vaan palauttaa merkkijonoesityksen, jotta metodin kutsuja voi halutessaan suorittaa tulostamisen.</p>
  <p>Metodia käytetään hieman yllättävällä tavalla:</p>
  <pre class="sh_java">
public static void main(String[] args) {
    Henkilo pekka = new Henkilo("Pekka");
    Henkilo antti = new Henkilo("Antti");

    int i = 0;
    while ( i &lt; 30 ) {
        pekka.vanhene();
        i++;
    }

    antti.vanhene();

    System.out.println( antti ); // sama kun System.out.println( antti.toString() );
    System.out.println( pekka ); // sama kun System.out.println( pekka.toString() );
}
</pre>
  <p>Periaatteena on, että <code>System.out.println</code>-metodi pyytää olion merkkijonoesityksen ja tulostaa sen. Merkkijonoesityksen palauttavan <code>toString</code>-metodin kutsua ei tarvitse kirjoittaa itse, sillä Java lisää sen automaattisesti. Ohjelmoijan kirjoittaessa:</p>
<pre class="sh_java">
System.out.println( antti );
</pre>
  <p>Java täydentää suorituksen aikana kutsun muotoon:</p>
<pre class="sh_java">
System.out.println( antti.toString() );
</pre>
  <p>Käy niin, että oliolta pyydetään sen merkkijonoesitys. Olion palauttama merkkijonoesitys tulostetaan normaaliin tapaan <code>System.out.println</code>-komennolla. </p>
  <p><b>Voimme nyt poistaa turhaksi käyneen <code>tulostaOlio</code>-metodin.</b></p>
  <p>Olioscreencastin toinen osa: </p>
  <a href="http://www.youtube.com/watch?feature=player_embedded&v=d-56AxspStE" height="300" target="_blank"><img src=" https://www.cs.helsinki.fi/group/java/k13/ohpe/img/youtube.jpg"/></a>

  <!--
<p><iframe allowfullscreen="" frameborder="0" height="450" width="700" src="http://www.youtube.com/embed/eX7XXP5GHTk"></iframe></p>
-->

  <div class="tehtavat">
    <div class="tehtava">
    <h3>Lyyra-kortti</h3>
    <p>Helsingin Yliopiston opiskelijaruokaloissa eli Unicafeissa opiskelijat maksavat lounaansa käyttäen <a href="http://www.lyyra.fi" target="_blank">Lyyra-korttia</a>.</p>
    <p>Tässä tehtäväsäsarjassa tehdään luokka <code>LyyraKortti</code>, jonka tarkoituksena on jäljitellä Lyyra-kortin käyttämistä Unicafessa.</p>
    <h4 class="req">Luokan runko</h4>
    <p>Projektiin tulee kuulumaan kaksi kooditiedostoa:</p>
    <p>Tehtäväpohjan eli projektin <em>Viikko4_077.Lyyrakortti</em> mukana tulee kooditiedosto <code>Paaohjelma</code> jonka sisällä on <code>main</code>-metodi.</p>
    <p>Lisää projektiin uusi luokka nimeltä <code>LyyraKortti</code>. Uuden luokan saa lisättyä seuraavasti: Ruudun vasemmalla reunalla on projektilistaus. Paina projektin nimen <em>Viikko4_077.Lyyrakortti</em> kohdalla hiiren oikeaa nappia. Valitse avautuvasta valikosta <em>New</em> ja <em>Java Class</em>. Anna luokan nimeksi (Class Name) <code>LyyraKortti</code>. </p>
    <p>Tee ensin <code>LyyraKortti</code>-olion konstruktori, jolle annetaan kortin alkusaldo ja joka tallentaa sen olion sisäiseen muuttujaan. Tee sitten <code>toString</code>-metodi, joka palauttaa kortin saldon muodossa "Kortilla on rahaa X euroa".</p>
    <p>Seuraavassa on luokan <code>LyyraKortti</code> runko:</p>
    <pre class="sh_java">
public class LyyraKortti {
    private double saldo;

    public LyyraKortti(double alkusaldo) {
        // kirjoita koodia tähän
    }

    public String toString() {
        // kirjoita koodia tähän
    }
}
</pre>
    <p>Seuraava pääohjelma testaa luokkaa:</p>
    <pre class="sh_java">
public class Paaohjelma {
    public static void main(String[] args) {
        LyyraKortti kortti = new LyyraKortti(50);
        System.out.println(kortti);
    }
}
</pre>
    <p>Ohjelman tulisi tuottaa seuraava tulostus:</p>
    <pre>
Kortilla on rahaa 50.0 euroa
</pre>
    <h4 class="req">Kortilla maksaminen</h4>
    <p>Täydennä <code>LyyraKortti</code>-luokkaa seuraavilla metodeilla:</p>
    <pre class="sh_java">
public void syoEdullisesti() {
    // kirjoita koodia tähän
}

public void syoMaukkaasti() {
      // kirjoita koodia tähän
}
</pre>
    <p>Metodin <code>syoEdullisesti</code> tulisi vähentää kortin saldoa 2.50 eurolla ja metodin <code>syoMaukkaasti</code> tulisi vähentää kortin saldoa 4.00 eurolla.</p>
    <p>Seuraava pääohjelma testaa luokkaa:</p>
    <pre class="sh_java">
public class Paaohjelma {
    public static void main(String[] args) {
        LyyraKortti kortti = new LyyraKortti(50);
        System.out.println(kortti);

        kortti.syoEdullisesti();
        System.out.println(kortti);

        kortti.syoMaukkaasti();
        kortti.syoEdullisesti();
        System.out.println(kortti);
    }
}
</pre>
    <p>Ohjelman tulisi tuottaa seuraava tulostus:</p>
    <pre>
Kortilla on rahaa 50.0 euroa
Kortilla on rahaa 47.5 euroa
Kortilla on rahaa 41.0 euroa
</pre>
    <h4 class="req">Ei-negatiivinen saldo</h4>
    <p>Mitä tapahtuu, jos kortilta loppuu raha kesken? Ei ole järkevää, että saldo muuttuu negatiiviseksi. Muuta metodeita <code>syoEdullisesti</code> ja <code>syoMaukkaasti</code> niin, että ne eivät vähennä saldoa, jos saldo menisi negatiiviseksi.</p>
    <p>Seuraava pääohjelma testaa luokkaa:</p>
    <pre class="sh_java">
public class Paaohjelma {
    public static void main(String[] args) {
        LyyraKortti kortti = new LyyraKortti(5);
        System.out.println(kortti);

        kortti.syoMaukkaasti();
        System.out.println(kortti);

        kortti.syoMaukkaasti();
        System.out.println(kortti);
    }
}
</pre>
    <p>Ohjelman tulisi tuottaa seuraava tulostus:</p>
<pre>
Kortilla on rahaa 5.0 euroa
Kortilla on rahaa 1.0 euroa
Kortilla on rahaa 1.0 euroa
</pre>
    <p>Yllä toinen metodin <code>syoMaukkaasti</code> kutsu ei vaikuttanut saldoon, koska saldo olisi mennyt negatiiviseksi.</p>
    <h4 class="req">Kortin lataaminen</h4>
    <p>Lisää <code>LyyraKortti</code>-luokkaan seuraava metodi:</p>
    <pre class="sh_java">
public void lataaRahaa(double rahamaara) {
    // kirjoita koodia tähän
}
</pre>
    <p>Metodin tarkoituksena on kasvattaa kortin saldoa parametrina annetulla rahamäärällä. Kuitenkin kortin saldo saa olla korkeintaan 150 euroa, joten jos ladattava rahamäärä ylittäisi sen, saldoksi tulisi tulla silti tasan 150 euroa.</p>
    <p>Seuraava pääohjelma testaa luokkaa:</p>
    <pre class="sh_java">
public class Paaohjelma {
    public static void main(String[] args) {
        LyyraKortti kortti = new LyyraKortti(10);
        System.out.println(kortti);

        kortti.lataaRahaa(15);
        System.out.println(kortti);

        kortti.lataaRahaa(10);
        System.out.println(kortti);

        kortti.lataaRahaa(200);
        System.out.println(kortti);
    }
}
</pre>
    <p>Ohjelman tulisi tuottaa seuraava tulostus:</p>
<pre>
Kortilla on rahaa 10.0 euroa
Kortilla on rahaa 25.0 euroa
Kortilla on rahaa 35.0 euroa
Kortilla on rahaa 150.0 euroa
</pre>
    <h4 class="req">Kortin lataus negatiivisella arvolla</h4>
    <p>Muuta metodia <code>lataaRahaa</code> vielä siten, että jos yritetään ladata negatiivinen rahamäärä, ei kortilla oleva arvo muutu.</p>
    <p>Seuraava pääohjelma testaa luokkaa:</p>
    <pre class="sh_java">
public class Paaohjelma {
    public static void main(String[] args) {
        LyyraKortti kortti = new LyyraKortti(10);
        System.out.println(kortti);
        kortti.lataaRahaa(-15);
        System.out.println(kortti);
    }
}
</pre>
    <p>Ohjelman tulisi tuottaa seuraava tulostus:</p>
<pre>
Kortilla on rahaa 10.0 euroa
Kortilla on rahaa 10.0 euroa
</pre>
    <h4 class="req">Monta korttia</h4>
    <p>Tee pääohjelma, joka sisältää seuraavan tapahtumasarjan:</p>
    <ul>
      <li> Luo Pekan lyyrakortti. Kortin alkusaldo on 20 euroa</li>
      <li> Luo Matin lyyrakortti. Kortin alkusaldo on 30 euroa</li>
      <li> Pekka syö maukkaasti</li>
      <li> Matti syö edullisesti</li>
      <li> Korttien arvot tulostetaan (molemmat omalle rivilleen, rivin alkuun kortin omistajan nimi)</li>
      <li> Pekka lataa rahaa 20 euroa</li>
      <li> Matti syö maukkaasti</li>
      <li> Korttien arvot tulostetaan (molemmat omalle rivilleen, rivin alkuun kortin omistajan nimi)</li>
      <li> Pekka syö edullisesti</li>
      <li> Pekka syö edullisesti</li>
      <li> Matti lataa rahaa 50 euroa</li>
      <li> Korttien arvot tulostetaan (molemmat omalle rivilleen, rivin alkuun kortin omistajan nimi)</li>
    </ul>
    <p>Pääohjelman runko on seuraava:</p>
    <pre class="sh_java">
public class Main {
    public static void main(String[] args) {
        LyyraKortti pekanKortti = new LyyraKortti(20);
        LyyraKortti matinKortti = new LyyraKortti(30);

        // kirjoita koodia tähän
    }
}
</pre>
    <p>Ohjelman tulisi tuottaa seuraava tulostus:</p>
<pre>
Pekka: Kortilla on rahaa 16.0 euroa
Matti: Kortilla on rahaa 27.5 euroa
Pekka: Kortilla on rahaa 36.0 euroa
Matti: Kortilla on rahaa 23.5 euroa
Pekka: Kortilla on rahaa 31.0 euroa
Matti: Kortilla on rahaa 73.5 euroa
</pre>
  </div>
</div>
  <h3>Lisää metodeja</h3>
  <p>Jatketaan taas <code>Henkilo</code>-luokan parissa. Päätetään että haluamme laskea henkilöiden painoindeksejä. Tätä varten teemme henkilölle metodit pituuden ja painon asettamista varten, sekä metodin joka laskee painoindeksin. Henkilön uudet ja muuttuneet osat seuraavassa:</p>
  <pre class="sh_java">
public class Henkilo {
    private String nimi;
    private int ika;
    private int paino;
    private int pituus;

    public Henkilo(String nimiAlussa) {
        this.ika = 0;
        this.paino = 0;
        this.pituus = 0;
        this.nimi = nimiAlussa;
    }

    public void setPituus(int uusiPituus) {
        this.pituus = uusiPituus;
    }

    public void setPaino(int uusiPaino) {
        this.paino = uusiPaino;
    }

    public double painoIndeksi(){
        double pituusPerSata = this.pituus / 100.0;
        return this.paino / ( pituusPerSata * pituusPerSata );
    }

    // ...
}
</pre>
  <p>Eli henkilölle lisättiin oliomuuttujat <code>pituus</code> ja <code>paino</code>. Näille voi asettaa arvon metodeilla <code>setPituus</code> ja <code>setPaino</code>. Jälleen käytössä Javaan vakiintunut nimeämiskäytäntö, eli jos metodin tehtävänä on ainoastaan asettaa arvo oliomuuttujaan, on metodi tapana nimetä <code>setMuuttujanNimi</code>:ksi. Arvon asettavia metodeja kutsutaan usein "settereiksi". Seuraavassa käytämme uusia metodeja:</p>
  <pre class="sh_java">
public static void main(String[] args) {
    Henkilo matti = new Henkilo("Matti");
    Henkilo juhana = new Henkilo("Juhana");

    matti.setPituus(180);
    matti.setPaino(86);

    juhana.setPituus(175);
    juhana.setPaino(64);

    System.out.println( matti.getNimi() + ", painoindeksisi on " + matti.painoIndeksi() );
    System.out.println( juhana.getNimi() + ", painoindeksisi on " + juhana.painoIndeksi() );
}
</pre>
<p>Tulostus:</p>
<pre>
Matti, painoindeksisi on 26.54320987654321
Juhana, painoindeksisi on 20.897959183673468
</pre>
  <h3>Parametrilla ja oliomuuttujalla sama nimi!</h3>
  <p>Edellä metodissa <code>setPituus</code> asetetaan oliomuuttujaan <code>pituus</code> parametrin <code>uusiPituus</code> arvo:</p>
  <pre class="sh_java">
public void setPituus(int uusiPituus) {
    this.pituus = uusiPituus;
}
</pre>
  <p>Parametrin nimi voisi olla myös sama kuin oliomuuttujan nimi, eli seuraava toimisi myös:</p>
  <pre class="sh_java">
public void setPituus(int pituus) {
    this.pituus = pituus;
}
</pre>
  <p>Nyt metodissa <code>pituus</code> tarkottaa nimenomaan <em>pituus</em>-nimistä parametria ja <code>this.pituus</code> saman nimistä oliomuuttujaa. Esim. seuraava ei toimisi sillä koodi ei viittaa ollenkaan oliomuuttujaan <em>pituus</em>:</p>
  <pre class="sh_java">
public void setPituus(int pituus) {
    // EI TOIMI ÄLÄ TEE NÄIN!!!
    pituus = pituus;
}
</pre>
  <h3>Liukuluvun "siisti" tulostaminen</h3>
  <p>Desimaalien määrä edellisessä tulostuksessa on hieman liioiteltu. Yksi tapa päästä määräämään tulostettavien desimaalien määrä on seuraava:</p>
  <pre class="sh_java">
System.out.println( matti.getNimi() + ", painoindeksisi on " + String.format( "%.2f", matti.painoIndeksi() ) );
System.out.println( juhana.getNimi() + ", painoindeksisi on " + String.format( "%.2f", juhana.painoIndeksi() ) );
</pre>
  <p>Eli jos <code>luku</code> on liukuluku, voi siitä tehdä komennolla <code>String.format( "%.2f", luku )</code> merkkijonon, jossa luku on otettu mukaan kahden desimaalin tarkkuudella. Pisteen ja f:n välissä oleva numero säätää mukaan tulevan desimaalien määrän. </p>
  <p>Nyt tulostus on siistimpi:</p>
<pre>
Matti, painoindeksisi on 26,54
Juhana, painoindeksisi on 20,90
</pre>
  <p><code>String.format</code> ei ehkä ole kaikkein monikäyttöisin tapa Javassa tulostuksen muotoiluun. Se kuitenkin lienee yksinkertaisin ja kelpaa meille hyvin nyt.</p>
  <div class="tehtavat">
    <div class="tehtava">
    <h3>Kello laskurin avulla</h3>
    <p>Tässä tehtävässä tehdään luokka <code>YlhaaltaRajoitettuLaskuri</code> ja sovelletaan sitä kellon tekemiseen.</p>
    <h4 class="req">Rajoitettu laskuri</h4>
    <p>Tehdään luokka <code>YlhaaltaRajoitettuLaskuri</code>. Luokan olioilla on seuraava toiminnallisuus:</p>
    <ul>
      <li> Laskurilla on oliomuuttuja, joka muistaa laskurin arvon.
        Laskurin arvo on luku väliltä 0...yläraja.</li>
      <li> Aluksi laskurin arvo on 0.</li>
      <li> Olion konstruktori määrittää laskurin ylärajan.</li>
      <li> Metodi <code>seuraava</code> kasvattaa laskurin arvoa.
        Mutta jos laskurin arvo ylittää ylärajan, sen arvoksi tulee 0.</li>
      <li> Metodi <code>toString</code> palauttaa laskurin arvon merkkijonona.</li>
    </ul>
    <p>Tehtäväpohjassa on valmiina pääohjelmaa varten tiedosto <code>Paaohjelma</code>. Aloita tekemällä luokka <code>YlhaaltaRajoitettuLaskuri</code> vastaavasti kuin LyyraKortti-tehtävässä. Näin tehdään myös tulevissa tehtäväsarjoissa.</p>
    <p>Luokan rungoksi tulee seuraava:</p>
    <pre class="sh_java">
public class YlhaaltaRajoitettuLaskuri {
    private int arvo;
    private int ylaraja;

    public YlhaaltaRajoitettuLaskuri(int ylarajanAlkuarvo) {
        // kirjoita koodia tähän
    }

    public void seuraava() {
        // kirjoita koodia tähän
    }

    public String toString() {
        // kirjoita koodia tähän
    }
}
</pre>
    <p><b>Vihje</b>: et voi palauttaa toStringissä suoraan kokonaislukutyyppisen oliomuuttujan <code>laskuri</code> arvoa. Kokonaislukumuuttujasta <code>arvo</code> saa merkkijonomuodon esim. lisäämällä sen eteen tyhjän merkkijonon eli kirjoittamalla <code>"" + arvo</code>.</p>
    <p>Seuraavassa on pääohjelma, joka käyttää laskuria:</p>
    <pre class="sh_java">
public class Paaohjelma {
    public static void main(String[] args) {
        YlhaaltaRajoitettuLaskuri laskuri = new YlhaaltaRajoitettuLaskuri(4);
        System.out.println("arvo alussa: " + laskuri );

        int i = 0;
        while ( i &lt; 10) {
            laskuri.seuraava();
            System.out.println("arvo: " + laskuri );
            i++;
        }
    }
}
</pre>
    <p>Laskurille asetetaan konstruktorissa ylärajaksi 4, joten laskurin arvo on luku 0:n ja 4:n väliltä. Huomaa, miten metodi <code>seuraava</code> vie laskurin arvoa eteenpäin, kunnes se pyörähtää 4:n jälkeen 0:aan:</p>
    <p>Ohjelman tulostuksen tulisi olla seuraava:</p>
    <pre>
arvo alussa: 0
arvo: 1
arvo: 2
arvo: 3
arvo: 4
arvo: 0
arvo: 1
arvo: 2
arvo: 3
arvo: 4
arvo: 0
</pre>
    <h4 class="req">Etunolla tulostukseen</h4>
    <p>Tee <code>toString</code>-metodista sellainen, että se lisää arvon merkkijonoesitykseen etunollan, jos laskurin arvo on vähemmän kuin 10. Eli jos laskurin arvo on esim. 3, palautetaan merkkijono "03", jos arvo taas on esim. 12, palautetaan normaaliin tapaan merkkijono "12".</p>
    <p>Muuta pääohjelma seuraavaan muotoon ja varmista, että tulos on haluttu.</p>
    <pre class="sh_java">
public class Paaohjelma {
    public static void main(String[] args) {
        YlhaaltaRajoitettuLaskuri laskuri = new YlhaaltaRajoitettuLaskuri(14);
        System.out.println("arvo alussa: " + laskuri );

        int i = 0;
        while ( i &lt; 16){
            laskuri.seuraava();
            System.out.println("arvo: " + laskuri );
            i++;
        }
    }
}
</pre>
<pre>
arvo alussa: 00
arvo: 01
arvo: 02
arvo: 03
arvo: 04
arvo: 05
arvo: 06
arvo: 07
arvo: 08
arvo: 09
arvo: 10
arvo: 11
arvo: 12
arvo: 13
arvo: 14
arvo: 00
arvo: 01
</pre>
    <h4 class="req">Kello, ensimmäinen versio</h4>
    <p>Käyttämällä kahta laskuria voimme muodostaa kellon. Tuntimäärä on laskuri, jonka yläraja on 23, ja minuuttimäärä on laskuri jonka yläraja on 59. Kuten kaikki tietävät, kello toimii siten, että aina kun minuuttimäärä pyörähtää nollaan, tuntimäärä kasvaa yhdellä. </p>
    <p>Tee ensin laskurille metodi <code>arvo</code>, joka palauttaa laskurin arvon:</p>
    <pre class="sh_java">
public int arvo() {
    // kirjoita koodia tähän
}
</pre>
    <p>Tee sitten kello täydentämällä seuraava pääohjelmarunko (kopioi tämä pääohjelmaksesi sekä täydennä tarvittavilta osin kommenttien ohjaamalla tavalla):</p>
    <pre class="sh_java">
public class Paaohjelma {
    public static void main(String[] args) {
        YlhaaltaRajoitettuLaskuri minuutit = new YlhaaltaRajoitettuLaskuri(59);
        YlhaaltaRajoitettuLaskuri tunnit = new YlhaaltaRajoitettuLaskuri(23);

        int i = 0;
        while ( i &lt; 121 ) {
            System.out.println( tunnit + ":" + minuutit);   // tulostetaan nykyinen aika
            // minuuttimäärä kasvaa
            // jos minuuttimäärä menee nollaan, tuntimäärä kasvaa

            i++;
        }
    }
}
</pre>
    <p>Jos kellosi toimii oikein, sen tulostus näyttää suunnilleen seuraavalta:</p>
<pre>
00:00
00:01
...
00:59
01:00
01:01
01:02
...
01:59
02:00
</pre>
    <h4>Kello, toinen versio</h4>
    <p>Laajenna kelloasi myös sekuntiviisarilla. Tee lisäksi luokalle <code>YlhaaltaRajoitettuLaskuri</code> metodi <code>asetaArvo</code>, jolla laskurille pystyy asettamaan halutun arvon. Jos laskurille yritetään asettaa kelvoton arvo eli negatiivinen luku tai ylärajaa suurempi luku, ei laskurin arvo muutu.</p>
    <p>Tämän metodin avulla voit muuttaa kellon ajan heti ohjelman alussa haluamaksesi.</p>
    <p>Voit testata kellon toimintaa seuraavalla ohjelmalla</p>
    <pre class="sh_java">
import java.util.Scanner;

public class Paaohjelma {
    public static void main(String[] args)  {
        Scanner lukija = new Scanner(System.in);
        YlhaaltaRajoitettuLaskuri sekunnit = new YlhaaltaRajoitettuLaskuri(59);
        YlhaaltaRajoitettuLaskuri minuutit = new YlhaaltaRajoitettuLaskuri(59);
        YlhaaltaRajoitettuLaskuri tunnit = new YlhaaltaRajoitettuLaskuri(23);

        System.out.print("sekunnit: ");
        int sek = // kysy sekuntien alkuarvo käyttäjältä
        System.out.print("minuutit: ");
        int min = // kysy minuuttien alkuarvo käyttäjältä
        System.out.print("tunnit: ");
        int tun = // kysy tuntien alkuarvo käyttäjältä

        sekunnit.asetaArvo(sek);
        minuutit.asetaArvo(min);
        tunnit.asetaArvo(tun);

        int i = 0;
        while ( i &lt; 121 ) {
            // lisää edelliseen myös sekuntiviisari
            i++;
        }

    }
}
</pre>
    <p>Kokeile laittaa kellosi alkamaan ajasta <i>23:59:50</i> ja varmista, että vuorokauden vaihteessa kello toimii odotetusti!</p>
    <p><strong>Bonus-tehtävä: ikuisesti käyvä kello (tehtävää ei palauteta!)</strong></p>
    <p>Ennen kuin alat tekemään tätä tehtävää, palauta jo tekemäsi kello!</p>
    <p>Muuta pääohjelmasi seuraavaan muotoon:</p>
  <pre class="sh_java">
public class Paaohjelma {
    public static void main(String[] args) throws Exception {
        YlhaaltaRajoitettuLaskuri sekunnit = new YlhaaltaRajoitettuLaskuri(59);
        YlhaaltaRajoitettuLaskuri minuutit = new YlhaaltaRajoitettuLaskuri(59);
        YlhaaltaRajoitettuLaskuri tunnit = new YlhaaltaRajoitettuLaskuri(23);

        sekunnit.asetaArvo(50);
        minuutit.asetaArvo(59);
        tunnit.asetaArvo(23);

        while ( true ) {
            System.out.println( tunnit + ":" + minuutit + ":" + sekunnit );
            Thread.sleep(1000);
            // lisää kellon aikaa sekunnilla eteenpäin
        }
    }
}
</pre>
    <p>Nyt kello käy ikuisesti ja kasvattaa arvoaan sekunnin välein. Sekunnin odotus tapahtuu komennolla <code>Thread.sleep(1000);</code>, komennon parametri kertoo nukuttavan ajan millisekunteina. Jotta komento toimisi, pitää main:in esittelyriville tehdä pieni lisäys: <code>public static void main(String[] args) <b>throws Exception</b> {</code>, eli tummennettuna oleva <code>throws Exception</code>.</p>
    <p>Saat ohjelman lopetettua painamalla NetBeans-konsolin (eli sen osan johon kello tulostaa arvonsa) vasemmalla laidalla olevasta punaisesta laatikosta.</p>
  </div>
</div>
  <p><big><b>Tärkeitä kommentteja liittyen olioiden käyttöön. Lue nämä ehdottomasti.</b></big></p>
  <p>Olio-ohjelmoinnissa on kyse pitkälti käsitteiden eristämisestä omiksi kokonaisuuksikseen tai toisin ajatellen abstraktioiden muodostamisesta. Voisi ajatella, että on turha luoda oliota jonka sisällä on ainoastaan luku, eli että saman voisi tehdä suoraan <code>int</code>-muuttujilla. Asia ei kuitenkaan ole näin. Jos kello koostuu pelkästään kolmesta int-muuttujasta joita kasvatellaan, muuttuu ohjelma lukijan kannalta epäselvemmäksi, koodista on vaikea "nähdä" mistä on kysymys. Aiemmin materiaalissa mainitsimme jo kokeneen ja kuuluisan ohjelmoijan Kent Beckin neuvon <em>"Any fool can write code that a computer can understand.  Good programmers write code that humans can understand"</em>, eli koska viisari on oikeastaan oma selkeä käsitteensä, on siitä ohjelman ymmärrettävyyden parantamiseksi hyvä tehdä oma luokka, eli <code>YlhaaltaRajoitettuLaskuri</code>.</p>
  <p>Käsitteen erottaminen omaksi luokaksi on monellakin tapaa hyvä idea. Ensinnäkin tiettyjä yksityiskohtia (esim. laskurin pyörähtäminen) saadaan piilotettua luokan sisään (eli <em>abstrahoitua</em>). Sen sijaan että kirjoitetaan if-lause ja sijoitusoperaatio, riittää, että laskurin käyttäjä kutsuu selkeästi nimettyä metodia <code>seuraava()</code>. Aikaansaatu laskuri sopii kellon lisäksi ehkä muidenkin ohjelmien rakennuspalikaksi, eli selkeästä käsitteestä tehty luokka voi olla monikäyttöinen. Suuri etu saavutetaan myös sillä, että koska laskurin toteutuksen yksityiskohdat eivät näy laskurin käyttäjille, voidaan yksityiskohtia tarvittaessa muuttaa.</p>
  <p>Totesimme että kello sisältää kolme viisaria, eli koostuu kolmesta käsitteestä. Oikeastaan kello on itsekin käsite ja teemme ensi viikolla luokan Kello, jotta voimme luoda selkeitä Kello-olioita. Kello tulee siis olemaan olio jonka toiminta perustuu "yksinkertaisimpiin" olioihin eli viisareihin. Tämä on juuri olio-ohjelmoinnin suuri idea: ohjelma rakennetaan pienistä selkeistä yhteistoiminnassa olevista olioista. </p>
  <p>Nyt otamme varovaisia ensiaskelia oliomaailmassa. Kurssin lopussa oliot alkavat kuitenkin olla jo selkärangassa ja nyt ehkä käsittämättömältä tuntuva lausahdus, <em>ohjelma rakennetaan pienistä selkeistä yhteistoiminnassa olevista olioista</em> alkaa tuntua meistä ehkä järkeenkäyvältä ja itsestäänselvältä.</p>
  <h3>Oman metodin kutsu</h3>
  <p>Olio voi kutsua myös omia metodeitaan. Jos esim. halutaan, että toString-metodin palauttama merkkijonoesitys kertoisi myös henkilön painoindeksin, kannattaa <code>toString</code>:istä kutsua olion omaa metodia <code>painoIndeksi</code>:</p>
  <pre class="sh_java">
public String toString() {
    return this.nimi + ", ikä " + this.ika + " vuotta, painoindeksini on " + this.painoIndeksi();
}
</pre>
  <p>Eli kun olio kutsuu omaa metodiaan, riittää etuliite this ja pelkkä metodin nimi. Vaihtoehtoinen tapa on tehdä oman metodin kutsu muodossa <code>painoIndeksi()</code> jolloin ei korosteta, että kutsutaan "olion itsensä" metodia painoindeksi:</p>
  <pre class="sh_java">
public String toString() {
    return this.nimi + ", ikä " + this.ika + " vuotta, painoindeksini on " + painoIndeksi();
}
</pre>
  <p>Olioscreencastin kolmas osa:</p>
  <a href="http://www.youtube.com/watch?feature=player_embedded&v=YKwzIGuCLn8" height="300" target="_blank"><img src=" https://www.cs.helsinki.fi/group/java/k13/ohpe/img/youtube.jpg"/></a>

  <!--
<p><iframe allowfullscreen="" frameborder="0" height="450" width="700" src="http://www.youtube.com/embed/owhvYkDTX2g"></iframe></p>
-->

  <p>Nyt on aika harjoitella lisää yksinkertaisten olioiden tekemistä käytännössä:</p>
  <div class="tehtavat">
    <div class="tehtava">
    <h3>Lukutilasto</h3>
    <h4 class="req">Lukujen määrä</h4>
    <p>Tee luokka <code>Lukutilasto</code> (tiedosto luomaasi luokkaa varten on tehtäväpohjassa valmiina), joka tuntee seuraavat toiminnot :</p>
    <ul>
      <li> metodi <code>lisaaLuku</code> lisää uuden luvun tilastoon
      <li> metodi <code>haeLukujenMaara</code> kertoo lisättyjen lukujen määrän
    </ul>
    <p>Luokan ei tarvitse tallentaa mihinkään lisättyjä lukuja, vaan riittää muistaa niiden määrä. Metodin <code>lisaaLuku</code> ei tässä vaiheessa tarvitse edes ottaa huomioon, mikä luku lisätään tilastoon, koska ainoa tallennettava asia on lukujen määrä.</p>
    <p>Luokan runko on seuraava:</p>
    <pre class="sh_java">
public class Lukutilasto {
    private int lukujenMaara;

    public Lukutilasto() {
        // alusta tässä muuttuja lukujenMaara
    }

    public void lisaaLuku(int luku) {
        // kirjoita koodia tähän
    }

    public int haeLukujenMaara() {
        // kirjoita koodia tähän
    }
}
</pre>
    <p>Seuraava ohjelma esittelee luokan käyttöä:</p>
    <pre class="sh_java">
public class Paaohjelma {
    public static void main(String[] args) {
        Lukutilasto tilasto = new Lukutilasto();
        tilasto.lisaaLuku(3);
        tilasto.lisaaLuku(5);
        tilasto.lisaaLuku(1);
        tilasto.lisaaLuku(2);
        System.out.println("Määrä: " + tilasto.haeLukujenMaara());
    }
}
</pre>
    <p>Ohjelman tulostus on seuraava:</p>
<pre>
Määrä: 4
</pre>
    <h4 class="req">Summa ja keskiarvo</h4>
    <p>Laajenna luokkaa seuraavilla toiminnoilla:</p>
    <ul>
      <li> metodi <code>summa</code> kertoo lisättyjen lukujen summan (tyhjän lukutilaston summa on 0)
      <li> metodi <code>keskiarvo</code> kertoo lisättyjen lukujen keskiarvon (tyhjän lukutilaston keskiarvo on 0)
    </ul>
    <p>Luokan runko on seuraava:</p>
    <pre class="sh_java">
public class Lukutilasto {
    private int lukujenMaara;
    private int summa;

    public Lukutilasto() {
        // alusta tässä muuttujat maara ja summa
    }

    public void lisaaLuku(int luku) {
        // kirjoita koodia tähän
    }

    public int haeLukujenMaara() {
        // kirjoita koodia tähän
    }

    public int summa() {
        // kirjoita koodia tähän
    }

    public double keskiarvo() {
        // kirjoita koodia tähän
    }
}
</pre>
    <p>Seuraava ohjelma esittelee luokan käyttöä:</p>
    <pre class="sh_java">
public class Main {
    public static void main(String[] args) {
        Lukutilasto tilasto = new Lukutilasto();
        tilasto.lisaaLuku(3);
        tilasto.lisaaLuku(5);
        tilasto.lisaaLuku(1);
        tilasto.lisaaLuku(2);
        System.out.println("Määrä: " + tilasto.haeLukujenMaara());
        System.out.println("Summa: " + tilasto.summa());
        System.out.println("Keskiarvo: " + tilasto.keskiarvo());
    }
}
</pre>
    <p>Ohjelman tulostus on seuraava:</p>
<pre>
Määrä: 4
Summa: 11
Keskiarvo: 2.75
</pre>
    <h4 class="req">Summa käyttäjältä</h4>
    <p>Tee ohjelma, joka kysyy lukuja käyttäjältä, kunnes käyttäjä antaa luvun -1. Sitten ohjelma ilmoittaa lukujen summan.</p>
    <p>Ohjelmassa tulee käyttää <code>Lukutilasto</code>-olioa summan laskemiseen.</p>

    <p><strong>HUOM: </strong> älä muuta Lukutilasto-luokaa millään tavalla!</p>

<pre>
Anna lukuja:
<font color="red">4</font>
<font color="red">2</font>
<font color="red">5</font>
<font color="red">4</font>
<font color="red">-1</font>
Summa: 15
</pre>
    <h4>Monta summaa</h4>
    <p>Muuta edellistä ohjelmaa niin, että ohjelma laskee myös parillisten ja parittomien lukujen summaa.</p>
    <p><b>HUOM</b>: Määrittele ohjelmassa <i>kolme</i> Lukutilasto-olioa ja laske ensimmäisen avulla kaikkien lukujen summa, toisen avulla parillisten lukujen summa ja kolmannen avulla parittomien lukujen summa.</p>
    <p><b>Jotta testi toimisi, on oliot luotava pääohjelmassa edellä mainitussa järjestyksessä (eli ensin kaikkien summan laskeva olio, toisena parillisten summan laskeva ja viimeisenä parittomien summan laskeva olio)!</b></p>

    <p><strong>HUOM: </strong> älä muuta Lukutilasto-luokaa millään tavalla!</p>

    <p>Ohjelman tulee toimia seuraavasti:</p>
<pre>
Anna lukuja:
<font color="red">4</font>
<font color="red">2</font>
<font color="red">5</font>
<font color="red">2</font>
<font color="red">-1</font>
Summa: 13
Parillisten summa: 8
Parittomien summa: 5
</pre>
</div>
</div>
  <h2>Satunnaisuus</h2>
  <p>Ohjelmoidessa satunnaisuutta tarvitaan silloin tällöin. Satunnaisuutta, esimerkiksi sään arvaamattomuutta tai tietokoneen tietokonepeleissä tekemien yllättäviä siirtoja, voidaan useimmiten simuloida tietokoneelta pyydettävien satunnaislukujen avulla. Satunnaislukujen pyytäminen onnistuu käyttäen Javasta löytyvää <code>Random</code>-luokkaa. Random-luokkaa voi käyttää seuraavalla tavalla.</p>
  <pre class="sh_java">
import java.util.Random;

    public class Arvontaa {
        public static void main(String[] args) {
        Random arpoja = new Random(); // luodaan arpoja apuväline
        int i = 0;

        while (i &lt; 10) {
            // Arvotaan ja tulostetaan jokaisella kierroksella satunnainen luku
            System.out.println(arpoja.nextInt(10));
            i++;
        }
    }
}
</pre>
  <p>Yllä olevassa koodissa luodaan ensin <code>Random</code>-luokan ilmentymä käyttäen avainsanaa <code>new</code> -- samoin kuin muitakin olioita luodessa. Random-olio tarjoaa metodin <code>nextInt</code>, jolle annetaan parametrina kokonaisluku. Metodi palauttaa satunnaisen kokonaisluvun väliltä <em>0..(annettu kokonaisluku - 1)</em>.</p>
  <p>Ohjelman tulostus voisi olla vaikka seuraavanlainen:</p>
<pre>
2
2
4
3
4
5
6
0
7
8
</pre>
  <p>Tarvitsemme liukulukuja esimerkiksi todennäköisyyslaskennan yhteydessä. Tietokoneella todennäköisyyksiä simuloidaan yleensä väliltä [0..1] olevilla luvuilla.  Random-oliolta saa satunnaisia liukulukuja metodilla <code>nextDouble</code>. Tarkastellaan seuraavia säämahdollisuuksia:</p>
  <ul>
    <li>Sataa räntää todennäköisyydellä 0.1 (10%)</li>
    <li>Sataa lunta todennäköisyydellä 0.3 (30%)</li>
    <li>Aurinko paistaa todennäköisyydellä 0.6 (60%)</li>
  </ul>
  <p>Luodaan edellä olevista arvioista sääennustaja.</p>
  <pre class="sh_java">
import java.util.ArrayList;
import java.util.Random;

public class SaaEnnustaja {
    private Random random;

    public SaaEnnustaja() {
        this.random = new Random();
    }

    public String ennustaSaa() {
        double todennakoisyys = this.random.nextDouble();

        if (todennakoisyys &lt;= 0.1) {
            return "Sataa räntää";
        } else if (todennakoisyys &lt;= 0.4) { // 0.1 + 0.3
            return "Sataa lunta";
        } else { // loput, 1.0 - 0.4 = 0.6
            return "Aurinko paistaa";
        }
    }

    public int ennustaLampotila() {
        return (int) ( 4 * this.random.nextGaussian() - 3 );
    }
}
</pre>
  <p>Metodi <code>ennustaLampotila</code> on monella tapaa mielenkiintoinen. Metodin sisällä tehtävä kutsu <code>this.random.nextGaussian()</code> on tavallinen metodikutsu, jonka kaltaisia olemme nähneet aikaisemminkin. Kiinnostavaa tässä <code>Random</code>-luokan ilmentymän tarjoamassa metodissa on se, että metodin palauttama luku on <em>normaalijakautunut</em> (jos et koe mielenkiintoa satunnaisuuden eri lajeihin se ei haittaa!).</p>
  <pre class="sh_java">
public int ennustaLampotila() {
    return (int) ( 4 * this.random.nextGaussian() - 3 );
}
</pre>
  <p>Edellisessä lausekkeessa kiinnostava on myös osa <code>(int)</code>. Tämä kohta lausekkeessa muuttaa suluissa olevan liukuluvun kokonaisluvuksi. Vastaavalla menetelmällä voidaan muuttaa myös kokonaislukuja liukuluvuiksi kirjoittamalla <code>(double) kokonaisluku</code>. Tätä kutsutaan <em>eksplisiittiseksi tyyppimuunnokseksi</em>.</p>
  <p>Luodaan vielä pääohjelma josta luokkaa <code>SaaEnnustaja</code> käytetään.</p>
  <pre class="sh_java">
public class Ohjelma {

    public static void main(String[] args) {
        SaaEnnustaja ennustaja = new SaaEnnustaja();

        // käytetään listaa apuvälineenä
        ArrayList&lt;String&gt; paivat = new ArrayList&lt;String&gt;();
        Collections.addAll(paivat, "Ma", "Ti", "Ke", "To", "Pe", "La", "Su");

        System.out.println("Seuraavan viikon sääennuste:");
        for(String paiva : paivat) {
            String saaEnnuste = ennustaja.ennustaSaa();
            int lampotilaEnnuste = ennustaja.ennustaLampotila();

            System.out.println(paiva + ": " + saaEnnuste + " " + lampotilaEnnuste + " astetta.");
        }
    }
}
</pre>
  <p>Ohjelman tulostus voisi olla esimerkiksi seuraavanlainen:</p>
<pre>
Seuraavan viikon sääennuste:
Ma: Sataa lunta 1 astetta.
Ti: Sataa lunta 1 astetta.
Ke: Aurinko paistaa -2 astetta.
To: Aurinko paistaa 0 astetta.
Pe: Sataa lunta -3 astetta.
La: Sataa lunta -3 astetta.
Su: Aurinko paistaa -5 astetta
</pre>
  <div id="viikko4" class="tehtavat">
    <div class="tehtava">
    <h3 class="req">Nopan heittäminen</h3>
    <p> Tehtäväpohjassa on luokka <code>Noppa</code>, jolla on seuraavat toiminnot:</p>
    <ul>
      <li> konstruktori <code>Noppa(int tahkojenMaara)</code> luo uuden noppa-olion annetulla nopan tahkojen (eri oman numeronsa sisältämien "puolien") määrällä</li>
      <li> metodi <code>heita</code> kertoo nopanheiton tuloksen (tulos riippuu tahkojen määrästä)</li>
    </ul>
    <p>Luokan runko on seuraava:</p>
    <pre class="sh_java">
import java.util.Random;

public class Noppa {
    private Random random = new Random();
    private int tahkojenMaara;

    public Noppa(int tahkojenMaara) {
      // Alusta muuttuja tahkojenMaara tässä
    }

    public int heita() {
        // arvotaan luku väliltä 1-tahkojenMaara
    }
}
</pre>
    <p>Täydennä luokkaa <code>Noppa</code> siten, että noppa palauttaa jokaisella heitolla arvotun luvun väliltä <code>1...tahkojen määrä</code>. Seuraavassa noppaa testaava pääohjelma: </p>
    <pre class="sh_java">
public class Ohjelma {
    public static void main(String[] args) {
        Noppa noppa = new Noppa(6);

        int i = 0;
        while ( i &lt; 10 ) {
            System.out.println( noppa.heita() );
            i++;
          }
    }
}
</pre>
    <p>Tulostus voisi olla esimerkiksi seuraava:</p>
<pre>
1
6
3
5
3
3
2
2
6
1
</pre>
</div>
<div class="tehtava">
    <h3>Salasanan arpoja</h3>
    <p>Tehtävänäsi on täydentää luokkaa <code>SalasananArpoja</code>, jossa on seuraavat toiminnot:</p>
    <ul>
      <li> konstruktori <code>SalasananArpoja</code> luo uuden olion, joka käyttää annettua salasanan pituutta</li>
      <li> metodi <code>luoSalasana</code> palauttaa uuden, merkeistä a-z muodostetun konstruktorin parametrin määräämän pituisen salasanan </li>
    </ul>
    <p>Luokan runko on seuraava:</p>
    <pre class="sh_java">
import java.util.Random;

public class SalasananArpoja {
    // Määrittele muuttuja tässä

    public SalasananArpoja(int pituus) {
        // Alusta muuttuja tässä
    }

    public String luoSalasana() {
        // Kirjoita tähän koodi, joka palauttaa uuden salasanan
    }
}
</pre>
    <p>Seuraavassa ohjelma joka käyttää SalasananArpoja-olioa:</p>
    <pre class="sh_java">
public class Ohjelma {
    public static void main(String[] args) {
        SalasananArpoja arpoja = new SalasananArpoja(13);
        System.out.println("Salasana: " + arpoja.luoSalasana());
        System.out.println("Salasana: " + arpoja.luoSalasana());
        System.out.println("Salasana: " + arpoja.luoSalasana());
        System.out.println("Salasana: " + arpoja.luoSalasana());
    }
}
</pre>
    <p>Ohjelman tulostus voisi näyttää seuraavalta:</p>
<pre>
Salasana: mcllsoompezvs
Salasana: urcxboisknkme
Salasana: dzaccatonjcqu
Salasana: bpqmedlbqaopq
</pre>
    <p><b>Vihje1:</b> näin muutat kokonaisluvun <tt>luku</tt> kirjaimeksi:</p>
<pre class="sh_java">
int luku = 17;
char merkki = "abcdefghijklmnopqrstuvxyz".charAt(luku);
</pre>
    <p><b>Vihje2:</b> tehtävän 78 vihjeestä lienee tässäkin tehtävässä apua.</p>
  </div>
  <div class="tehtava">
    <h3>Lottoarvonta</h3>
    <p>Tehtävänäsi on täydentää luokkaa <code>LottoRivi</code>, joka arpoo viikon lottonumerot. Lottonumerot ovat väliltä 1&ndash;39 ja niitä arvotaan 7. Lottorivi koostuu siis 7:stä eri numerosta väliltä 1&ndash;39. Luokassa on seuraavat toiminnot:</p>
    <ul>
      <li> konstruktori <code>LottoRivi</code> luo uuden LottoRivi-olion joka sisältää uudet, arvotut numerot</li>
      <li> metodi <code>numerot</code> palauttaa tämän lottorivin lottonumerot</li>
      <li> metodi <code>arvoNumerot</code> arpoo riville uudet numerot</li>
      <li> metodi <code>sisaltaaNumeron</code> kertoo onko arvotuissa numeroissa annettu numero</li>
    </ul>
    <p>Luokan runko on seuraava:</p>
    <pre class="sh_java">
import java.util.ArrayList;
import java.util.Random;

    public class LottoRivi {
    private ArrayList&lt;Integer&gt; numerot;

    public LottoRivi() {
        // Alustetaan lista numeroille
        this.numerot = new ArrayList&lt;Integer&gt;();
        // Arvo numerot heti LottoRivin luomisen yhteydessä
        this.arvoNumerot();
    }

    public ArrayList&lt;Integer&gt; numerot() {
        return this.numerot;
    }

    public void arvoNumerot() {
        // Kirjoita numeroiden arvonta tänne käyttämällä metodia sisaltaaNumeron()
    }

    public boolean sisaltaaNumeron(int numero) {
        // Testaa tässä onko numero jo arvottujen numeroiden joukossa
    }
}
</pre>
    <p>Tehtäväpohjan mukana tulee seuraava pääohjelma:</p>
    <pre class="sh_java">
import java.util.ArrayList;

    public class Ohjelma {
        public static void main(String[] args) {
        LottoRivi lottoRivi = new LottoRivi();
        ArrayList&lt;Integer&gt; lottonumerot = lottoRivi.numerot();

        System.out.println("Lottonumerot:");
        for (int numero : lottonumerot) {
            System.out.print(numero + " ");
        }
        System.out.println("");
    }
}
</pre>
    <p>Ohjelman mahdollisia tulostuksia ovat seuraavat:</p>
<pre>
Lottonumerot:
3 5 10 14 15 27 37
</pre>
<pre>
Lottonumerot:
2 9 11 18 23 32 34
</pre>
    <p><strong>Huom!</strong> Sama numero saa esiintyä lottorivissä vain kerran.</p>
  </div>
  <div class="tehtava">
    <h3>Viikon huipennus: hirsipuun logiikka</h3>
    <p>Hirsipuu-pelistä pitävä kaverisi ohjelmoi hirsipuupelin joka näyttää seuraavalta.</p>
    <p><img src=" https://www.cs.helsinki.fi/group/java/k13/ohpe/img/hirsipuu-tikkuukko.png"/></p>
    <p>Hänen koneestaan hajosi kovalevy, eikä hän ollut tehnyt <a href="http://fi.wikipedia.org/wiki/Varmuuskopiointi" target="_blank"><em>varmuuskopiota</em></a>. Hän on kuitenkin luvannut pelin lahjaksi pikkuveljelleen, ja aikataulukiireidensä takia tarvitsee apuasi pelin toteutukseen. Tässä tehtäväsarjassa toteutat kaverisi hirsipuu-pelille arvauslogiikan ja annetun sanan salaamisen.</p>
    <p>Kaverisi on luonut pelille käyttöliittymän sekä valmiin rungon sovelluksen logiikkaan. Kun lataat projektin TMC:ltä, näet käyttöliittymä- ja testiluokkien lisäksi allaolevan ohjelmarungon.</p>
    <pre class="sh_java">
public class HirsipuuLogiikka {

    private String sana;
    private String arvatutKirjaimet;
    private int virheidenLukumaara;

    public HirsipuuLogiikka(String sana) {
        this.sana = sana.toUpperCase();
        this.arvatutKirjaimet = "";
        this.virheidenLukumaara = 0;
    }

    public int virheidenLukumaara() {
        return this.virheidenLukumaara;
    }

    public String arvatutKirjaimet() {
        return this.arvatutKirjaimet;
    }

    public int virheitaHavioon() {
        return 12;
    }

    public void arvaaKirjain(String kirjain) {
        // Ohjelmoi tänne toiminnallisuus kirjaimen arvaamiseksi.

        // Arvattua kirjainta ei saa arvata uudestaan. Jos arvattava sana
        // ei sisällä kirjainta, virheiden lukumäärän tulee kasvaa.
        // Lisää arvattu kirjain arvattuihin kirjaimiin

    }

    public String salattuSana() {
        // Ohjelmoi tänne toiminnallisuus salatun sanan luomiseksi
        // ja antamiseksi.

        // Luo uusi salattu sana this.sana-merkkijonoa kirjain kirjaimelta
        // läpikäyden. Jos kirjain on arvatuissa kirjaimissa, voit lisätä sen
        // sellaisenaan. Jos ei, lisää uuteen sanaan merkki "_".

        // Muista varmistaa ettet ohjelmoi päättymätöntä toistolauseketta!

        // palauta lopuksi salattua sanaa kuvaava merkkijono.

        return "";
    }
}
</pre>
    <p>Tässä tehtävässä <em>sinun tulee lisätä toiminnallisuutta vain luokan <code>HirsipuuLogiikka</code> metodeihin <code>arvaaKirjain(String kirjain)</code> ja <code>salattuSana()</code></em>.</p>
    <p><strong>Logiikan testaaminen</strong></p>
    <p>Tehtäväpohja sisältää <em>kaksi</em> testiluokkaa. Luokka <code>Main</code> käynnistää kaverisi toteuttaman graafisen version pelistä. Luokkaa <code>Testiohjelma</code> taas voit käyttää <code>HirsipuuLogiikka</code>-luokan testaamiseen.</p>
    <h4>Kirjaimen arvaaminen</h4>
    <p>Muokkaa tässä tehtävässä vain metodin <code>arvaaKirjain(String kirjain)</code> toiminnallisuutta.</p>
    <p>Kun käyttäjä arvaa jonkin kirjaimen, kutsuu hirsipuun käyttöliittymä hirsipuulogiikan metodia <code>arvaaKirjain</code> jonka tulee tarkistaa onko arvattava kirjain jo arvattujen kirjainten (joita hirsipuulogiikka säilyttää oliomuuttujassa <code>this.arvatutKirjaimet</code>) joukossa. Jos kirjain on jo arvattujen kirjainten joukossa, metodin ei tule tehdä mitään. Jos arvattavaa kirjainta ei ole arvattu aiemmin, on tarkastettava onko se arvattavassa sanassa (jota hirsipuulogiikka säilyttää oliomuuttujassa <code>this.sana</code>). Jos ei, virheiden lukumäärää (oliomuuttuja <code>this.virheidenLukumaara</code>) pitää kasvattaa yhdellä. Arvattu kirjain pitää lopuksi lisätä osaksi arvattuja kirjaimia, jos se ei ole jo siellä.</p>
    <p>Esimerkki <code>arvaaKirjain</code>-metodin toiminnasta:</p>
    <pre class="sh_java">
HirsipuuLogiikka l = new HirsipuuLogiikka("kissa");
System.out.println("Arvataan: A, D, S, F, D");
l.arvaaKirjain("A");   // oikea
l.arvaaKirjain("D");   // väärä
l.arvaaKirjain("S");   // oikea
l.arvaaKirjain("F");   // väärä
l.arvaaKirjain("D");   // Tämän ei pitäisi kasvattaa virheiden lukumäärää koska D oli jo arvattu
System.out.println("Arvatut kirjaimet: "+l.arvatutKirjaimet());
System.out.println("Virheiden lukumäärä: "+l.virheidenLukumaara());
</pre>
<pre>
Arvataan: A, D, S, F, D
Arvatut kirjaimet: ADSF
Virheiden lukumäärä: 2
</pre>
<h4>Salatun sanan luominen</h4>
    <p>Hirsipuun käyttöliittymä näyttää käyttäjälle salatun muodon arvattavana olevasta sanasta. Yllä olevassa kuvassa salattu sana on <code>METO_I</code>, eli arvattavana olevasta sanasta näytetään vain arvatut kirjaimet, muut korvataan alaviivalla. Salatun sanan muodostaa hirsipuulogiikan metodi <code>salattuSana()</code> jonka sisältöä tässä tehtävässä on tarkoitus muokata.</p>
    <p>Salattu sana luodaan luomalla arvattavasta sanasta (<code>this.sana</code>) uusi versio. Jokainen kirjain jota ei ole vielä arvattu tulee vaihtaa merkkiin "_". Jos kirjain on jo arvattu, eli se löytyy arvatuista kirjaimista, voidaan se lisätä sellaisenaan salattuun sanaan.</p>
    <p>Avainsanoista <code>while</code>, <code>charAt</code> ja <code>contains</code> lienee tästä hyötyä. Saat muutettua yksittäisen merkin merkkijonoksi seuraavasti:</p>
    <pre class="sh_java">
  char merkki = 'a';
  String merkkijono = "" + merkki;
</pre>
    <p>Esimerkki metodin toiminnasta:</p>
    <pre class="sh_java">
HirsipuuLogiikka l = new HirsipuuLogiikka("kissa");
System.out.println("Sana on: "+l.salattuSana());

System.out.println("Arvataan: A, D, S, F, D");
l.arvaaKirjain("A");
l.arvaaKirjain("D");
l.arvaaKirjain("S");
l.arvaaKirjain("F");
l.arvaaKirjain("D");
System.out.println("Arvatut kirjaimet: "+l.arvatutKirjaimet());
System.out.println("Virheiden lukumäärä: "+l.virheidenLukumaara());
System.out.println("Sana on: "+l.salattuSana());
</pre>
<pre>
Sana on: _____
Arvataan: A, D, S, F, D
Arvatut kirjaimet: ADSF
Virheiden lukumäärä: 2
Sana on: __SSA
</pre>
    <p>Testaa lopuksi sinun ja kaverisi yhteistyössä tekemää ohjelmaa <code>Main</code>-luokan avulla! Voit muuttaa arvattavaa sanaa muuttamalla HirsipuuLogiikka-luokan konstruktorille parametrina annettavaa merkkijonoa:</p>
    <pre class="sh_java">
HirsipuuLogiikka logiikka = new HirsipuuLogiikka("parametri");
HirsipuuIkkuna peliIkkuna = new HirsipuuIkkuna(logiikka);
peliIkkuna.pelaa();
</pre>
    <p>Peliä pelataan näppäimistöltä, pelin voi lopettaa painamalla peli-ikkunan vasemmassa yläkulmassa olevaa x-merkkiä.</p>
  </div>
</div>
</div>
</section>


<section class="viikkoraja" id="5">
<div class="viikkoraja">Viikko 5</div>
<div class="viikkoraja-mooc" id="Viikko 5" deadline="avautuu kun 85 %  4. viikosta tehty" data-first-chapter-index="22" data-first-exercise-index="84" data-first-week-index="5" data-first-chapter-index-mooc="22" data-first-exercise-index-mooc="84" data-first-week-index-mooc="5" tekija="Arto Vihavainen, Matti Luukkainen">


<h2>Lisää luokista ja olioista</h2>
<h3>Useita konstruktoreja</h3>
<p>Palataan jälleen henkilöitä käsittelevän luokan pariin. Luokka <code>Henkilo</code> näyttää tällä hetkellä seuraavalta:</p>
<pre class="sh_java">
public class Henkilo {

    private String nimi;
    private int ika;
    private int pituus;
    private int paino;

    public Henkilo(String nimi) {
        this.nimi = nimi;
        this.ika = 0;
        this.paino = 0;
        this.pituus = 0;
    }

    public void tulostaHenkilo() {
        System.out.println(this.nimi + " olen " + this.ika + " vuotta vanha");
    }

    public void vanhene() {
        this.ika++;
    }

    public boolean taysiIkainen(){
        if ( this.ika &lt; 18 ) {
            return false;
        }

        return true;
    }

    public double painoindeksi(){
        double pituusMetreina = this.pituus/100.0;

        return this.paino / (pituusMetreina*pituusMetreina);
    }

    public String toString(){
        return this.nimi + " olen " + this.ika + " vuotta vanha, painoindeksini on " + this.painoindeksi();
    }

    public void setPituus(int pituus){
        this.pituus = pituus;
    }

    public int getPituus(){
        return this.pituus;
    }

    public int getPaino() {
        return this.paino;
    }

    public void setPaino(int paino) {
        this.paino = paino;
    }

    public String getNimi(){
        return this.nimi;
    }
}
</pre>
<p>Kaikki henkilöoliot ovat luontihetkellä 0-vuotiaita, sillä konstruktori asettaa uuden henkilön ika-oliomuuttujan arvoksi 0:</p>
<pre class="sh_java">
public Henkilo(String nimi) {
    this.nimi = nimi;
    this.ika = 0;
    this.paino = 0;
    this.pituus = 0;
}
</pre>
<p>Haluaisimme myös luoda henkilöitä siten, että nimen lisäksi konstruktorin parametrina annettaisiin ikä. Tämä onnistuu helposti, sillä konstruktoreja voi olla useita. Tehdään vaihtoehtoinen konstruktori. Vanhaa konstruktoria ei tarvise poistaa. </p>
<pre class="sh_java">
public Henkilo(String nimi) {
    this.nimi = nimi;
    this.ika = 0;
    this.paino = 0;
    this.pituus = 0;
}

public Henkilo(String nimi, int ika) {
    this.nimi = nimi;
    this.ika = ika;
    this.paino = 0;
    this.pituus = 0;
}
</pre>
<p>Nyt olioiden luonti onnistuu kahdella vaihtoehtoisella tavalla:</p>
<pre class="sh_java">
public static void main(String[] args) {
    Henkilo pekka = new Henkilo("Pekka", 24);
    Henkilo esko = new Henkilo("Esko");

    System.out.println( pekka );
    System.out.println( esko );
}
</pre>
<pre>
Pekka, ikä 24 vuotta
Esko, ikä 0 vuotta
</pre>
<p>Tekniikkaa jossa luokalla on kaksi konstruktoria, kutsutaan <em>konstruktorin kuormittamiseksi</em>. Luokalla voi siis olla useita konstruktoreja, jotka poikkeavat toisistaanparametriensa määrältä tai tyypeiltä. Ei kuitenkaan ole mahdollista tehdä kahta erilaista konstruktoria joilla on täysin saman tyyppiset parametrit. Emme siis voi edellisten lisäksi lisätä konstruktoria <code>public Henkilo(String nimi, int paino)</code> sillä Javan on mahdoton erottaa tätä kaksiparametrisesta konstruktorissa, jossa luku tarkoittaa ikää.</p>
<h3>Oman konstruktorin kutsuminen</h3>
<p>Mutta hetkinen, luvussa 21 todettiin että "copy-paste"-koodi ei ole hyvä idea. Kun tarkastellaan edellä tehtyjä kuormitettuja konstruktoreita, niissä on aika paljon samaa. Emme ole oikein tyytyväisiä tilanteeseen.</p>
<p>Konstruktoreista ylempi on oikeastaan alemman erikoistapaus. Entä jos ylempi konstruktori voisi "kutsua" alempaa konstruktoria? Tämä onnistuu, sillä konstruktorin sisältä voi kutsua toista konstruktoria juuri tähän olioon liittyvän <code>this</code>-ilmauksen avulla!</p>
<p>Muutetaan ylempää konstruktoria siten, että se ei itse tee mitään vaan ainoastaan kutsuu alempaa konstruktoria ja pyytää sitä asettamaan iäksi 0:</p>
<pre class="sh_java">
public Henkilo(String nimi) {
    this(nimi, 0);  // suorita tässä toisen konstruktorin koodi ja laita ika-parametrin arvoksi 0
}

public Henkilo(String nimi, int ika) {
    this.nimi = nimi;
    this.ika = ika;
    this.paino = 0;
    this.pituus = 0;
}
</pre>
<p>Oman konstruktorin kutsu <code>this(nimi, 0);</code> saattaa vaikuttaa erikoiselta. Asiaa voi vaikka ajatella siten, että kutsun kohdalle tulee "copy-pastena" automaattisesti alemman konstruktorin koodi, siten että ika parametrin arvoksi tulee 0.</p>
<h3>Metodin kuormittaminen</h3>
<p>Konstruktorien tapaan myös metodeja voi kuormittaa, eli samannimisestä metodista voi olla useita versioita. Jälleen eri versioiden parametrien tyyppien on oltava erilaiset. Tehdään <code>vanhene</code>-metodista toinen versio, joka mahdollistaa henkilön vanhentamisen parametrina olevalla vuosimäärällä:</p>
<pre class="sh_java">
public void vanhene() {
    this.ika = this.ika + 1;
}

public void vanhene(int vuodet) {
    this.ika = this.ika + vuodet;
}
</pre>
<p>Seuraavassa "Pekka" syntyy 24-vuotiaana, vanhenee ensin vuoden ja sitten 10 vuotta:</p>
<pre class="sh_java">
public static void main(String[] args) {
    Henkilo pekka = new Henkilo("Pekka", 24);

    System.out.println( pekka );
    pekka.vanhene();
    System.out.println( pekka );
    pekka.vanhene(10);
    System.out.println( pekka );
}
</pre>
<p>Tulostuu:</p>
<pre>
Pekka, ikä 24 vuotta
Pekka, ikä 25 vuotta
Pekka, ikä 35 vuotta
</pre>
<p>Henkilöllä on siis <code>vanhene</code>-nimisiä metodeja 2 kappaletta. Se kumpi metodeista valitaan suoritettavaksi, riippuu metodikutsussa käytettyjen parametrien määrästä. Metodin <code>vanhene</code> voi myös toteuttaa metodin <code>vanhene(int vuodet)</code> avulla: </p>
<pre class="sh_java">
public void vanhene() {
    this.vanhene(1);
}

public void vanhene(int vuodet) {
    this.ika = this.ika + vuodet;
}
</pre>

<!-- CAST1-->

<a href="http://www.youtube.com/watch?feature=player_embedded&v=b6YmqoQopvs" height="300" target="_blank"><img src=" https://www.cs.helsinki.fi/group/java/k13/ohpe/img/youtube.jpg"/></a>

<div class="tehtavat" id="viikko5">
  <div class="tehtava">
  <h3>Kuormitettu laskuri</h3>
  <h4>Monta konstruktoria</h4>
  <p>Toteuta luokka <code>Laskuri</code>, joka sisältää luvun, jota voi
    vähentää ja suurentaa. Laskurissa on lisäksi
    valinnainen <em>tarkistus</em> joka estää laskurin menemisen
    miinukselle. Luokalla tulee olla seuraavat konstruktorit:</p>
  <ul>
    <li><code>public Laskuri(int alkuarvo, boolean tarkistus)</code> asettaa laskurin alkuarvoksi parametrin <code>alkuarvo</code> arvon.  Tarkistus on päällä jos  parametrin <code>tarkistus</code> arvoksi annettiin <code>true</code>.</li>
    <li><code>public Laskuri(int alkuarvo)</code> asettaa laskurin alkuarvoksi parametrin <code>alkuarvo</code> arvon, tarkastus ei ole päällä.</li>
    <li><code>public Laskuri(boolean tarkistus)</code> laskurin alkuarvoksi tulee 0.  Tarkistus on päällä jos  parametrin <code>tarkistus</code> arvoksi annettiin <code>true</code>.</li>
    <li><code>public Laskuri()</code> laskurin alkuarvoksi tulee 0 ja tarkastus ei ole päällä.</li>
  </ul>
  <p>ja seuraavat metodit:</p>
  <ul>
    <li><code>public int arvo()</code> palauttaa laskurin tämänhetkisen arvon</li>
    <li><code>public void lisaa()</code> lisää laskurin arvoa yhdellä</li>
    <li><code>public void vahenna()</code> vähentää laskurin arvoa yhdellä,
      mutta ei alle nollan jos tarkistus on päällä</li>
  </ul>
  <h4>Vaihtoehtoiset metodit</h4>
  <p>Tee laskurin metodeista <code>lisaa</code> ja <code>vahenna</code> myös yksiparametriset versiot:</p>
  <ul>
    <li><code>public void lisaa(int lisays)</code> lisää laskurin arvoa parametrina annetun luvun verran. Jos parametrin arvo on negatiivinen, ei laskurin arvo muutu.</li>
    <li><code>public void vahenna(int vahennys)</code> vähentää laskurin arvoa parametrina annetun luvun verran,
      mutta ei alle nollan jos tarkistus on päällä. Jos parametrin arvo on negatiivinen, ei laskurin arvo muutu.</li>
  </ul>
</div>
</div>
<h3>Olio on langan päässä</h3>
<p>Luvussa 20 mainittiin, että <code>ArrayList</code> on "langan päässä". Myös oliot ovat langan päässä. Mitä tämä oikein tarkoittaa? Tarkastellaan seuraavaa esimerkkiä:</p>
<pre class="sh_java">
public static void main(String[] args) {
    Henkilo pekka = new Henkilo("Pekka", 24);

    System.out.println( pekka );
}
</pre>
<p>Kun suoritamme lauseen <code>Henkilo pekka = new Henkilo("Pekka", 24);</code> syntyy olio. Olioon päästään käsiksi muuttujan <code>pekka</code> avulla. Teknisesti ottaen olio ei ole muuttujan <code>pekka</code> "sisällä" (eli lokerossa pekka) vaan <code>pekka</code> viittaa syntyneeseen olioon. Toisin sanonen olio on <code>pekka</code>-nimisestä muuttujasta lähtevän "langan päässä". Kuvana asiaa voisi havainnollistaa seuraavasti: </p>
<p> <img src=" https://www.cs.helsinki.fi/group/java/k13/ohpe/img/lanka1.PNG"/> </p>
<p>Lisätään ohjelmaan <code>Henkilo</code>-tyyppinen muuttuja <code>henkilo</code> ja annetaan sille alkuarvoksi <code>pekka</code>. Mitä nyt tapahtuu?</p>
<pre class="sh_java">
public static void main(String[] args) {
    Henkilo pekka = new Henkilo("Pekka", 24);

    System.out.println( pekka );

    Henkilo henkilo = pekka;
    henkilo.vanhene(25);

    System.out.println( pekka );
}
</pre>
<p>Tulostuu:</p>
<pre>
Pekka, ikä 24 vuotta
Pekka, ikä 49 vuotta
</pre>
<p>Eli Pekka on alussa 24-vuotias, <code>henkilo</code>-muuttujaan liittyvän langan päässä olevaa Henkilö-oliota vanhennetaan 25:llä vuodella ja sen seurauksena Pekka vanhenee! Mistä on kysymys? </p>
<p>Komento <code>Henkilo henkilo = pekka;</code> saa aikaan sen, että <code>henkilo</code> rupeaa viittaamaan samaan olioon kuin mihin <code>pekka</code> viittaa. Eli ei synnykään kopiota oliosta, vaan molemmissa muuttujissa on langan päässä sama olio. Komennossa <code>Henkilo henkilo = pekka;</code> syntyy <em>kopio langasta</em>. Kuvana (Huom: kuvassa p ja h tarkottavat pääohjelman muuttujia pekka ja henkilo. Kuvien muuttujanimiä on lyhennelty myös muutamassa seuraavassa kuvassa.):</p>
<p> <img src=" https://www.cs.helsinki.fi/group/java/k13/ohpe/img/lanka2.PNG"/> </p>
<p>Esimerkissä "vieras henkilö <code>henkilo</code> ryöstää Pekan identiteetin". Seuraavassa esimerkkiä on jatkettu siten, että luodaan uusi olio ja <code>pekka</code> alkaa viittaamaan uuteen olioon:</p>
<pre class="sh_java">
public static void main(String[] args) {
    Henkilo pekka = new Henkilo("Pekka", 24);

    System.out.println( pekka );

    Henkilo henkilo = pekka;
    henkilo.vanhene(25);

    System.out.println( pekka );

    pekka = new Henkilo("Pekka Mikkola", 24);
    System.out.println( pekka );
}
</pre>
<p>Tulostuu:</p>
<pre>
Pekka, ikä 24 vuotta
Pekka, ikä 49 vuotta
Pekka Mikkola, ikä 24 vuotta
</pre>
<p>Muuttuja <code>pekka</code> viittaa siis ensin yhteen olioon, mutta rupeaa sitten viittaamaan toiseen olioon.

  Seuraavassa kuva tilanteesta viimeisen koodirivin jälkeen:</p>
<p> <img src=" https://www.cs.helsinki.fi/group/java/k13/ohpe/img/lanka3.PNG"/> </p>
<p>Jatketaan vielä esimerkkiä laittamalla <code>henkilo</code> viittaamaan "ei mihinkään", eli <code>null</code>:iin: </p>
<pre class="sh_java">
public static void main(String[] args) {
    Henkilo pekka = new Henkilo("Pekka", 24);

    System.out.println( pekka );

    Henkilo henkilo = pekka;
    henkilo.vanhene(25);

    System.out.println( pekka );

    pekka = new Henkilo("Pekka Mikkola", 24);
    System.out.println( pekka );

    henkilo = null;
    System.out.println( henkilo );
}
</pre>
<p>Viimeisen koodirivin jälkeen näyttää seuraavalta:</p>
<p> <img src=" https://www.cs.helsinki.fi/group/java/k13/ohpe/img/lanka4.PNG"/> </p>
<p>Alempaan olioon ei nyt viittaa kukaan. Oliosta on tullut "roska". Javan roskienkerääjä käy siivoamassa aika ajoin roskaksi joutuneet oliot. Jos näin ei tehtäisi, jäisivät ne kuluttamaan turhaan koneen muistia ohjelman suorituksen loppuun asti.</p>
<p>Huomaamme, että viimeisellä rivillä yritetään vielä tulostaa "ei mitään" eli <code>null</code>. Käy seuraavasti:</p>
<pre>
Pekka, ikä 24 vuotta
Pekka, ikä 49 vuotta
Pekka Mikkola, ikä 24 vuotta
null
</pre>
<p>Mitä tapahtuu jos yritämme kutsua "ei minkään" metodia, esimerkiksi metodia <code>painoIndeksi</code>:</p>
<pre class="sh_java">
public static void main(String[] args) {
    Henkilo pekka = new Henkilo("Pekka", 24);

    System.out.println( pekka );

    Henkilo henkilo = null;
    System.out.println( henkilo.painoIndeksi() );
}
</pre>
<p>Tulos:</p>
<pre>
Pekka, ikä 24 vuotta
<font color="red">Exception in thread "main" java.lang.NullPointerException
at Main.main(Main.java:20)
Java Result: 1</font>
</pre>
<p>Eli käy huonosti. Tämän on ehkä ensimmäinen kerta elämässäsi kun näet tekstin <b>NullPointerException</b>. Voimme luvata, että tulet näkemään sen vielä uudelleen. NullPointerException on poikkeustila, joka syntyy kun <code>null</code>-arvoisen olion metodeja yritetään kutsua.</p>
<h3>Metodin parametrina olio</h3>
<p>Olemme nähneet että metodien parametrina voi olla esim. <code>int, double, String</code> tai ArrayList. ArrayListit ja merkkijonot ovat olioita, joten kuten arvata saattaa, metodi voi saada
  parametriksi minkä tahansa tyyppisen olion. Demonstroidaan tätä esimerkillä.</p>
<p>Painonvartijoihin hyväksytään jäseniksi henkilöitä, joiden painoindeksi ylittää jonkun annetun rajan.
  Kaikissa painonvartijayhdistyksissä raja ei ole sama. Tehdään painonvartijayhdistystä vastaava luokka.
  Olioa luotaessa konstruktorille annetaan parametriksi pienin painoindeksi, jolla yhdistyksen jäseneksi pääsee. </p>
<pre class="sh_java">
public class PainonvartijaYhdistys {
    private double alinPainoindeksi;

    public PainonvartijaYhdistys(double indeksiRaja) {
        this.alinPainoindeksi = indeksiRaja;
    }

}
</pre>
<p>Tehdään sitten metodi, jonka avulla voidaan tarkastaa hyväksytäänkö tietty henkilö
  yhdistyksen jäseneksi, eli onko henkilön painoindeksi tarpeeksi suuri.
  Metodi palauttaa <code>true</code> jos parametrina annettu henkilö hyväksytään, <code>false</code> jos ei.</p>
<pre class="sh_java">
public class PainonvartijaYhdistys {
    // ...

    public boolean hyvaksytaanJaseneksi(Henkilo henkilo) {
        if ( henkilo.painoIndeksi() &lt; this.alinPainoindeksi ) {
            return false;
        }
        return true;
        }
}
</pre>
<p>Painonvartijayhdistys-olion metodi <code>hyvaksytaanJaseneksi</code> saa siis parametriksi <code>Henkilo</code>-olion (tarkemmin sanottuna "langan" henkilöön) ja kutsuu parametrina saamansa henkilön metodia <code>painoIndeksi</code>. </p>
<p>Seuraavassa testipääohjelma jossa painonvartijayhdistyksen metodille annetaan ensin parametriksi henkilöolio <code>matti</code> ja sen jälkeen henkilöolio <code>juhana</code>:</p>
<pre class="sh_java">
public static void main(String[] args) {
    Henkilo matti = new Henkilo("Matti");
    matti.setPaino(86);
    matti.setPituus(180);

    Henkilo juhana = new Henkilo("Juhana");
    juhana.setPaino(64);
    juhana.setPituus(172);

    PainonvartijaYhdistys kumpulanPaino = new PainonvartijaYhdistys(25);

    if ( kumpulanPaino.hyvaksytaanJaseneksi(matti) ) {
        System.out.println( matti.getNimi() + " pääsee jäseneksi");
    } else {
        System.out.println( matti.getNimi() + " ei pääse jäseneksi");
    }

    if ( kumpulanPaino.hyvaksytaanJaseneksi(juhana) ) {
        System.out.println( juhana.getNimi() + " pääsee jäseneksi");
    } else {
        System.out.println( juhana.getNimi() + " ei pääse jäseneksi");
    }
}
</pre>
<p> Ohjelma tulostaa: </p>
<pre>
Matti pääsee jäseneksi
Juhana ei pääse jäseneksi
</pre>
<div class="help"> <p><big><b>Muutama NetBeans-vihje</b></big></p>
  <ul>
    <li> Kaikki NetBeans-vihjeet löytyvät <a href="netbeans.html">täältä</a> </li>
    <li> <b>Konstruktorien, getterien ja setterien automaattinen generointi</b>
      <p> Mene luokan koodilohkon sisäpuolelle mutta kaikkien metodien ulkopuolelle ja paina yhtä aikaa ctrl ja välilyönti. Jos luokallasi on esim. oliomuuttuja <code>saldo</code>, tarjoaa NetBeans mahdollisuuden generoida oliomuuttujalle getteri- ja setterimetodit sekä konstruktorin joka asettaa oliomuuttujalle alkuarvon. <b>HUOM:</b> laitoksen koneilla tämä saadaan aikaan painamalla yhtä aikaa ctrl, alt ja välilyönti. </p>
    </li>
  </ul>
</div>

<!-- CAST2 -->

<a href="http://www.youtube.com/watch?feature=player_embedded&v=aSFT6UnyvE0" height="300" target="_blank"><img src=" https://www.cs.helsinki.fi/group/java/k13/ohpe/img/youtube.jpg"/></a>


<div class="tehtavat">
  <div class="tehtava">
  <h3>Kasvatuslaitos</h3>
  <p>Tehtäväpohjassasi on valmiina jo tutuksi tullut luokka <code>Henkilo</code> sekä runko luokalle <code>Kasvatuslaitos</code>. Kasvatuslaitosoliot käsittelevät ihmisiä eri tavalla, esim. punnitsevat ja syöttävät ihmisiä. Rakennamme tässä tehtävässä kasvatuslaitoksen. Luokan Henkilö koodiin ei tehtävässä ole tarkoitus koskea!</p>
  <h4>Henkilöiden punnitseminen</h4>
  <p>Kasvatuslaitoksen luokkarungossa on valmiina runko metodille <code>punnitse</code>:</p>
  <pre class="sh_java">
public class Kasvatuslaitos {

    public int punnitse(Henkilo henkilo) {
        // palautetaan parametrina annetun henkilön paino
        return -1;
    }
}
</pre>
  <p>Metodi saa parametrina henkilön ja metodin on tarkoitus palauttaa kutsujalleen parametrina olevan henkilön paino. Paino selviää kutsumalla parametrina olevan henkilön <code>henkilo</code> sopivaa metodia. <strong>Eli täydennä metodin koodi!</strong></p>
  <p>Seuraavassa on pääohjelma jossa kasvatuslaitos punnitsee kaksi henkilöä:</p>
  <pre class="sh_java">
public static void main(String[] args) {
    // esimerkkipääohjelma tehtävän ensimmäiseen kohtaan

    Kasvatuslaitos haaganNeuvola = new Kasvatuslaitos();

    Henkilo eero = new Henkilo("Eero", 1, 110, 7);
    Henkilo pekka = new Henkilo("Pekka", 33, 176, 85);

    System.out.println(eero.getNimi() + " paino: " + haaganNeuvola.punnitse(eero) + " kiloa");
    System.out.println(pekka.getNimi() + " paino: " + haaganNeuvola.punnitse(pekka) + " kiloa");
}
</pre>
  <p>Tulostuksen pitäisi olla seuraava:</p>
<pre>
Eero paino: 7 kiloa
Pekka paino: 85 kiloa
</pre>
  <h4>syötä</h4>
  <p>Parametrina olevan olion tilaa on mahdollista muuttaa. Tee kasvatuslaitokselle metodi <code>public void syota(Henkilo henkilo)</code> joka kasvattaa parametrina olevan henkilön painoa yhdellä. </p>
  <p>Seuraavassa esimerkki, jossa henkilöt ensin punnitaan, ja tämän jälkeen neuvolassa syötetään eeroa kolme kertaa. Tämän jälkeen henkilöt taas punnitaan:</p>
  <pre class="sh_java">
public static void main(String[] args) {
    Kasvatuslaitos haaganNeuvola = new Kasvatuslaitos();

    Henkilo eero = new Henkilo("Eero", 1, 110, 7);
    Henkilo pekka = new Henkilo("Pekka", 33, 176, 85);

    System.out.println(eero.getNimi() + " paino: " + haaganNeuvola.punnitse(eero) + " kiloa");
    System.out.println(pekka.getNimi() + " paino: " + haaganNeuvola.punnitse(pekka) + " kiloa");

    haaganNeuvola.syota(eero);
    haaganNeuvola.syota(eero);
    haaganNeuvola.syota(eero);

    System.out.println("");

    System.out.println(eero.getNimi() + " paino: " + haaganNeuvola.punnitse(eero) + " kiloa");
    System.out.println(pekka.getNimi() + " paino: " + haaganNeuvola.punnitse(pekka) + " kiloa");
}
</pre>
  <p>Tulostuksen pitäisi paljastaa että Eeron paino on noussut kolmella:</p>
<pre>
Eero paino: 7 kiloa
Pekka paino: 85 kiloa

Eero paino: 10 kiloa
Pekka paino: 85 kiloa
</pre>
  <h4>laske punnitukset</h4>
  <p>Tee kasvatuslaitokselle metodi <code>public int
    punnitukset()</code> joka kertoo kuinka monta punnitusta
    kasvatuslaitos on ylipäätään tehnyt. Testipääohjelma:</p>
  <pre class="sh_java">
public static void main(String[] args) {
    // esimerkkipääohjelma tehtävän ensimmäiseen kohtaan

    Kasvatuslaitos haaganNeuvola = new Kasvatuslaitos();

    Henkilo eero = new Henkilo("Eero", 1, 110, 7);
    Henkilo pekka = new Henkilo("Pekka", 33, 176, 85);

    System.out.println("punnituksia tehty "+haaganNeuvola.punnitukset());

    haaganNeuvola.punnitse(eero);
    haaganNeuvola.punnitse(pekka);

    System.out.println("punnituksia tehty "+haaganNeuvola.punnitukset());

    haaganNeuvola.punnitse(eero);
    haaganNeuvola.punnitse(eero);
    haaganNeuvola.punnitse(eero);
    haaganNeuvola.punnitse(eero);

    System.out.println("punnituksia tehty "+haaganNeuvola.punnitukset());
}
</pre>
  <p>Tulostuu:</p>
<pre>
punnituksia tehty 0
punnituksia tehty 2
punnituksia tehty 6
</pre>
</div>
<div class="tehtava">
  <h3>Lyyra-kortti ja Kassapääte</h3>
  <h4 class="req">"Tyhmä" Lyyra-kortti</h4>
  <p>Teimme viime viikolla luokan LyyraKortti. Kortilla oli metodit edullisesti ja maukkaasti syömistä sekä rahan lataamista varten.</p>
  <p>Viime viikon tyylillä tehdyssä Lyyra-kortissa oli kuitenkin ongelma. Kortti tiesi lounaiden hinnan ja osasi sen ansiosta vähentää saldoa oikean määrän. Entä kun hinnat nousevat? Tai jos myyntivalikoimaan tulee uusia tuotteita? Hintojen muuttaminen tarkoittaisi, että kaikki jo käytössä olevat Lyyra-kortit pitäisi korvata uusilla, uudet hinnat tuntevilla korteilla. </p>
  <p>Parempi ratkaisu on tehdä kortit "tyhmiksi", hinnoista ja myytävistä tuotteista tietämättömiksi pelkän saldon säilyttäjiksi. Kaikki äly kannattaakin laittaa erillisiin olioihin, kassapäätteisiin.</p>
  <p>Toteutetaan ensin Lyyra-kortista "tyhmä" versio. Kortilla on ainoastaan metodit saldon kysymiseen, rahan lataamiseen ja rahan ottamiseen. Täydennä alla (ja tehtäväpohjassa) olevaan luokkaan metodin <code>public boolean otaRahaa(double maara)</code> ohjeen mukaan:</p>
  <pre class="sh_java">
public class LyyraKortti {
    private double saldo;

    public LyyraKortti(double saldo) {
      this.saldo = saldo;
    }

    public double saldo() {
        return this.saldo;
    }

    public void lataaRahaa(double lisays) {
        this.saldo += lisays;
    }

    public boolean otaRahaa(double maara){
        // toteuta metodi siten että se ottaa kortilta rahaa vain jos saldo on vähintään maara
        // onnistuessaan metodi palauttaa true ja muuten false
    }
}
</pre>
  <p>Testipääohjelma:</p>
  <pre class="sh_java">
public class Paaohjelma {
    public static void main(String[] args) {
        LyyraKortti pekanKortti = new LyyraKortti(10);

        System.out.println("rahaa " + pekanKortti.saldo() );
        boolean onnistuiko = pekanKortti.otaRahaa(8);
        System.out.println("onnistuiko otto: " + onnistuiko );
        System.out.println("rahaa " + pekanKortti.saldo() );

        onnistuiko = pekanKortti.otaRahaa(4);
        System.out.println("onnistuiko otto: " + onnistuiko );
        System.out.println("rahaa " + pekanKortti.saldo() );
      }
}
</pre>
  <p>Tulostuksen kuuluisi olla seuraavanlainen</p>
<pre>
rahaa 10.0
onnistuiko otto: true
rahaa 2.0
onnistuiko otto: false
rahaa 2.0
</pre>
  <h4 class="req">Kassapääte ja käteiskauppa</h4>
  <p>Unicafessa asioidessa asiakas maksaa joko käteisellä tai Lyyra-kortilla. Myyjä käyttää kassapäätettä kortin velottamiseen ja käteismaksujen hoitamiseen. Tehdään ensin kassapäätteestä käteismaksuihin sopiva versio. </p>
  <p>Kassapäätteen runko. Metodien kommentit kertovat halutun toiminnallisuuden:</p>
  <pre class="sh_java">
public class Kassapaate {
    private double rahaa;  // kassassa olevan käteisen määrä
    private int edulliset; // myytyjen edullisten lounaiden määrä
    private int maukkaat;  // myytyjen maukkaiden lounaiden määrä

    public Kassapaate() {
        // kassassa on aluksi 1000 euroa rahaa
    }

    public double syoEdullisesti(double maksu) {
        // edullinen lounas maksaa 2.50 euroa.
        // kasvatetaan kassan rahamäärää edullisen lounaan hinnalla ja palautetaan vaihtorahat
        // jos parametrina annettu maksu ei ole riittävän suuri, ei lounasta myydä ja metodi palauttaa koko summan
    }

    public double syoMaukkaasti(double maksu) {
        // maukas lounas maksaa 4.00 euroa.
        // kasvatetaan kassan rahamäärää maukkaan lounaan hinnalla ja palautetaan vaihtorahat
        // jos parametrina annettu maksu ei ole riittävän suuri, ei lounasta myydä ja metodi palauttaa koko summan
    }

    public String toString() {
        return "kassassa rahaa "+rahaa+" edullisia lounaita myyty "+edulliset+" maukkaita lounaita myyty "+maukkaat;
    }
}
</pre>
  <P>Kassapäätteessä on aluksi rahaa 1000 euroa. Toteuta ylläolevan rungon metodit ohjeen ja alla olevan pääohjelman esimerkkitulosteen mukaan toimiviksi. </p>
  <pre class="sh_java">
public class Paaohjelma {
    public static void main(String[] args) {
        Kassapaate unicafeExactum = new Kassapaate();

        double vaihtorahaa = unicafeExactum.syoEdullisesti(10);
        System.out.println("vaihtorahaa jäi " + vaihtorahaa );

        vaihtorahaa = unicafeExactum.syoEdullisesti(5);
        System.out.println("vaihtorahaa jäi "  + vaihtorahaa );

        vaihtorahaa = unicafeExactum.syoMaukkaasti(4);
        System.out.println("vaihtorahaa jäi "  + vaihtorahaa );

        System.out.println( unicafeExactum );
    }
}
</pre>
  <pre>
vaihtorahaa jäi 7.5
vaihtorahaa jäi 2.5
vaihtorahaa jäi 0.0
kassassa rahaa 1009.0 edullisia lounaita myyty 2 maukkaita lounaita myyty 1
</pre>
  <h4 class="req">Kortilla maksaminen</h4>
  <p>Laajennetaan kassapäätettä siten että myös kortilla voi maksaa. Teemme kassapäätteelle siis metodit joiden parametrina kassapääte saa lyyrakortin jolta se vähentää valitun lounaan hinnan.
    Seuraavassa uusien metodien rungot ja ohje niiden toteuttamiseksi:</p>
<pre class="sh_java">
public class Kassapaate {
    // ...

    public boolean syoEdullisesti(LyyraKortti kortti) {
        // edullinen lounas maksaa 2.50 euroa.
        // jos kortilla on tarpeeksi rahaa, vähennetään hinta kortilta ja palautetaan true
        // muuten palautetaan false
    }

    public boolean syoMaukkaasti(LyyraKortti kortti) {
        // maukas lounas maksaa 4.00 euroa.
        // jos kortilla on tarpeeksi rahaa, vähennetään hinta kortilta ja palautetaan true
        // muuten palautetaan false
    }

    // ...
}
</pre>
  <p><b>Huom:</b> kortilla maksaminen ei lisää kassapäätteessä olevan käteisen määrää.</p>
  <p>Seuraavassa testipääohjelma ja haluttu tulostus:</p>
  <pre class="sh_java">
public class Paaohjelma {
    public static void main(String[] args) {
        Kassapaate unicafeExactum = new Kassapaate();

        double vaihtorahaa = unicafeExactum.syoEdullisesti(10);
        System.out.println("vaihtorahaa jäi " + vaihtorahaa );

        LyyraKortti antinKortti = new LyyraKortti(7);

        boolean onnistuiko = unicafeExactum.syoMaukkaasti(antinKortti);
        System.out.println("riittikö raha: " + onnistuiko);
        onnistuiko = unicafeExactum.syoMaukkaasti(antinKortti);
        System.out.println("riittikö raha: " + onnistuiko);
        onnistuiko = unicafeExactum.syoEdullisesti(antinKortti);
        System.out.println("riittikö raha: " + onnistuiko);

        System.out.println( unicafeExactum );
    }
}
</pre>
<pre>
vaihtorahaa jäi 7.5
riittikö raha: true
riittikö raha: false
riittikö raha: true
kassassa rahaa 1002.5 edullisia lounaita myyty 2 maukkaita lounaita myyty 1
</pre>
  <h4 class="req">Rahan lataaminen</h4>
  <p>Lisätään vielä kassapäätteelle metodi jonka avulla kortille voidaan ladata lisää rahaa. Muista, että rahan lataamisen yhteydessä ladattava summa viedään kassapäätteeseen. Metodin runko:</p>
  <pre class="sh_java">
public void lataaRahaaKortille(LyyraKortti kortti, double summa) {
    // ...
}
</pre>
  <p>Testipääohjelma ja esimerkkisyöte:</p>
  <pre class="sh_java">
public class Paaohjelma {
    public static void main(String[] args) {
        Kassapaate unicafeExactum = new Kassapaate();
        System.out.println( unicafeExactum );

        LyyraKortti antinKortti = new LyyraKortti(2);

        System.out.println("kortilla rahaa " + antinKortti.saldo() + " euroa");

        boolean onnistuiko = unicafeExactum.syoMaukkaasti(antinKortti);
        System.out.println("riittikö raha: " + onnistuiko);

        unicafeExactum.lataaRahaaKortille(antinKortti, 100);

        onnistuiko = unicafeExactum.syoMaukkaasti(antinKortti);
        System.out.println("riittikö raha: " + onnistuiko);

        System.out.println("kortilla rahaa " + antinKortti.saldo() + " euroa");

        System.out.println( unicafeExactum );
    }
}
</pre>
<pre>
kassassa rahaa 1000.0 edullisia lounaita myyty 0 maukkaita lounaita myyty 0
kortilla rahaa 2.0 euroa
riittikö raha: false
riittikö raha: true
kortilla rahaa 98.0 euroa
kassassa rahaa 1100.0 edullisia lounaita myyty 0 maukkaita lounaita myyty 1
</pre>
</div>
</div>
<h3>Metodin parametrina toinen samantyyppinen olio</h3>
<p>Jatkamme edelleen luokan <code>Henkilo</code> parissa. Kuten muistamme, henkilöt tietävät ikänsä:</p>
<pre class="sh_java">
public class Henkilo {

    private String nimi;
    private int ika;
    private int pituus;
    private int paino;

    // ...
}
</pre>
<p>Haluamme vertailla kahden henkilön ikää. Vertailu voidaan hoitaa usealla tavalla. Henkilölle voitaisiin määritellä getterimetodi <code>getIka</code> ja kahden henkilön iän vertailu tapauhtuisi tällöin seuraavasti:</p>
<pre class="sh_java">
Henkilo pekka = new Henkilo("Pekka");
Henkilo juhana = new Henkilo("Juhana")

if ( pekka.getIka() &gt; juhana.getIka() ) {
    System.out.println( pekka.getNimi() + " on vanhempi kuin " + juhana.getNimi() );
}
</pre>
<p>Opettelemme kuitenkin nyt hieman "oliohenkisemmän" tavan kahden henkilön ikävertailun tekemiseen.</p>
<p>Teemme Henkilö-luokalle metodin <code>boolean vanhempiKuin(Henkilo verrattava)</code> jonka avulla tiettyä henkilö-olioa voi verrata parametrina annettuun henkilöön iän perusteella. </p>
<p>Metodia on tarkoitus käyttää seuraavaan tyyliin:</p>
<pre class="sh_java">
public static void main(String[] args) {
    Henkilo pekka = new Henkilo("Pekka", 24);
    Henkilo antti = new Henkilo("Antti", 22);

    if ( pekka.vanhempiKuin(antti) ) {  //  sama kun pekka.vanhempiKuin(antti)==true
        System.out.println( pekka.getNimi() + " on vanhempi kuin " + antti.getNimi() );
    } else {
        System.out.println( pekka.getNimi() + " ei ole vanhempi kuin " + antti.getNimi() );
    }
}
</pre>
<p>Tässä siis kysytään Pekalta onko hän Anttia vanhempi, Pekka vastaa true jos on ja false muuten. Käytännössä kutsutaan "Pekkaa" vastaavan olion johon <code>pekka</code> viittaa metodia <code>vanhempiKuin</code>, jolle annetaan parametriksi "Anttia" vastaavan olion viite <code>antti</code>. </p>
<p>Ohjelman tulostaa:</p>
<pre>
Pekka on vanhempi kuin Antti
</pre>
<p>Metodi saa parametrikseen henkilöolion (tarkemmin sanottuna viitteen henkilöolioon, eli "langan päässä" olevan henkilön) ja vertaa omaa ikäänsä <code>this.ika</code> verrattavaksi annetun henkilön ikään <code>verrattava.ika</code>. Toteutus näyttää seuraavalta:</p>
<pre class="sh_java">
public class Henkilo {
    // ...

    public boolean vanhempiKuin(Henkilo verrattava) {
        if ( this.ika &gt; verrattava.ika ) {
            return true;
        }

        return false;
      }
}
</pre>
<p>Vaikka <code>ika</code> onkin olion yksityinen (<code>private</code>) oliomuuttuja,
  pystymme lukemaan muuttujan arvon kirjoittamalla <code>verrattava.ika</code>.
  Tämä johtuu siitä, että <code>private</code>-muuttujat ovat luettavissa kaikissa
  metodeissa, jotka kyseinen luokka sisältää. Huomaa, että syntaksi (kirjoitusasu) vastaa
  tässä jonkin olion metodin kutsumista. Toisin kuin metodia kutsuttaessa, viittaamme olion kenttään,
  jolloin metodikutsun osoittavia sulkeita ei kirjoiteta. </p>
<h3>Päiväys oliona</h3>
<p>Toinen esimerkki samasta teemasta. Tehdään luokka, jonka avulla voidaan esittää päiväyksiä.</p>
<p>Olion sisällä päiväys esitetään kolmella oliomuuttujalla. Tehdään myös metodi jolla voi vertailla onko päivämäärä aiemmin kuin parametrina annettu päivämäärä:</p>
<pre class="sh_java">
public class Paivays {
    private int paiva;
    private int kuukausi;
    private int vuosi;

    public Paivays(int paiva, int kuukausi, int vuosi) {
        this.paiva = paiva;
        this.kuukausi = kuukausi;
        this.vuosi = vuosi;
    }

    public String toString() {
        return this.paiva + "." + this.kuukausi + "." + this.vuosi;
    }

    public boolean aiemmin(Paivays verrattava) {
        // ensin verrataan vuosia
        if ( this.vuosi &lt; verrattava.vuosi ) {
            return true;
        }

        // jos vuodet ovat samat, verrataan kuukausia
        if ( this.vuosi == verrattava.vuosi &amp;&amp; this.kuukausi &lt; verrattava.kuukausi ) {
            return true;
        }

        // vuodet ja kuukaudet samoja, verrataan päivää
        if ( this.vuosi == verrattava.vuosi &amp;&amp; this.kuukausi == verrattava.kuukausi &amp;&amp;
            this.paiva &lt; verrattava.paiva ) {
            return true;
        }

        return false;
    }
}
</pre>
<p>Käyttöesimerkki:</p>
<pre class="sh_java">
public static void main(String[] args) {
    Paivays p1 = new Paivays(14, 2, 2011);
    Paivays p2 = new Paivays(21, 2, 2011);
    Paivays p3 = new Paivays(1, 3, 2011);
    Paivays p4 = new Paivays(31, 12, 2010);

    System.out.println( p1 + " aiemmin kuin " + p2 + ": " + p1.aiemmin(p2));
    System.out.println( p2 + " aiemmin kuin " + p1 + ": " + p2.aiemmin(p1));

    System.out.println( p2 + " aiemmin kuin " + p3 + ": " + p2.aiemmin(p3));
    System.out.println( p3 + " aiemmin kuin " + p2 + ": " + p3.aiemmin(p2));

    System.out.println( p4 + " aiemmin kuin " + p1 + ": " + p4.aiemmin(p1));
    System.out.println( p1 + " aiemmin kuin " + p4 + ": " + p1.aiemmin(p4));
}
</pre>
<pre>
14.2.2011 aiemmin kuin 21.2.2011: true
21.2.2011 aiemmin kuin 14.2.2011: false
21.2.2011 aiemmin kuin 1.3.2011: true
1.3.2011 aiemmin kuin 21.2.2011: false
31.12.2010 aiemmin kuin 14.2.2011: true
14.2.2011 aiemmin kuin 31.12.2010: false
</pre>

<!-- CAST3 -->

<a href="http://www.youtube.com/watch?feature=player_embedded&v=9XYbf5V7uGs" height="300" target="_blank"><img src=" https://www.cs.helsinki.fi/group/java/k13/ohpe/img/youtube.jpg"/></a>

<div class="tehtavat">
  <div class="tehtava">
  <h3>Asuntovertailu</h3>
  <p>Asuntovälitystoimiston tietojärjestelmässä myynnissä olevaa asuntoa kuvataan seuraavan luokan olioilla:</p>
  <pre class="sh_java">
public class Asunto {
    private int huoneita;
    private int nelioita;
    private int neliohinta;

    public Asunto(int huoneita, int nelioita, int neliohinta){
        this.huoneita = huoneita;
        this.nelioita = nelioita;
        this.neliohinta = neliohinta;
    }
}
</pre>
  <p>Tehtävänä on toteuttaa muutama metodi, joiden avulla myynnissä olevia asuntoja voidaan vertailla.</p>
  <h4>Suurempi</h4>
  <p>Tee metodi <code>public boolean suurempi(Asunto verrattava)</code> joka palauttaa true jos asunto-olio, jolle metodia kutsutaan on suurempi kuin verrattavana oleva asunto-olio.</p>
  <p>Esimerkki metodin toiminnasta:</p>
  <pre class="sh_java">
Asunto eiraYksio = new Asunto(1, 16, 5500);
Asunto kallioKaksio = new Asunto(2, 38, 4200);
Asunto jakomakiKolmio = new Asunto(3, 78, 2500);

System.out.println( eiraYksio.suurempi(kallioKaksio) );       // false
System.out.println( jakomakiKolmio.suurempi(kallioKaksio) );  // true
</pre>
  <h4>Hintaero</h4>
  <p>Tee metodi <code>public int hintaero(Asunto verrattava)</code> joka palauttaa asunto-olion jolle metodia kutsuttiin ja parametrina olevan asunto-olion hintaeron. Hintaero on asuntojen hintojen (=neliöhinta*neliöt) itseisarvo.</p>
  <p>Esimerkki metodin toiminnasta:</p>
<pre class="sh_java">
Asunto eiraYksio = new Asunto(1, 16, 5500);
Asunto kallioKaksio = new Asunto(2, 38, 4200);
Asunto jakomakiKolmio = new Asunto(3, 78, 2500);

System.out.println( eiraYksio.hintaero(kallioKaksio) );        // 71600
System.out.println( jakomakiKolmio.hintaero(kallioKaksio) );   // 35400
</pre>
  <h4>Kalliimpi</h4>
  <p>Tee metodi <code>public boolean kalliimpi(Asunto verrattava)</code> joka palauttaa true jos asunto-olio, jolle metodia kutsutaan on kalliimpi kuin verrattavana oleva asunto-olio.</p>
  <p>Esimerkki metodin toiminnasta:</p>
  <pre class="sh_java">
Asunto eiraYksio = new Asunto(1, 16, 5500);
Asunto kallioKaksio = new Asunto(2, 38, 4200);
Asunto jakomakiKolmio = new Asunto(3, 78, 2500);

System.out.println( eiraYksio.kalliimpi(kallioKaksio) );       // false
System.out.println( jakomakiKolmio.kalliimpi(kallioKaksio) );   // true
</pre>
</div>
</div>
<h3>Olioita listalla</h3>
<p>Olemme käyttäneet <code>ArrayList</code>:ejä jo monessa esimerkissä ja tehtävässä. ArrayList-olioon pystyy lisäämään esimerkiksi merkkijonoja ja listalla olevien merkkijonojen läpikäynti, etsiminen, poistaminen, järjestäminen ym. ovat vaivattomia toimenpiteitä.</p>
<p>ArrayList:eihin voidaan laittaa minkä tahansa tyyppisiä oliota. Luodaan seuraavassa henkilölista, eli tyyppiä <code>ArrayList&lt;Henkilo&gt;</code> oleva ArrayList ja laitetaan sinne muutama henkilöolio:</p>
<pre class="sh_java">
public static void main(String[] args) {
    ArrayList&lt;Henkilo&gt; opettajat = new ArrayList&lt;Henkilo&gt;();

    // voidaan ensin ottaa henkilö muuttujaan
    Henkilo opettaja = new Henkilo("Juhana");
    // ja lisätä se sitten listalle
    opettajat.add(opettaja);

    // tai voidaan myös luoda olio lisättäessä:
    opettajat.add( new Henkilo("Matti") );
    opettajat.add( new Henkilo("Martin") );

    System.out.println("opettajat vastasyntyneenä: ");
    for ( Henkilo hlo : opettajat ) {
        System.out.println( hlo );
    }

    for ( Henkilo hlo : opettajat ) {
        hlo.vanhene( 30 );
    }

    System.out.println("30 vuoden kuluttua: ");
    for ( Henkilo hlo : opettajat ) {
        System.out.println( hlo );
    }
}
</pre>
<p>Ohjelman tulostus:</p>
<pre>
opettajat vastasyntyneenä:
Juhana, ikä 0 vuotta
Matti, ikä 0 vuotta
Martin, ikä 0 vuotta
30 vuoden kuluttua:
Juhana, ikä 30 vuotta
Matti, ikä 30 vuotta
Martin, ikä 30 vuotta
</pre>
<div class="tehtavat">
  <div class="tehtava">
  <h3>Opiskelija-luokka</h3>
  <h4 class="req">Opiskelija-luokka</h4>
  <p>Tee luokka <code>Opiskelija</code>,
    johon tallennetaan seuraavat tiedot opiskelijasta:</p>
  <ul>
    <li> nimi (<code>String</code>)</li>
    <li> opiskelijanumero (<code>String</code>)</li>
  </ul>
  <p>Tee luokkaan seuraavat metodit:</p>
  <ul>
    <li> konstruktori, jolle annetaan opiskelijan nimi ja opiskelijanumero</li>
    <li> <code>haeNimi</code>, joka palauttaa opiskelijan nimen, esim. Pekka Mikkola</li>
    <li> <code>haeOpiskelijanumero</code>, joka palauttaa opiskelijan opiskelijanumeron, esim. 013141590</li>
    <li> <code>toString</code>, joka palauttaa merkkijonoesityksen opiskelijasta muodossa: Pekka Mikkola (013141590)</li>
  </ul>
  <p>Voit testata luokan toimintaa seuraavalla koodilla:</p>
  <pre class="sh_java">
public class Main {
    public static void main(String[] args) {
        Opiskelija pekka = new Opiskelija("Pekka Mikkola", "013141590");
        System.out.println("Nimi: " + pekka.haeNimi());
        System.out.println("Opiskelijanumero: " + pekka.haeOpiskelijanumero());
        System.out.println(pekka);
    }
}
</pre>
  <p>Ohjelman tulostuksen tulisi olla seuraava:</p>
  <pre>
Nimi: Pekka Mikkola
Opiskelijanumero: 013141590
Pekka Mikkola (013141590)
</pre>
  <h4 class="req">Opiskelijalista</h4>
  <p>Tee edellisen tilalle uusi pääohjelma, joka kysyy alla olevan esimerkkitulostuksen tyyliin opiskelijoiden tietoja (ensin kysytään nimi ja sen jälkeen opiskelijanumero). Ohjelma luo jokaisesta opiskelijasta uuden olion ja tallentaa sen listaan. Kun käyttäjä antaa nimeksi tyhjän merkkijonon, ohjelma tulostaa listalla olevat opiskelijat.</p>
  <p>Listan määrittelyn tulisi olla seuraava:</p>
  <pre class="sh_java">
  ArrayList&lt;Opiskelija&gt; lista = new ArrayList&lt;Opiskelija&gt;();
</pre>
  <p>Seuraavassa on esimerkki ohjelman suorituksesta:</p>
  <pre>
Nimi: <font color="red">Alfred Apina</font>
Opiskelijanumero: <font color="red">017635727</font>
Nimi: <font color="red">Bruno Banaani</font>
Opiskelijanumero: <font color="red">011288989</font>
Nimi: <font color="red">Cecilia Cembalo</font>
Opiskelijanumero: <font color="red">013672548</font>
Nimi:

Alfred Apina (017635727)
Bruno Banaani (011288989)
Cecilia Cembalo (013672548)
</pre>
  <h4 class="req">Opiskelijahaku</h4>
  <p>Laajenna edellisen tehtävän opiskelijalistaa siten,
    että listan syöttämisen jälkeen pääohjelma kysyy hakusanan,
    jonka avulla voi hakea opiskelijat,
    joiden nimessä on annettu hakusana.
    Tehtävänäsi on siis toteuttaa hakutoiminto.</p>
  <p>Vihje: Käy opiskelijat läpi silmukassa ja
    tarkista <code>String</code>-luokan <code>contains</code>-metodilla,
    onko hakusana opiskelijan nimessä.</p>
  <p>Seuraavassa on esimerkki ohjelman suorituksesta:</p>
  <pre>
Nimi: <font color="red">Saku Silmukka</font>
Opiskelijanumero: <font color="red">015696234</font>
Nimi: <font color="red">Cecilia Cembalo</font>
Opiskelijanumero: <font color="red">013672548</font>
Nimi: <font color="red">Taina Taulukko</font>
Opiskelijanumero: <font color="red">014662803</font>
Nimi:

Saku Silmukka (015696234)
Cecilia Cembalo (013672548)
Taina Taulukko (014662803)

Anna hakusana: <font color="red">ukk</font>
Tulokset:
Saku Silmukka (015696234)
Taina Taulukko (014662803)
</pre>
</div>
</div>
<h3>Olion sisällä olio</h3>
<p>Olioiden sisällä voi olla olioita, ei pelkästään merkkijonoja vaan myös itse määriteltyjä oliota. Jatketaan taas <code>Henkilo</code>-luokan parissa ja lisätään henkilölle syntymäpäivä. Syntymäpäivä on luonnollista esittää aiemmin tehdyn <code>Paivays</code>-olion avulla:</p>
<pre class="sh_java">
public class Henkilo {
    private String nimi;
    private int ika;
    private int paino;
    private int pituus;
    private Paivays syntymaPaiva;

    // ...
  </pre>
<p>Tehdään henkilölle uusi konstruktori, joka mahdollistaa syntymäpäivän asettamisen:</p>
<pre class="sh_java">
public Henkilo(String nimi, int paiva, int kuukausi, int vuosi) {
    this.nimi = nimi;
    this.paino = 0;
    this.pituus = 0;
    this.syntymaPaiva = new Paivays(paiva, kuukausi, vuosi);
}
</pre>
<p>Eli konstruktorin parametrina annetaan erikseen päiväyksen osat (päivä, kuukausi, vuosi), niistä
  luodaan päiväysolio joka <i>sijoitetaan</i> oliomuuttujaan <code>syntymaPaiva</code>.</p>
<p>Muokataan <code>toString</code> siten, että iän sijaan se näyttää syntymäpäivän:</p>
<pre class="sh_java">
public String toString() {
    return this.nimi + ", syntynyt " + this.syntymaPaiva;
}
</pre>
<p>Ja kokeillaan miten uusittu Henkilö-luokka toimii:</p>
<pre class="sh_java">
public static void main(String[] args) {
    Henkilo martin = new Henkilo("Martin", 24, 4, 1983);

    Henkilo juhana = new Henkilo("Juhana", 17, 9, 1985);

    System.out.println( martin );
    System.out.println( juhana );
  }
</pre>
<p>Tulostuu:</p>
<pre>
Martin, syntynyt 24.4.1983
Juhana, syntynyt 17.9.1985
</pre>
<p>Luvussa 24.4 todettiin, että oliot ovat "langan päässä". Kertaa nyt luku 24.4.</p>
<p>Henkilö-oliolla on oliomuuttujat <code>nimi</code> joka on merkkijono-olio ja <code>syntymaPaiva</code> joka on Päiväys-olio. Henkilön oliomuuttujat siis ovat molemmat olioita, eli teknisesti ottaen ne eivät sijaitse henkilö-olion sisällä vaan ovat "langan päässä", ts. henkilöllä on oliomuuttujissa tallessa viite niihin. Kuvana:</p>
<p> <img src=" https://www.cs.helsinki.fi/group/java/k13/ohpe/img/henkilo.PNG"/> </p>
<p>Pääohjelmalla on nyt siis langan päässä kaksi Henkilö-olioa. Henkilöllä on nimi ja syntymäpäivä. Koska molemmat ovat olioita, ovat ne henkilöllä langan päässä.</p>
<p>Syntymäpäivä vaikuttaa hyvältä laajennukselta Henkilö-luokkaan. Huomaamme kuitenkin, että oliomuuttuja <code>ikä</code> uhkaa jäädä turhaksi ja lienee syytä poistaa se. Iän pystyy nimittäin tarvittaessa selvittämään helposti nykyisen päivämäärän ja syntymäpäivän perusteella. Javassa nykyinen päivä selviää esim. seuraavasti:</p>
<pre class="sh_java">
int paiva = Calendar.getInstance().get(Calendar.DATE);
int kuukausi = Calendar.getInstance().get(Calendar.MONTH) + 1; // tammikuun numero 0 joten  lisätään 1
int vuosi = Calendar.getInstance().get(Calendar.YEAR);
System.out.println("tänään on " + paiva + "." + kuukausi + "." + vuosi );
</pre>
<p>Kun ikä poistetaan, täytyy <code>vanhempiKuin</code>-metodi muuttaa toimimaan syntymäpäiviä
  vertaamalla. Teemme muutoksen harjoitustehtävänä.</p>
<div class="tehtavat">
  <div class="tehtava">
    <h3>Kellosta olio</h3>
  <p>Edellisen viikon tehtävässä 78 tehtiin ensin luokka <code>YlhaaltaRajoitettuLaskuri</code> ja rakennettiin laskurien avulla pääohjelmaan kello. Tehdään nyt myös itse kellosta olio. Luokan kello runko näyttää seuraavalta:</p>
  <pre class="sh_java">

public class Kello {
    private YlhaaltaRajoitettuLaskuri tunnit;
    private YlhaaltaRajoitettuLaskuri minuutit;
    private YlhaaltaRajoitettuLaskuri sekunnit;

    public Kello(int tunnitAlussa, int minuutitAlussa, int sekunnitAlussa) {
      // luodaan kello joka asetetaan parametrina annettuun aikaan
    }

    public void etene(){
      // kello etenee sekunnilla
    }

    public String toString() {
        // palauttaa kellon merkkijonoesityksen
      }
}
</pre>
  <p>Kopioi uuteen projektiin viime viikon tehtävän 78 <code>YlhaaltaRajoitettuLaskuri</code>-luokka.</p>
  <p>Toteuta luokan <code>Kello</code> konstruktori ja puuttuvat
    metodit. Voit testata kelloasi seuraavalla pääohjelmalla:</p>
  <pre class="sh_java">
public class Main {
    public static void main(String[] args) {
        Kello kello = new Kello(23, 59, 50);

        int i = 0;
        while( i &lt; 20) {
            System.out.println( kello );
            kello.etene();
            i++;
        }
    }
}
</pre>
  <p>Tulostuksen tulisi edetä seuraavasti:</p>
<pre>
23:59:50
23:59:51
23:59:52
23:59:53
23:59:54
23:59:55
23:59:56
23:59:57
23:59:58
23:59:59
00:00:00
00:00:01
...
</pre>
</div>
</div>

<!-- foobar -->

<h3>Olion sisällä listallinen olioita</h3>
<p>Laajennetaan <code>PainonvartijaYhdistys</code>-oliota siten, että yhdistys tallettaa kaikki jäsenensä <code>ArrayList</code>-olioon. Listalle tulee siis <code>Henkilo</code>-olioita. Yhdistykselle annetaan laajennetussa versiossa konstruktorin parametrina nimi:</p>
<pre class="sh_java">
public class PainonvartijaYhdistys {
    private double alinPainoindeksi;
    private String nimi;
    private ArrayList&lt;Henkilo&gt; jasenet;

    public PainonvartijaYhdistys(String nimi, double alinPainoindeksi) {
        this.alinPainoindeksi = alinPainoindeksi;
        this.nimi = nimi;
        this.jasenet = new ArrayList&lt;Henkilo&gt;();
    }

//..
}
</pre>
<p>Tehdään metodi jolla henkilö liitetään yhdistykseen. Metodi ei liitä yhdistykseen kuin tarpeeksi suuren painoindeksin omaavat henkilöt. Tehdään myös toString jossa tulostetaan jäsenten nimet:</p>
<pre class="sh_java">
public class PainonvartijaYhdistys {
  // ...

    public boolean hyvaksytaanJaseneksi(Henkilo henkilo) {
        if ( henkilo.painoIndeksi() &lt; this.alinPainoindeksi ) {
            return false;
        }

        return true;
    }

    public void lisaaJaseneksi(Henkilo henkilo) {
        if ( !hyvaksytaanJaseneksi(henkilo) ) { // sama kuin hyvaksytaanJaseneksi(henkilo) == false
            return;
        }

        this.jasenet.add(henkilo);
    }

    public String toString() {
        String jasenetMerkkijonona = "";

        for ( Henkilo jasen : this.jasenet ) {
            jasenetMerkkijonona += "  " + jasen.getNimi() + "\n";
        }

        return "Painonvartijayhdistys " + this.nimi + " jäsenet: \n" + jasenetMerkkijonona;
    }
}
</pre>
<p>Metodi <code>lisaaJaseneksi</code> käyttää aiemmin tehtyä metodia <code>hyvaksytaanJaseneksi</code>.</p>
<p>Kokeillaan laajentunutta painonvartijayhdistystä:</p>
<pre class="sh_java">
public static void main(String[] args) {
    PainonvartijaYhdistys painonVartija = new PainonvartijaYhdistys("Kumpulan paino", 25);

    Henkilo matti = new Henkilo("Matti");
    matti.setPaino(86);
    matti.setPituus(180);
    painonVartija.lisaaJaseneksi(matti);

    Henkilo juhana = new Henkilo("Juhana");
    juhana.setPaino(64);
    juhana.setPituus(172);
    painonVartija.lisaaJaseneksi(juhana);

    Henkilo harri = new Henkilo("Harri");
    harri.setPaino(104);
    harri.setPituus(182);
    painonVartija.lisaaJaseneksi(harri);

    Henkilo petri = new Henkilo("Petri");
    petri.setPaino(112);
    petri.setPituus(173);
    painonVartija.lisaaJaseneksi(petri);

    System.out.println( painonVartija );
}
</pre>
<p>Tulostuksesta huomaamme, että Juhanaa ei kelpuutettu jäseneksi:</p>
<pre>
Painonvartijayhdistys Kumpulan paino jäsenet:
Matti
Harri
Petri
</pre>


  <!-- CAST4 -->

  <a href="http://www.youtube.com/watch?feature=player_embedded&v=Rut2pt5ztN0" height="300" target="_blank"><img src=" https://www.cs.helsinki.fi/group/java/k13/ohpe/img/youtube.jpg"/></a>


<div class="tehtavat">
  <div class="tehtava">
  <h3>Joukkueet ja pelaajat</h3>
  <h4 class="req"><code>Joukkue</code>-luokka</h4>
  <p>Tee luokka <code>Joukkue</code>,
    johon tallennetaan joukkueen nimi (<code>String</code>).
    Tee luokkaan seuraavat metodit:</p>
  <ul>
    <li> konstruktori, jolle annetaan joukkueen nimi</li>
    <li> <code>haeNimi</code>, joka palauttaa joukkueen nimen</li>
  </ul>
  <p>Seuraava pääohjelma testaa luokan toimintaa:</p>
  <pre class="sh_java">
public class Main {
    public static void main(String[] args) {
        Joukkue tapiiri = new Joukkue("FC Tapiiri");
        System.out.println("Joukkue: " + tapiiri.haeNimi());
    }
}
</pre>
  <p>Ohjelman tulostus on seuraava:</p>
  <pre>
Joukkue: FC Tapiiri
</pre>
  <h4 class="req">Pelaaja</h4>
  <p>Luo luokka <code>Pelaaja</code>, johon tallennetaan pelaajan nimi ja tehtyjen maalien määrä. Tee luokkaan kaksi konstruktoria: yksi jolle annetaan vain pelaajan nimi, toinen jolle annetaan sekä pelaajan nimi että pelaajan tekemien maalien määrä. Lisää pelaajalle myös metodit:</p>
  <ul>
    <li> <code>haeNimi</code>, joka palauttaa pelaajan nimen</li>
    <li> <code>maalit</code>, joka palauttaa tehtyjen maalien määrän</li>
    <li> <code>toString</code>, joka palauttaa pelaajan merkkijonoesityksen</li>
  </ul>
  <pre class="sh_java">
public class Main {
    public static void main(String[] args) {
        Joukkue tapiiri = new Joukkue("FC Tapiiri");
        System.out.println("Joukkue: " + tapiiri.haeNimi());

        Pelaaja matti = new Pelaaja("Matti");
        System.out.println("Pelaaja: " + matti);

        Pelaaja pekka = new Pelaaja("Pekka", 39);
        System.out.println("Pelaaja: " + pekka);
    }
}
</pre>
<pre>
Joukkue: FC Tapiiri
Pelaaja: Matti, maaleja 0
Pelaaja: Pekka, maaleja 39
</pre>
  <h4 class="req">Pelaajat joukkueisiin</h4>
  <p>Lisää luokkaan <code>Joukkue</code> seuraavat metodit:</p>
  <ul>
    <li> <code>lisaaPelaaja</code>, joka lisää pelaajan joukkueeseen</li>
    <li> <code>tulostaPelaajat</code>, joka tulostaa joukkueessa olevat pelaajat</li>
  </ul>
  <p>Tallenna joukkueessa olevat pelaajat <code>Joukkue</code>-luokan
    sisäiseen <code>ArrayList</code>-listaan.</p>
  <p>Seuraava pääohjelma testaa luokan toimintaa:</p>
  <pre class="sh_java">
public class Main {
    public static void main(String[] args) {
        Joukkue tapiiri = new Joukkue("FC Tapiiri");

        Pelaaja matti = new Pelaaja("Matti");
        Pelaaja pekka = new Pelaaja("Pekka", 39);

        tapiiri.lisaaPelaaja(matti);
        tapiiri.lisaaPelaaja(pekka);
        tapiiri.lisaaPelaaja(new Pelaaja("Mikael", 1)); //vaikutus on sama kuin edellisillä

        tapiiri.tulostaPelaajat();
    }
}
</pre>
  <p>Ohjelman tulostuksen tulisi olla seuraava:</p>
<pre>
Matti, maaleja 0
Pekka, maaleja 39
Mikael, maaleja 1
</pre>
  <h4 class="req">Joukkueen maksimikoko ja nykyinen koko</h4>
  <p>Lisää luokkaan <code>Joukkue</code> seuraavat metodit:</p>
  <ul>
    <li> <code>asetaMaksimikoko(int maksimikoko)</code>, joka asettaa joukkueen maksimikoon (eli maksimimäärän pelaajia)</li>
    <li> <code>koko</code>, joka palauttaa pelaajien määrän (<code>int</code>)</li>
  </ul>
  <p>Joukkueen suurin sallittu pelaajamäärä on oletusarvoisesti 16. Metodin <code>asetaMaksimikoko</code> avulla tätä rajaa voi muuttaa. Muuta metodia <code>lisaaPelaaja</code> niin, että se ei lisää pelaajaa joukkueeseen, jos sallittu pelaajamäärä ylittyisi.</p>
  <p><strong>HUOM:</strong> muista lisätä oletusarvoinen maksimikoko koodiisi sillä muuten arvoksi tulee 0. Tämä aiheuttaa edellisen kohdan testien hajoamisen, sillä testit luovat oletusmaksimikokoisia joukkueita ja jos joukkueen maksimikoko on 0, ei joukkueeseen voi lisätä yhtään pelaajaa.</p>
  <p>Seuraava pääohjelma testaa luokan toimintaa:</p>
  <pre class="sh_java">
public class Main {
    public static void main(String[] args) {
        Joukkue tapiiri = new Joukkue("FC Tapiiri");
        tapiiri.asetaMaksimikoko(1);

        Pelaaja matti = new Pelaaja("Matti");
        Pelaaja pekka = new Pelaaja("Pekka", 39);
        tapiiri.lisaaPelaaja(matti);
        tapiiri.lisaaPelaaja(pekka);
        tapiiri.lisaaPelaaja(new Pelaaja("Mikael", 1)); //vaikutus on sama kuin edellisillä

        System.out.println("Pelaajia yhteensä: " + tapiiri.koko());
    }
}
</pre>
<pre>
Pelaajia yhteensä: 1
</pre>
  <h4 class="req">Joukkueen maalit</h4>
  <p>Lisää luokkaan <code>Joukkue</code> metodi:</p>
  <ul>
    <li> <code>maalit</code>, joka palauttaa joukkueen pelaajien tekemien maalien yhteismäärän.</li>
  </ul>
  <p>Seuraava pääohjelma testaa luokan toimintaa:</p>
  <pre class="sh_java">
public class Main {
    public static void main(String[] args) {
        Joukkue tapiiri = new Joukkue("FC Tapiiri");

        Pelaaja matti = new Pelaaja("Matti");
        Pelaaja pekka = new Pelaaja("Pekka", 39);
        tapiiri.lisaaPelaaja(matti);
        tapiiri.lisaaPelaaja(pekka);
        tapiiri.lisaaPelaaja(new Pelaaja("Mikael", 1)); //vaikutus on sama kuin edellisillä

        System.out.println("Maaleja yhteensä: " + tapiiri.maalit());
    }
}
</pre>
<pre>
Maaleja yhteensä: 40
</pre>
</div>
</div>
<h3>Metodi palauttaa olion</h3>
<p>Olemme nähneet metodeja jotka palauttavat totuusarvoja, lukuja, listoja ja merkkijonoja. On helppoa arvata, että metodi voi palauttaa minkä tahansa tyyppisen olion. Tehdään painovartijayhdistykselle metodi, jolla saadaan tietoon yhdistyksen suurimman painoindeksin omaava henkilö. </p>
<pre class="sh_java">
public class PainonvartijaYhdistys {
    // ...

    public Henkilo suurinPainoindeksinen() {
        // jos jasenlista on tyhjä, palautetaan null-viite
        if ( this.jasenet.isEmpty() ) {
            return null;
        }

        Henkilo painavinTahanAsti = this.jasenet.get(0);

        for ( Henkilo henkilo : this.jasenet) {
            if ( henkilo.painoIndeksi() &gt; painavinTahanAsti.painoIndeksi() ) {
                painavinTahanAsti = henkilo;
            }
        }

        return painavinTahanAsti;
    }
}
</pre>
<p>Logiikaltaan metodi toimii samaan tapaan kuin suurimman luvun etsiminen taulukosta. Käytössä on apumuuttuja <code>painavinTahanAsti</code> joka laitetaan aluksi viittaamaan listan ensimmäiseen henkilöön. Sen jälkeen käydään lista läpi ja katsotaan tuleeko vastaan suuremman painoindeksin omaavia henkilöitä, jos tulee, niin otetaan viite talteen muuttujaan <code>painavinTahanAsti</code>. Lopuksi palautetaan muuttujan arvo eli <i>viite henkilöolioon</i>.</p>
<p>Tehdään lisäys edelliseen pääohjelmaan. Pääohjelma ottaa vastaan metodin palauttaman viitteen muuttujaan <code>painavin</code>.</p>
<pre class="sh_java">
public static void main(String[] args) {
    PainonvartijaYhdistys painonVartija = new PainonvartijaYhdistys("Kumpluan paino", 25);

    // ..

    Henkilo painavin = painonVartija.suurinPainoindeksinen();
    System.out.print("suurin painoindeksinen jäsen: " + painavin.getNimi() );
    System.out.println(" painoindeksi " + String.format( "%.2f", painavin.painoIndeksi() ) );
}
</pre>
<p>Tulostuu:</p>
<pre>
suurin painoindeksinen jäsen: Petri
painoindeksi 37,42
</pre>
<h3>Metodi palauttaa luomansa olion</h3>
<p>Edellisessä esimerkissä metodi palautti yhden painonVartija-olion sisältämistä Henkilo-olioista. On myös mahdollista, että metodi palauttaa kokonaan uuden olion. Seuraavassa yksinkertainen laskuri, jolla on metodi <code>kloonaa</code>, jonka avulla laskurista voidaan tehdä klooni, eli uusi laskurio-olio, jolla on luomishetkellä sama arvo kuin kloonattavalla laskurilla:</p>
<pre class="sh_java">
public Laskuri {
    private int arvo;

    public Laskuri(){
        this(0);
    }

    public Laskuri(int alkuarvo){
        this.arvo = alkuarvo;
    }

    public void kasvata(){
        this.arvo++;
    }

    public String toString(){
        return "arvo: "+arvo;
    }

    public Laskuri kloonaa(){
        // luodaan uusi laskuriolio, joka saa alkuarvokseen kloonattavan laskurin arvon
        Laskuri klooni = new Laskuri(this.arvo);

        // palautetaan klooni kutsujalle
        return klooni;
    }
}
</pre>
<p>Seuraavassa käyttöesimerkki:</p>
<pre class="sh_java">
Laskuri laskuri = new Laskuri();
laskuri.kasvata();
laskuri.kasvata();

System.out.println(laskuri);         // tulostuu 2

Laskuri klooni = laskuri.kloonaa();

System.out.println(laskuri);         // tulostuu 2
System.out.println(klooni);          // tulostuu 2

laskuri.kasvata();
laskuri.kasvata();
laskuri.kasvata();
laskuri.kasvata();

System.out.println(laskuri);         // tulostuu 6
System.out.println(klooni);          // tulostuu 2

klooni.kasvata();

System.out.println(laskuri);         // tulostuu 6
System.out.println(klooni);          // tulostuu 3
</pre>
<p>Kloonattavan ja kloonin arvo on siis kloonauksen tapahduttua sama. Kyseessä on kuitenkin kaksi erillistä olioa, eli jatkossa kun toista laskureista kasvatetaan, ei kasvatus vaikuta toisen arvoon millään tavalla.</p>
<div class="tehtavat">
  <div class="tehtava">
  <h3>Päiväys</h3>
  <p>Tehtäväpohjan mukana tulee luvussa 24.7 esitelty luokka <code>Paivays</code>, jossa päivämäärä talletetaan oliomuuttujien <code>vuosi</code>, <code>kuukausi</code>, ja <code>paiva</code> avulla:
  <pre class="sh_java">
public class Paivays {
    private int paiva;
    private int kuukausi;
    private int vuosi;

    public Paivays(int paiva, int kuukausi, int vuosi) {
        this.paiva = paiva;
        this.kuukausi = kuukausi;
        this.vuosi = vuosi;
    }

    public String toString() {
        return this.paiva + "." + this.kuukausi + "." + this.vuosi;
    }

    public boolean aiemmin(Paivays verrattava) {
        // ensin verrataan vuosia
        if ( this.vuosi &lt; verrattava.vuosi ) {
            return true;
        }

        // jos vuodet ovat samat, verrataan kuukausia
        if ( this.vuosi == verrattava.vuosi &amp;&amp; this.kuukausi &lt; verrattava.kuukausi ) {
            return true;
        }

        // vuodet ja kuukaudet samoja, verrataan päivää
        if ( this.vuosi == verrattava.vuosi &amp;&amp; this.kuukausi == verrattava.kuukausi &amp;&amp;
            this.paiva &lt; verrattava.paiva ) {
            return true;
        }

        return false;
    }
}
</pre>
  <p>Tässä tehtäväsarjassa laajennetaan luokkaa.</p>
  <h4 class="req">Seuraava päivä</h4>
  <p>Toteuta metodi <code>public void etene()</code>, joka siirtää päiväystä yhdellä päivällä. Tässä tehtävässä oletetaan, että jokaisessa kuukaudessa on 30 päivää. Huom! Sinun tulee <em>tietyissä</em> tilanteissa muuttaa kuukauden ja vuoden arvoa.</p>
  <h4 class="req">Tietty määrä päiviä eteenpäin</h4>
  <p>Toteuta metodi <code>public void etene(int montakoPaivaa)</code>, joka siirtää päiväystä annetun päivien määrän verran. Käytä apuna edellisessä tehtävässä toteutettua metodia <code>etene()</code>.</p>
  <h4 class="req">Ajan kuluminen</h4>
  <p>Lisätään <code>Paivays</code>-olioon mahdollisuus edistää aikaa. Tee oliolle metodi <code>Paivays paivienPaasta(int paivia)</code>, joka luo <strong>uuden</strong> <code>Paivays</code>-olion, jonka päiväys on annetun päivien lukumäärän verran suurempi kuin oliolla, jolle sitä kutsuttiin. Voit edelleen olettaa, että jokaisessa kuukaudessa on 30 päivää. Huomaa, että vanhan päiväysolion on pysyttävä muuttumattomana! </p>
  <p>Koska metodissa on luotava <b>uusi olio</b>, tulee rungon olla suunnilleen seuraavanlainen:</p>
  <pre class="sh_java">
public Paivays paivienPaasta(int paivia){
    Paivays uusiPaivays = new Paivays( ... );

    // tehdään jotain...

    return uusiPaivays;
}

</pre>
  <p>Ohessa on esimerkki metodin toiminnasta. </p>
  <pre class="sh_java">
public static void main(String[] args) {
    Paivays pvm = new Paivays(25, 2, 2011);
    Paivays uusi_pvm = pvm.paivienPaasta(7);
    for (int i = 1; i &lt;= 7; ++i) {
        System.out.println("Perjantai " + i + " viikon kuluttua on " + uusi_pvm);
        uusi_pvm = uusi_pvm.paivienPaasta(7);
    }
    System.out.println("Tämän viikon perjantai on " + pvm);
    System.out.println("Päivämäärä 790:n päivän päästä tämän viikon perjantaista on  " + pvm.paivienPaasta(790));
}
</pre>
  <p>Ohjelma tulostaa:</p>
<pre>
Perjantai 1 viikon kuluttua on 2.3.2011
Perjantai 2 viikon kuluttua on 9.3.2011
Perjantai 3 viikon kuluttua on 16.3.2011
Perjantai 4 viikon kuluttua on 23.3.2011
Perjantai 5 viikon kuluttua on 30.3.2011
Perjantai 6 viikon kuluttua on 7.4.2011
Perjantai 7 viikon kuluttua on 14.4.2011
Tämän viikon perjantai on 25.2.2011
Päivämäärä 790:n päivän päästä tämän viikon perjantaista on  5.5.2013
</pre>
  <p> <strong>Huom!</strong> Sen sijaan, että muuttaisimme vanhan olion tilaa
    palautamme uuden olion. Kuvitellaan, että <code>Paivays</code>-luokalle on
    olemassa metodi <code>edista</code>, joka toimii vastaavasti kuin ohjelmoimamme
    metodi, mutta se muuttaa vanhan olion tilaa.
    Tällöin seuraava koodin pätkä tuottaisi ongelmia. </p>
  <pre class="sh_java">
Paivays nyt = new Paivays(20,2,2011);
Paivays viikonPaasta = nyt;
viikonPaasta.edista(7);
System.out.println("Nyt: " + nyt);
System.out.println("Viikon päästä: " + viikonPaasta);
</pre>
  <p>Ohjelman tulostus olisi seuraavanlainen:</p>
<pre>
Nyt 27.2.2011
Viikon päästä 27.2.2011
</pre>
  <p>Tämä johtuu siitä, että tavallinen sijoitus kopioi ainoastaan viitteen olioon. Siis
    itse asiassa ohjelman oliot <code>nyt</code> ja <code>viikonPaasta</code> viittavaat <strong>yhteen ja samaan</strong> <code>Paivays</code>-olioon. </p>
</div>

  <div class="tehtava">
  <h3>Päivämäärien erotus</h3>
  <p>Jatketaan luokan Päiväys laajentamista. Tämä tehtävä ei riipu edellisestä tehtävästä, saat tehtäväpohjan mukana Paivays-luokan jossa ei ole edellisen tehtävän lisäyksiä.</p>
  <h4 class="req">Kahden päiväyksen erotus vuosissa</h4>
  <p><b>Lisää päiväykselle metodi</b> <code>public int erotusVuosissa(Paivays verrattava)</code>, jonka avulla saadaan selville päiväyksen ja verrattavan päiväyksen ero vuosissa. <b>Huomioi seuraavat: </b></p>
  <ul>
    <li> Ensimmäisessä versiossa metodi toimii vasta aika karkealla tasolla, se ainoastaan laskee verrattavien päiväysten vuosilukujen erotuksen. </li>
    <li> Metodin tarvitsee toimia ainoastaan siten, että parametriksi annettava päivämäärä on aiempi kuin se päivämäärä jolle metodia kutsutaan. </li>
  </ul>
  <p>Seuraava pääohjelma demonstroi metodin käyttöä:</p>
  <pre class="sh_java">
public class Paaohjelma {
    public static void main(String[] args) {
        Paivays eka = new Paivays(24, 12, 2009);
        Paivays toka = new Paivays(1, 1, 2011);
        Paivays kolmas = new Paivays(25, 12, 2010);

        System.out.println( toka + " ja " + eka + " ero vuosissa: " + toka.erotusVuosissa(eka) );

        System.out.println( kolmas + " ja " + eka + " ero vuosissa: " + kolmas.erotusVuosissa(eka) );

        System.out.println( toka + " ja " + kolmas + " ero vuosissa: " + toka.erotusVuosissa(kolmas) );
    }
}
</pre>
  <p>Tulos näyttää seuraavalta:</p>
<pre>
1.1.2011 ja 24.12.2009 ero vuosissa: 2
25.12.2010 ja 24.12.2009 ero vuosissa: 1
1.1.2011 ja 25.12.2010 ero vuosissa: 1
</pre>
  <h4 class="req">Tarkennettu versio</h4>
  <p>Vuosien laskenta ei edellisessä versiossa ollut vielä kovin tarkkaa. Esim. 1.1.2011 ja 25.12.2010 välillä ilmoitettiin olevan vuoden ero. <b>Tarkennetaan metodin toiminta sellaiseksi, että se osaa laskea vuodet kunnolla. Laske erotukseen mukaan vain täydet vuodet.</b> Eli vaikka päiväysten ero olisi 1 vuosi ja 364 päivää, ilmoittaa metodi eroksi vuoden.</p>
  <p> Metodin tämänkin version tarvitsee toimia ainoastaan siten, että parametriksi annettava päivämäärä on aiempi kuin se päivämäärä jolle metodia kutsutaan. </p>
  <p>Edellisen esimerkin tulos on nyt:</p>
<pre>
1.1.2011 ja 24.12.2009 ero vuosissa: 1
25.12.2010 ja 24.12.2009 ero vuosissa: 1
1.1.2011 ja 25.12.2010 ero vuosissa: 0
</pre>
  <h4>Ja lopullinen versio</h4>
  <p>Laitetaan metodi toimimaan samoin riippumatta onko parametrina annettava päiväys myöhempi vai aiempi kuin päiväys mille metodia kutsutaan. Esimerkkipääohjelma:</p>
  <pre class="sh_java">
public class Paaohjelma {
    public static void main(String[] args) {
        Paivays eka = new Paivays(24, 12, 2009);
        Paivays toka = new Paivays(1, 1, 2011);
        Paivays kolmas = new Paivays(25, 12, 2010);

        System.out.println( eka + " ja " + toka + " ero vuosissa: " + toka.erotusVuosissa(eka) );
        System.out.println( toka + " ja " + eka + " ero vuosissa: " + eka.erotusVuosissa(toka) );
        System.out.println( eka + " ja " + kolmas + " ero vuosissa: " + kolmas.erotusVuosissa(eka) );
        System.out.println( kolmas + " ja " + eka + " ero vuosissa: " + eka.erotusVuosissa(kolmas) );
        System.out.println( kolmas + " ja " + toka + " ero vuosissa: " + toka.erotusVuosissa(kolmas) );
        System.out.println( toka + " ja " + kolmas + " ero vuosissa: " + kolmas.erotusVuosissa(toka) );
    }
}
</pre>
  <pre>
24.12.2009 ja 1.1.2011 ero vuosissa: 1
1.1.2011 ja 24.12.2009 ero vuosissa: 1
24.12.2009 ja 25.12.2010 ero vuosissa: 1
25.12.2010 ja 24.12.2009 ero vuosissa: 1
1.1.2011 ja 25.12.2010 ero vuosissa: 0
25.12.2010 ja 1.1.2011 ero vuosissa: 0
</pre>
</div>
<div class="tehtava">
<h3>Luokan Henkilö muokkaaminen</h3>
  <h4 class="req">Iän laskeminen syntymäpäivän perusteella</h4>
  <p>Luvussa 24.9. lisättiin henkilölle oliomuuttujaksi syntymäpäivän kertova Paivays-olio. Samalla todettiin, että oliomuuttuja <code>ika</code> kannattaa poistaa sillä iän pystyy laskemaan päiväyksen ja syntymäpäivän avulla. </p>
  <p>Toteuta metodi <code>ika</code> joka palauttaa henkilön iän.</p>
  <p><b>Huom:</b> edellisessä tehtävässä lisättiin luokalle <code>Paivays</code> metodi <code>public int erotusVuosissa(Paivays verrattava)</code>. Kannattaa kopioida metodi tässä tehtävässä olevaan luokkaan, se helpottaa tehtävän tekemistä oleellisesti!</p>
  <pre class="sh_java">
import java.util.Calendar;

public class Henkilo {
    private String nimi;
    private Paivays syntymaPaiva;

    public Henkilo(String nimi, int pp, int kk, int vv) {
        this.nimi = nimi;
        this.syntymaPaiva = new Paivays(pp, kk, vv);
    }

    public int ika() {
        // laske henkilön ikä syntymäpäivän ja tämän päivän perusteella
        // tämä päivä saadaan selville seuraavasti
        // Calendar.getInstance().get(Calendar.DATE);
        // Calendar.getInstance().get(Calendar.MONTH) + 1; // tammikuun numero on 0 joten lisätään 1
        // Calendar.getInstance().get(Calendar.YEAR);
    }

    public String getNimi() {
        return this.nimi;
    }

    public String toString() {
        return this.nimi +", syntynyt "+ this.syntymaPaiva;
    }
}
</pre>
  <p>Voit testata Henkilöä seuraavalla pääohjelmalla. Lisää myös itsesi ohjelmaan ja varmista että ikäsi tulostuu oikein.</p>
  <pre class="sh_java">
public class Main {
    public static void main(String[] args) {
        Henkilo pekka = new Henkilo("Pekka", 15, 2, 1993);
        Henkilo antti = new Henkilo("Antti", 1, 3, 1955);

        System.out.println( antti.getNimi() + " ikä " + antti.ika() + " vuotta");
        System.out.println( pekka.getNimi() + " ikä " + pekka.ika() + " vuotta");
    }
}
</pre>
  <p>Tulostus:</p>
  <pre>
Antti ikä 57 vuotta
Pekka ikä 20 vuotta
</pre>
<h4 class="req">Iän vertailu syntymäpäivien perusteella</h4>
  <p>Tee henkilölle metodi jonka avulla se vertaa ikäänsä parametrina annettuun henkilöön. Jos henkilö on vanhempi eli syntynyt aiemmin, palauttaa metodi true ja muuten false.</p>
  <pre class="sh_java">
public class Henkilo {
    // ...

    public boolean vanhempiKuin(Henkilo verrattava) {
        // vertaa henklöiden ikiä käyttäen henkilöiden syntymäpäivää
    }
}
</pre>
  <p>Ja testaa laajennettua Henkilö-luokkaa esim. seuraavasti:</p>
  <pre class="sh_java">
public class Main {
    public static void main(String[] args) {
        Henkilo pekka = new Henkilo("Pekka", 15, 2, 1983);
        Henkilo martin = new Henkilo("Martin", 1, 3, 1983);

        System.out.println( martin.getNimi() + " vanhempi kuin " +  pekka.getNimi() + ": "+ martin.vanhempiKuin(pekka) );
        System.out.println( pekka.getNimi() + " vanhempi kuin " +  martin.getNimi() + ": "+ pekka.vanhempiKuin(martin) );
    }
}
</pre>
  <p>Tulostus:</p>
<pre>
Martin vanhempi kuin Pekka: false
Pekka vanhempi kuin Martin: true
</pre>
  <h4>Uusia konstruktoreja</h4>
  <p>Tee Henkilo-luokalle kaksi uutta konstruktoria:</p>
  <ul>
    <li><code>public Henkilo(String nimi, Paivays syntymapaiva)</code> - jossa konstruktori käyttää annettua Paivays-oliota syntymäpäivänä</li>
    <li><code>public Henkilo(String nimi)</code> - jossa konstruktori määrittää syntymäpäiväksi tämänhetkisen päivän</li>
  </ul>
  <p>Testaa uusia konstruktoreja esim. seuraavasti:</p>
  <pre class="sh_java">
public class Main {
      public static void main(String[] args) {
      Henkilo pekka = new Henkilo("Pekka", new Paivays(15, 2, 1983));
      Henkilo sepe = new Henkilo("Sepe");

      System.out.println( pekka );
      System.out.println( sepe );
    }
}
</pre>
  <p>Esimerkkitulostus:</p>
  <pre>
Pekka, syntynyt 15.2.1983
Sepe, syntynyt 9.2.2012
</pre>
  <p><b>Huom:</b> jälkimmäinen rivi riippuu päivämäärästä, jolloin koodi ajetaan!</p>
</div>
</div>
</div>
</section>




<section class="viikkoraja" id="6">
  <div class="viikkoraja">Viikko 6</div>
  <div class="viikkoraja-mooc" id="Viikko 6" deadline="avautuu kun 85 %  5. viikosta tehty" data-first-chapter-index="23" data-first-exercise-index="94" data-first-week-index="6" data-first-chapter-index-mooc="23" data-first-exercise-index-mooc="94" data-first-week-index-mooc="6" tekija="Arto Vihavainen, Matti Luukkainen">
<h2>Nopea kertaus</h2>
<p>Aloitetaan viikko muutamalla viime viikon tärkeimpiä teemoja kertaavalla tehtävällä. Kertaa tarvittaessa luku 24.10 ennen tehtävää 94 ja luvut 24.6 ja 24.12 ennen tehtävää 95.</p>
<p><strong>MUISTUTUS</strong> kun lisäät ohjelmaasi ArrayList:in, Scanner:in tai Random:in ei Java tunnista luokkaa ellet "importoi" sitä lisäämällä ohjelmatiedoston alkuun:</p>
<pre class="sh_java">
import java.util.ArrayList;    // importoi ArrayListin
import java.util.*;            // importoi kaikki java.util:sissa olevat työkalut, mm. ArrayListin, Scannerin ja Randomin
  </pre>
<div class="tehtavat" id="viikko6">
  <div class="tehtava">
  <h3>Puhelinmuistio</h3>
  <p>Tehtävässä tehdään yksinkertainen puhelinmuistio. </p>
  <h4>Henkilö</h4>
  <p>Tee ensin luokka <code>Henkilo</code> Luokan pitää toimia seuraavan esimerkin osoittamalla tavalla:</p>
  <pre class="sh_java">
public static void main(String[] args) {
    Henkilo pekka = new Henkilo("Pekka Mikkola", "040-123123");

    System.out.println( pekka.haeNimi() );
    System.out.println( pekka.haeNumero() );

    System.out.println( pekka );

    pekka.vaihdaNumeroa("050-333444");
    System.out.println( pekka );
}
  </pre>
  <p> Tulostuu: </p>
<pre>
Pekka Mikkola
040-123123
Pekka Mikkola  puh: 040-123123
Pekka Mikkola  puh: 050-333444
  </pre>
  <p>Tee siis luokalle</p>
  <ul>
    <li> metodi <code>public String toString()</code>, joka palauttaa henkilön merkkijonoesityksen (yo. esimerkin tapaan muotoiltuna)</li>
    <li> konstruktori, jolla asetetaan henkilölle nimi ja puhelinnumero</li>
    <li> <code>public String haeNimi()</code>, joka palauttaa nimen</li>
    <li> <code>public String haeNumero()</code>, joka palauttaa puhelinnumeron</li>
    <li> metodi <code>public void vaihdaNumeroa(String uusiNumero)</code>, joka muuttaa henkilön puhelinnumeroa</li>
  </ul>
  <h4>Henkilöiden lisäys puhelinmuistioon</h4>
  <p>Tee luokka <code>Puhelinmuistio</code> joka tallettaa sisällään olevaan ArrayListiin <code>Henkilo</code>-olioita. Tässä vaiheessa luokalle tehdään seuraavat metodit:</p>
  <ul>
    <li> <code>public void lisaa(String nimi, String numero)</code> luo <code>Henkilo</code>-olion ja lisää sen puhelinmuistion ArrayListiin.</li>
    <li><code>public void tulostaKaikki()</code>, tulostaa puhelinmuistion sisällön</li>
  </ul>
  <p>Esimerkki muistion toiminnasta:</p>
  <pre class="sh_java">
public static void main(String[] args) {
    Puhelinmuistio muistio = new Puhelinmuistio();

    muistio.lisaa("Pekka Mikkola", "040-123123");
    muistio.lisaa("Antti Laaksonen", "045-456123");
    muistio.lisaa("Juhana Laurinharju", "050-222333");

    muistio.tulostaKaikki();
}
  </pre>
  <p>Ohjelman tulostus oikein toteutetuilla luokilla on:</p>
<pre>
Pekka Mikkola  puh: 040-123123
Antti Laaksonen  puh: 045-456123
Juhana Laurinharju  puh: 050-222333
  </pre>
  <h4>Numerojen haku muistiosta</h4>
  <p>Tehdään puhelinmuistiolle metodi <code>public String haeNumero(String nimi)</code>, joka  palauttaa parametrina annetun henkilön numeron. Jos henkilö ei ole muistiossa, palautetaan merkkijono "numero ei tiedossa". Esimerkki metodin toiminnasta:</p>
  <pre class="sh_java">
public static void main(String[] args) {
    Puhelinmuistio muistio = new Puhelinmuistio();
    muistio.lisaa("Pekka Mikkola", "040-123123");
    muistio.lisaa("Antti Laaksonen", "045-456123");
    muistio.lisaa("Juhana Laurinharju", "050-222333");

    String numero = muistio.haeNumero("Pekka Mikkola");
    System.out.println( numero );

    numero = muistio.haeNumero("Martti Tienari");
    System.out.println( numero );
}
    </pre>
  <p>Tulostuu:</p>
  <pre>
040-123123
numero ei tiedossa
</pre>
</div>
<div class="tehtava">
  <h3>Raha</h3>
  <p>Lyyrakortti-tehtävässä käytimme rahamäärän tallettamiseen double-tyyppistä oliomuuttujaa. Todellisissa sovelluksissa näin ei kannata tehdä, sillä kuten jo olemme nähneet, doubleilla laskenta ei ole tarkkaa. Onkin järkevämpää toteuttaa rahamäärän käsittely oman luokkansa avulla. Seuraavassa on luokan runko:</p>
  <pre class="sh_java">
public class Raha {

    private final int euroa;
    private final int senttia;

    public Raha(int euroa, int senttia) {
        this.euroa = euroa;
        this.senttia = senttia;
    }

    public int eurot(){
      return euroa;
    }

    public int sentit(){
        return senttia;
    }

    public String toString() {
        String nolla = "";
        if (senttia &lt;= 10) {
            nolla = "0";
        }

        return euroa + "." + nolla + senttia + "e";
    }
}
</pre>
  <p>Määrittelyssä pistää silmään oliomuuttujien määrittelyn yhteydessä käytetty sana <code>final</code>, tällä saadaan aikaan se, että oliomuuttujien arvoa ei pystytä muuttamaan sen jälkeen kun ne on konstruktorissa asetettu. Raha-luokan oliot ovatkin muuttumattomia eli <em>immutaabeleita</em>, eli jos halutaan esim. kasvattaa rahamäärää, on luotava uusi olio, joka kuvaa kasvatettua rahasummaa.</p>
  <p>Luomme seuraavassa muutaman operaation rahojen käsittelyyn.</p>
  <h4>Plus</h4>
  <p>Tee ensin metodi <code>public Raha plus(Raha lisattava)</code>, joka palauttaa uuden raha-olion, joka on arvoltaan yhtä suuri kuin se olio jolle metodia kutsuttiin ja parametrina oleva olio yhteensä.</p>
  <p>Metodin runko on seuraavanlainen:</p>
  <pre class="sh_java">
public Raha plus(Raha lisattava) {
    Raha uusi = new Raha(...); // luodaan uusi Raha-olio jolla on oikea arvo

    // palautetaan uusi Raha-olio
    return uusi;
}
</pre>
  <p>Seuraavassa esimerkkejä metodin toiminnasta</p>
  <pre class="sh_java">
Raha a = new Raha(10,0);
Raha b = new Raha(5,0);

Raha c = a.plus(b);

System.out.println(a);  // 10.00e
System.out.println(b);  // 5.00e
System.out.println(c);  // 15.00e

a = a.plus(c);          // HUOM: tässä syntyy uusi Raha-olio, joka laitataan "a:n langan päähän"
//       vanha a:n langan päässä ollut 10 euroa häviää ja Javan roskien kerääjä korjaa sen pois

System.out.println(a);  // 25.00e
System.out.println(b);  // 5.00e
System.out.println(c);  // 15.00e
</pre>
  <h4>Vähemmän</h4>
  <p>Tee metodi <code>public boolean vahemman(Raha verrattava)</code>, joka palauttaa true jos raha-olio jolle metodia kutsutaan on arvoltaan pienempi kuin raha-olio, joka on metodin parametrina.</p>
  <pre class="sh_java">
Raha a = new Raha(10,0);
Raha b = new Raha(3,0);
Raha c = new Raha(5,0);

System.out.println(a.vahemman(b));  // false
System.out.println(b.vahemman(c));  // true

</pre>
  <h4>Miinus</h4>
  <p>Tee metodi <code>public Raha miinus(Raha vahentaja)</code>, joka palauttaa uuden raha-olion, jonka arvoksi tulee sen olion jolle metodia kutsuttiin ja parametrina olevan olion arvojen erotus. Jos erotus olisi negatiivinen, tulee luotavan raha-olion arvoksi 0.</p>
  <p>Seuraavassa esimerkkejä metodin toiminnasta</p>
  <pre class="sh_java">
Raha a = new Raha(10,0);
Raha b = new Raha(3,50);

Raha c = a.miinus(b);

System.out.println(a);  // 10.00e
System.out.println(b);  // 3.50e
System.out.println(c);  // 6.50e

c = c.miinus(a);        // HUOM: tässä syntyy uusi Raha-olio, joka laitataan "c:n langan päähän"
//       vanha c:n langan päässä ollut 6.5 euroa häviää ja Javan roskien kerääjä korjaa sen pois

System.out.println(a);  // 10.00e
System.out.println(b);  // 3.50e
System.out.println(c);  // 0.00e
</pre>
</div>
</div>
<h3>Merkkijonot ovat immutaabeleja</h3>
<p>Javan String-oliot ovat Raha-luokan olioiden tyyliin muuttumattomia, eli immutaabelena. Jos esim. merkkijonon perään katenoidaan eli liitetään +-operaatiolla uusi merkkijono, ei alkuperäistä merkkijonoa pidennetä vaan syntyy uusi merkkijono-olio:</p>
<pre class="sh_java">
String jono = "koe";
jono + "häntä";

System.out.println( jono );  // koe
</pre>
<p>Merkkijonoa ei siis voi muuttaa, mutta voimme ottaa katenoimalla syntyvän uuden merkkijonon talteen vanhaan muuttujaan:
<pre class="sh_java">
String jono = "koe";
jono = jono + "häntä";   // tai jono += "häntä";

System.out.println( jono );  // koehäntä
  </pre>
<p>Nyt siis muuttuja <code>jono</code> viittaa <em>uuteen</em> merkkijono-olioon, joka luotiin yhdistämällä muuttujan aiemmin viittaama merkkijono "koe" ja merkkijono "häntä". Merkkijono-olioon "koe" ei enää viitata.</p>
<h2 id="taulukko">Taulukko</h2>
<p>Olemme käyttäneet kurssin aikana lukemattomia kertoja ArrayList:ejä erilaisten olioiden säilömiseen. ArrayList on helppokäyttöinen sillä se tarjoaa paljon valmiita työvälineitä jotka helpottavat ohjelmoijan elämää: muun muassa automaattisen listan kasvatuksen, jonka ansioista listalta ei lopu tila kesken (ellei lista kasva niin suureksi että se käyttää loppuun ohjelmalle varatun muistimäärän).</p>
<p>ArrayListin helppokäyttöisyydesta huolimatta  ohjelmissa on joskus tarvetta ArrayListin esi-isälle eli <em>taulukolle</em>.</p>
<p><em>Taulukko</em> on olio, joka voidaan käsittää eräänlaisena järjestettynä <em>lokerikkona</em> arvoille. Taulukon <em>pituus</em> tai <em>koko</em> on lokerikon paikkojen lukumäärä, eli kuinka monta arvoa taulukkoon voi laittaa. Taulukon arvoja kutsutaan taulukon <em>alkioiksi</em>. ArrayLististä poiketen taulukon kokoa (eli sen alkioiden määrää) ei voi muuttaa, taulukon kasvattaminen vaatii siis aina uuden taulukon luomista ja vanhassa olevien alkioiden kopiointia uuteen.</p>
<p>Taulukon voi luoda kahdella eri tavalla. Tutustutaan ensin tapaan jossa taulukolle annetaan sisältö luomisen yhteydessä. Kolmen alkion kokonaislukutyyppinen taulukko määritellään seuraavasti:
<pre class="sh_java">
int[] luvut = {100, 1, 42};
</pre>
<p>Taulukko-olion tyyppi merkitään <code>int[]</code>, joka tarkoittaa taulukkoa, jonka alkiot ovat tyyppiä <code>int</code>. Taulukko-olion nimi on esimerkissä <code>luvut</code> ja se sisältää kolme lukua <code>{100, 1, 42}</code>.  Taulukko alustetaan lohkolla, jossa taulukkoon asetettavat arvot on esitelty pilkulla eriteltyinä. </p>
<p>Taulukon arvot voivat olla mitä tahansa aikaisemmin nähtyjä muuttujatyyppejä. Alla on esitelty ensin merkkijonoja sisältävä taulukko, jonka jälkeen esitellään liukulukuja sisältävä taulukko.</p>
<pre class="sh_java">
String[] merkkijonotaulukko = {"Matti P.", "Matti V."};
double[] liukulukutaulukko = {1.20, 3.14, 100.0, 0.6666666667};
</pre>
<p>Taulukon alkioihin viitataan <em>indeksillä</em>, joka on kokonaisluku. Indeksi kertoo alkion paikan taulukossa. Taulukon ensimmäinen alkio on paikassa nolla, seuraava kohdassa yksi ja niin edelleen. Taulukon tietyssä indeksissä olevaa arvoa tutkittaessa indeksi annetaan taulukko-olion nimen perään hakasulkeiden sisällä.</p>
<pre class="sh_java">
// indeksi       0   1    2    3   4   5     6     7
int[] luvut = {100,  1,  42,  23,  1,  1, 3200, 3201};

System.out.println(luvut[0]);  // tulostaa luvun taulukon indeksistä 0, eli luvun 100
System.out.println(luvut[2]);  // tulostaa luvun taulukon indeksistä 2, eli luvun 42
</pre>
<p>Yllä olevan taulukon koko (eli pituus) on 8.</p>
<p><em>Huomaat todennäköisesti että ArrayListin metodi <code>get</code> käyttäytyy hyvin samalla tavalla kuin taulukon tietystä indeksistä haku. Taulukon kohdalla vain syntaksi, eli merkintätapa, on erilainen</em>.</p>
<p>Yksittäisen arvon asettaminen taulukon tiettyyn paikkaan tapahtuu kuten arvon asetus tavalliseen muuttujaan, mutta taulukkoon asetettaessa paikka eli indeksi tulee kertoa. Indeksi kerrotaan hakasulkeiden sisällä.</p>
<pre class="sh_java">
int[] luvut = {100,1,42};

luvut[0] = 1;    // asetetaan luku 1 indeksiin 0
luvut[1] = 101;  // asetetaan luku 101 indeksiin 1

// luvut-taulukko on nyt {1,101,42}
</pre>
<p>Jos indeksillä osoitetaan taulukon ohi, eli alkioon jota ei ole olemassa, niin saadaan virheilmoitus <em>ArrayIndexOutOfBoundsException</em>, joka kertoo että indeksiä johon osoitimme ei ole olemassa.  Taulukon ohi, eli indeksiin joka on pienempi kuin 0 tai suurempi tai yhtäsuuri kuin taulukon koko ei siis saa viitata.</p>
<p>Huomaamme, että taulukko on selvästi sukua ArrayList:ille. Aivan kuten listoilla, myös taulukossa alkiot ovat tietyssä paikassa!</p>
<h3>Taulukon läpikäynti</h3>
<p>Taulukko-olion koon saa selville kirjoittamalla koodiin <code>taulukko.length</code>, huomaa että ilmauksessa ei tule käyttää sulkuja eli <code>taulukko.length()</code> ei toimi!</p>
<p>Taulukon alkioiden läpikäynti on helppo toteuttaa <code>while</code>-komennon avulla:</p>
<pre class="sh_java">
int[] luvut = {1, 8, 10, 3, 5};

int i = 0;
while (i &lt; luvut.length ) {
    System.out.println(luvut[i]);
    i++;
}
  </pre>
<p>Esimerkissä käydään muuttujan <code>i</code> avulla läpi indeksit 0, 1, 2, 3, ja 4, ja tulostetaan taulukon kussakin indeksissä olevan muuttujan arvo. Ensin siis tulostuu <code>luvut[0]</code>, sitten <code>luvut[1]</code> jne. Muuttujan <code>i</code> kasvatus loppuu kun koko taulukko on käyty läpi, eli kun sen arvo on yhtäsuuri kuin taulukon pituus.</p>
<p>Taulukon läpikäynnissä ei ole aina todellista tarvetta taulukon indeksien luetteluun, vaan ainoa kiinnostava asia ovat taulukon arvot. Tällöin voidaan käyttää aiemmin tutuksi tullutta for-each-rakennetta arvojen läpikäyntiin. Nyt toistolauseen rungossa annetaan vain muuttujan nimi, johon kukin taulukon arvo asetetaan vuorollaan, ja taulukon nimi kaksoispisteellä erotettuna.</p>
<pre class="sh_java">
    int[] luvut = {1,8,10,3,5};

for (int luku : luvut) {
    System.out.println(luku);
  }
</pre>
<pre class="sh_java">
String[] nimet = {"Juhana L.", "Matti P.", "Matti L.", "Pekka M."};

    for (String nimi : nimet) {
        System.out.println(nimi);
    }
}
</pre>
<p><strong>Huom:</strong> for-each-tyylisellä läpikäynnillä taulukon alkioihin ei voi asettaa arvoja! Seuraavaksi nähtävällä for-lauseen toisella muodolla sekin onnistuu.</p>
<h3>for-komennon toinen muoto</h3>
<p>Olemme toistaiseksi käyttäneet toistolauseissa whileä tai for-lauseen ns. "for-each"-muotoa. Toistolauseesta for on olemassa myös toinen muoto, joka on kätevä erityisesti taulukoiden käsittelyn yhteydessä. Seuraavassa tulostetaan for-toistolauseen avulla luvut 0, 1 ja 2:</p>
<pre class="sh_java">
for (int i = 0; i &lt; 3; i++ ) {
    System.out.println(i);
}
</pre>
<p>Esimerkin for toimii <em>täsmälleen</em> samalla tavalla kuin alla oleva while:</p>
<pre class="sh_java">
int i = 0;  // toistossa käytettävän muuttujan alustus
while ( i &lt; 3 ) {  // toistoehto
    System.out.println(i);
    i++;   // toistossa käytettävän muuttujan päivitys
}
</pre>
<p>for-komento, kuten yllä esitelty <code>for (int i = 0; i &lt; 3; i++ )</code> sisältää kolme osaa: <em>looppimuuttujien alustus; toistoehto; looppimuuttujien päivitys</em>: </p>
<ul>
  <li>Ensimmäisessä osassa alustetaan toistolauseessa käytettävät muuttujat. Yllä olevassa esimerkissä alustimme muuttujan <code>i</code> lauseella <code>int i=0</code>. Ensimmäinen osa suoritetaan vain kerran, juuri for:in suorituksen alussa.</li>
  <li>Toisessa osassa määritellään toistoehto, joka määrittelee miten kauan for:in yhteydessä olevassa koodilohkossa olevaa koodia suoritetaan. Esimerkissämme toistoehto oli <code>i &lt; 3</code>. Toistoehdon voimassaolo tarkastetaan <em>ennen jokaista for:in toistokertaa</em>. Toistoehto toimii täsmälleen samoin kuin while:n toistoehto.</li>
  <li>Kolmas osa, joka esimerkissämme on <code>i++</code> suoritetaan aina kertaalleen forin koodilohkon suorituksen jälkeen.</li>
</ul>
<p><em>for</em> on hieman <em>while</em>:ä selkeämpi tapa toteuttaa toistoja joissa toistojen määrä perustuu esim. laskurin kasvatukseen. Taulukkojen läpikäynnissä tilanne on yleensä juuri tämä. Seuraavassa tulostetaan taulukon <code>luvut</code> sisältö for:illa</p>
<pre class="sh_java">
int[] luvut = {1, 3, 5, 9, 17, 31, 57, 105};

for(int i = 3; i &lt; 7; i++) {
    System.out.println(luvut[i]);
}
</pre>
<p>Forilla voidaan aloittaa läpikäynti luonnollisesti muualtakin kuin nollasta ja läpikäynti voi edetä "ylhäältä alas". Esimerkiksi taulukon paikoissa  6, 5, 4, ja 3 olevat alkiot voidaan tulostaa seuraavasti:</p>
<pre class="sh_java">
int[] luvut = {1, 3, 5, 9, 17, 31, 57, 105};

for(int i = 6; i&gt;2 ; i--) {
    System.out.println(luvut[i]);
}
</pre>
<h3>for ja taulukon pituus</h3>
<p>Kaikkien taulukon alkioiden läpikäynti for:in avulla onnistuu seuraavasti:</p>
<pre class="sh_java">
int[] luvut = {1, 8, 10, 3, 5};

for (int i = 0; i &lt; luvut.length; i++ ) {
    System.out.println(luvut[i]);
}
</pre>
<p>Huomaa, että toistoehdossa <code>i &lt; luvut.length</code> verrataan looppimuuttujan arvoa taulukolta kysyttyyn pituuteen. Ehtoa ei kannata missään tapauksessa "kovakoodata" tyyliin <code>i &lt; 5</code> sillä yleensä taulukon pituudesta ei ole etukäteen varmuutta.</p>
<h3>Taulukko parametrina</h3>
<p>Taulukkoja voidaan käyttää metodin parametrina aivan kuten muitakin olioita. Huomaa, että kuten kaikkien olioiden tapauksessa, metodi saa parametrina viitteen taulukkoon, eli kaikki metodissa tapahtuvat taulukon sisältöön vaikuttavat muutokset näkyvät myös pääohjelmassa.</p>
<pre class="sh_java">
public static void listaaAlkiot(int[] kokonaislukuTaulukko) {

    System.out.println("taulukon alkiot ovat: ");
    for( int luku : kokonaislukuTaulukko) {
        System.out.print(luku + " ");
    }

    System.out.println("");
}

public static void  main(String[] args) {
    int[] luvut = { 1, 2, 3, 4, 5 };
    listaaAlkiot(luvut);
}
</pre>
<p>Kuten jo tiedämme, parametrin nimi metodin sisällä voi olla aivan vapaasti valittu, nimen ei tarvitse missään tapauksessa olla sama kuin kutsuvassa. Edellä taulukkoa kutsutaan metodin sisällä nimellä <code>kokonaislukuTaulukko</code>, metodin kutsuja taas näkee saman taulukon <code>luvut</code>-nimisenä.</p>

<!-- CAST61-->

<a href="http://www.youtube.com/watch?feature=player_embedded&v=mpfbaukh-4Y" height="300" target="_blank"><img src=" https://www.cs.helsinki.fi/group/java/k13/ohpe/img/youtube.jpg"/></a>

<!--
<p><iframe allowfullscreen="" frameborder="0"  height="450" width="700" src="http://www.youtube.com/embed/mpfbaukh-4Y"></iframe></p>
-->

<div class="tehtavat">
  <div class="tehtava">
  <h3 class="req">Taulukon lukujen summa</h3>
  <p>Tee metodi <code>public static int laskeTaulukonLukujenSumma(int[] taulukko)</code>, joka palauttaa taulukossa olevien lukujen summan.</p>
  <p>Ohjelman runko on seuraava:</p>
  <pre class="sh_java">
public class Main {
    public static void main(String[] args) {
        // Tässä voit testata metodia
        int[] taulukko = {5, 1, 3, 4, 2};
        System.out.println(laskeTaulukonLukujenSumma(taulukko));
    }

    public static int laskeTaulukonLukujenSumma(int[] taulukko) {
        // Kirjoita koodia tänne
        return 0;
    }
}
</pre>
  <p>Ohjelman tulostus on seuraava:</p>
<pre>
15
</pre>
  <p><b>Huom:</b> tämän tehtävän metodi samoin kuin muutamien seuraavien tehtävien taulukkoa käsittelevät metodit ovat viikkojen 2 ja 3 tapaan <code>static</code> eli staattisia metodeja. Karkeasti ottaen tämä johtuu siitä, että metodi ei liity mihinkään olioon, vaan saa kaiken datan jota se käyttää eli tässä tapauksessa taulukon, parametrina. Luvussa 28 palaamme tarkemmin aiheeseen staattiset vs. olioihin liittyvät metodit.</p>
  </div>
  <div class="tehtava">
  <h3 class="req">Tyylikäs tulostus</h3>
  <p>Tee metodi <code>public static void tulostaTyylikkaasti(int[] taulukko)</code>, joka tulostaa taulukossa olevat luvut tyylikkäästi. Lukujen väliin tulee pilkku ja välilyönti. Viimeisen luvun jälkeen ei  pilkkua tule.</p>
  <p>Ohjelman runko on seuraava:</p>
  <pre class="sh_java">
public class Main {
    public static void main(String[] args) {
        // Tässä voit testata metodia
        int[] taulukko = {5, 1, 3, 4, 2};
        tulostaTyylikkaasti(taulukko);
    }

    public static void tulostaTyylikkaasti(int[] taulukko) {
        // Kirjoita koodia tänne
    }
}
</pre>
  <p>Ohjelman tulostus on seuraava:</p>
  <pre>
  5, 1, 3, 4, 2
</pre>
</div>
</div>
<h3>Uuden taulukon luonti</h3>
<p>Jos taulukon koko ei ohjelmassa ole aina sama, eli se riippuu esim. käyttäjän syötteestä, ei äsken esitelty taulukon luontitapa kelpaa. Taulukko on mahdollista luoda myös siten, että sen koko määritellään muuttujan avulla:</p>
<pre class="sh_java">
int alkioita = 99;
int[] taulukko = new int[alkioita];
</pre>
<p>Yllä luodaan int-tyyppinen taulukko, jossa on 99 paikkaa. Tällä vaihtoehtoisella tavalla taulukon luominen tapahtuu siis kuten muidenkin olioiden luominen, eli <code>new</code>-komennolla. Komentoa <code>new</code> seuraa taulukon sisältämien muuttujien tyyppi, ja hakasuluissa taulukon koko.</p>
<pre class="sh_java">
int alkioita = 99;
int[] taulukko = new int[alkioita]; //luodaan muuttujan alkioita sisältämän arvon kokoinen taulukko

if(taulukko.length == alkioita) {
    System.out.println("Taulukon pituus on " + alkioita);
} else {
    System.out.println("Jotain epätodellista tapahtui. Taulukon pituus on eri kuin " + alkioita);
}
</pre>
<p>Seuraavassa esimerkissä on ohjelma, joka kysyy käyttäjältä lukujen määrän ja joukon lukuja. Tämän jälkeen ohjelma tulostaa luvut uudestaan samassa järjestyksessä. Käyttäjän antamat luvut tallennetaan taulukkoon.</p>
<pre class="sh_java">
System.out.print("Kuinka monta lukua? ");
int lukuja = Integer.parseInt(lukija.nextLine());

int[] luvut = new int[lukuja];

System.out.println("Anna luvut:");
for(int i = 0; i &lt; lukuja; i++) {
    luvut[i] = Integer.parseInt(lukija.nextLine());
}

System.out.println("Luvut uudestaan:");
for(int i = 0; i &lt; lukuja; i++) {
    System.out.println(luvut[i]);
}
</pre>
<p>Eräs ohjelman suorituskerta voisi olla seuraavanlainen:</p>
<pre>
Kuinka monta lukua? <span class="red">4</span>
Anna luvut:
<span class="red">4</span>
<span class="red">8</span>
<span class="red">2</span>
<span class="red">1</span>
Luvut uudestaan:
4
8
2
1
</pre>
<h3 id="muita_palautustyyppeja">Taulukko paluuarvona</h3>
<p>Koska metodit voivat palauttaa olioita, voivat ne palauttaa myös taulukkoja. Eräs merkkijonotaulukon palauttava metodi on seuraavannäköinen -- huomaa että taulukkoihin voi aivan hyvin siis laittaa myös olioita. </p>
<pre class="sh_java">
public static String[] annaMerkkijonoTaulukko() {
    String[] opet = new String[3];

    opet[0] = "Bonus";
    opet[1] = "Ihq";
    opet[2] = "Lennon";

    return opet;
}

public static void main(String[] args){
    String[] opettajat = annaMerkkijonoTaulukko();

    for ( String opettaja : opettajat){
        System.out.println( opettaja );
    }
}
</pre>
<div class="tehtavat">
  <div class="tehtava">
  <h3 class="req">Taulukon kopiointi ja kääntaminen</h3>
  <h4 class="req">Kopiointi</h4>
  <p>Tee metodi <code>public static int[] kopioi(int[] taulukko)</code> joka luo kopion parametrina saadusta taulukosta. <strong>Vihje:</strong> koska metodin on luotava taulukosta kopio, tulee metodin sisällä luoda uusi taulukko ja kopioida vanhan taulukon sisältö uudelle taulukolle alkio alkiolta.</p>
  <p>Seuraavassa esimerkki metodin käytöstä (koodissa myös Arrays-luokan tarjoama kätevä apuväline taulukon sisällön tulostamiseen):</p>
  <pre class="sh_java">
public static void main(String[] args) {
    int[] alkuperainen = {1, 2, 3, 4};
    int[] kopio = kopioi(alkuperainen);

    // muutetaan kopioa
    kopio[0] = 99;

    // tulostetaan molemmat
    System.out.println( "alkup: " + Arrays.toString(alkuperainen));
    System.out.println( "kopio: " + Arrays.toString(kopio));
  }
</pre>
  <p>Kuten tulostuksesta huomaa, ei kopioon tehty muutos vaikuta alkuperäiseen:</p>
<pre>
alkup: [1, 2, 3, 4]
kopio: [99, 2, 3, 4]
</pre>
  <h4 class="req">Kääntäminen</h4>
  <p>Tee metodi <code>public static int[] kaanna(int[] taulukko)</code> joka luo käänteisessä järjestyksessä olevan kopion parametrinaan saamastaan taulukosta.</p>
  <p>Eli jos parametrina on taulukko jossa esim. luvut <em>5, 6, 7</em> palauttaa metodi <em>uuden taulukon</em> jonka sisältönä luvut <em>7, 6, 5</em>. Parametrina oleva taulukko ei saa muuttua.</p>
  <p>Seuraavassa esimerkki metodin käytöstä:</p>
  <pre class="sh_java">
public static void main(String[] args) {
    int[] alkuperainen = {1, 2, 3, 4};
    int[] kaannetty = kaanna(alkuperainen);

    // tulostetaan molemmat
    System.out.println( "alkup: " +Arrays.toString(alkuperainen));
    System.out.println( "käännetty: " +Arrays.toString(kaannetty));
}
</pre>
  <p>Tulostuksesta pitäisi selvitä, että alkuperäinen taulukko on muuttumaton:</p>
<pre>
alkup: [1, 2, 3, 4]
käännetty: [4, 3, 2, 1]
</pre>
</div>
</div>

<!-- CAST62-->

<a href="http://www.youtube.com/watch?feature=player_embedded&v=COVbFEPZGQw" height="300" target="_blank"><img src=" https://www.cs.helsinki.fi/group/java/k13/ohpe/img/youtube.jpg"/></a>

<!--
<p><iframe allowfullscreen="" frameborder="0"  height="450" width="700" src="http://www.youtube.com/embed/COVbFEPZGQw"></iframe></p>
-->

<h2 id="lohkoista">Lohkoista ja sisäkkäisistä toistolauseista</h2>
<p>Aaltosululla <code>{</code> alkavaa ja aaltosululla <code>}</code> koodia sisältävää aluetta siis sanotaan <em>lohkoksi</em>.  Kuten on jo nähty, lohkoja käytetään muun muassa ehto- ja toistolauseiden alueen rajaamisessa. <em>Tärkeä lohkon ominaisuus on se, että lohkossa määritellyt muuttujat ovat voimassa vain lohkon sisällä</em>.</p>
<p>Seuraavassa esimerkissä määritellään ehtolausekkeeseen liittyvän lohkon sisällä tekstimuuttuja <code>lohkonSisallaMaariteltyTeksti</code>, joka on olemassa vain lohkon sisällä.  Lohkossa esitellyn muuttujan tulostus lohkon ulkopuolella ei toimi!</p>
<pre class="sh_java">
int luku = 5;

if( luku == 5 ){
    String lohkonSisallaMaariteltyTeksti = "Jea!";
}

System.out.println(lohkonSisallaMaariteltyTeksti); // ei toimi!
</pre>
<p>Lohkossa voidaan toki käyttää ja muuttaa sen ulkopuolella määriteltyjä muuttujia.</p>
<pre class="sh_java">
int luku = 5;

if( luku == 5 ) {
    luku = 6;
}

System.out.println(luku); // tulostaa luvun 6
</pre>
<p>Lohkon sisällä voi olla mitä tahansa koodia. Esimerkiksi for-toistolauseen määrittelemän lohkon sisällä voi olla toinen for-toistolauseke tai vaikkapa while-toistolauseke. Tarkastellaan seuraavaa ohjelmaa:</p>
<pre class="sh_java">
for(int i = 0; i &lt; 3; i++) {
    System.out.print(i + ": ");

    for(int j = 0; j &lt; 3; j++) {
        System.out.print(j + " ");
    }

    System.out.println();
}
</pre>
<p>Ohjelman tulostus on seuraava:</p>
<pre>
0: 0 1 2
1: 0 1 2
2: 0 1 2
</pre>
<p>Eli mitä ohjelmassa tapahtuukaan? Jos ajatellaan pelkkää ulommaista for:ia, on toiminnallisuus helppo ymmärtää: </p>
<pre class="sh_java">
for(int i = 0; i &lt; 3; i++) {
    System.out.print(i + ": ");

    // sisemmäinen for

    System.out.println();
}
</pre>
<p>Eli ensin <code>i=0</code> ja tulostuu <code>0:</code> ja rivinvaihto. Tämän jälkeen i kasvaa ja tulostuu ykkönen, jne., eli ulompi for saa aikaan seuraavan:</p>
<pre>
0:
1:
2:
</pre>
<p>Myös sisempi for on helppo ymmärtää erillään. Se saa aina aikaan tulosteen <code>0 1 2</code>. Kun yhdistämme nämä kaksi, huomaamme, että sisin for suorittaa tulosteensa aina juuri ennen uloimman for:in tulostamaa rivinvaihtoa.</p>
<h3>for-toistolauseen ulkopuolella määriteltyjen muuttujien käyttö toiston ehtona</h3>
<p>Tutkitaan seuraavaa muunnosta edelliseen esimerkkiin:</p>
<pre class="sh_java">
for(int i = 0; i &lt; 3; i++) {
    System.out.print(i + ": ");

    for(int j = 0; j &lt;= i; j++) {
        System.out.print(j + " ");
    }

    System.out.println();
}
</pre>
<p>Sisemmän for:in toistojen määrä riippuukin nyt ulomman for:in muuttujan <code>i</code> arvosta. Eli kun <code>i=0</code>, tulostaa sisin looppi luvun 0, kun <code>i=1</code>, tulostaa sisempi toistolauseke 0 1, jne. Koko ohjelman tulostus on seuraava: </p>
<pre>
0: 0
1: 0 1
2: 0 1 2
</pre>
<p>Seuraava ohjelma tulostaa lukujen 1..10 kertotaulun. </p>
<pre class="sh_java">
for(int i = 1; i &lt;= 10; i++) {

    for(int j = 1; j &lt;= 10; j++) {
        System.out.print(i * j + " ");
    }

    System.out.println();
}
</pre>
<p> Tulostus näyttää seuraavalta: </p>
<pre>
1 2 3 4 5 6 7 8 9 10
2 4 6 8 10 12 14 16 18 20
3 6 9 12 15 18 21 24 27 30
4 8 12 16 20 24 28 32 36 40
5 10 15 20 25 30 35 40 45 50
6 12 18 24 30 36 42 48 54 60
7 14 21 28 35 42 49 56 63 70
8 16 24 32 40 48 56 64 72 80
9 18 27 36 45 54 63 72 81 90
10 20 30 40 50 60 70 80 90 100
</pre>
<p>Ylimmällä rivillä luvun 1 kertotaulu. Alussa <code>i=1</code> ja sisimmän loopin muuttuja <code>j</code> saa arvot 1...10. Jokaisella <code>i, j</code> arvoparilla tulostetaan niiden tulo. Eli alussa <code>i=1, j=1</code>, sitten <code>i=1, j=2</code>, ..., <code>i=1, j=10</code> seuraavaksi <code>i=2, j=1</code>, jne. </p>
<p>Kertotaulu-ohjelman voi toki pilkkoa pienempiin osiin. Voimme määritellä metodit <code>public void tulostaKertotaulunRivi(int kerroin, int montakokertaa)</code> ja <code>public void tulostaKertotaulu(int mihinAsti)</code>, jolloin ohjelman rakenne olisi esimerkiksi seuraavanlainen seuraavanlainen:</p>
<pre class="sh_java">
public class Kertotaulu {

    public void tulosta(int mihinAsti) {
        for(int i = 1; i &lt;= mihinAsti; i++) {
            tulostaKertotaulunRivi(i, mihinAsti);

            System.out.println();
        }
    }


    public void tulostaKertotaulunRivi(int kerroin, int montakokertaa) {
        for(int i = 1; i &lt;= montakokertaa; i++) {
            System.out.print(i * kerroin + " ");
        }
    }
}
</pre>
<p>Nyt kutsu <code>new Kertotaulu().tulosta(5);</code> tulostaa allaolevan kertotaulun.</p>
<pre>
1 2 3 4 5
2 4 6 8 10
3 6 9 12 15
4 8 12 16 20
5 10 15 20 25
</pre>
<div class="tehtavat">
  <div class="tehtava">
  <h3>Taulukko tähtinä</h3>
  <p>Kirjoita metodi <code>public static void tulostaTaulukkoTahtina(int[] taulukko)</code>, joka tulostaa jokaista taulukossa olevaa lukua vastaavan pituisen rivin tähtiä.</p>
  <p>Ohjelman runko on seuraava:</p>
  <pre class="sh_java">
public class Main {
    public static void main(String[] args) {
        // Tässä voit testata metodia
        int[] taulukko = {5, 1, 3, 4, 2};
        tulostaTaulukkoTahtina(taulukko);
    }

    public static void tulostaTaulukkoTahtina(int[] taulukko) {
        // Kirjoita tulostuskoodi tänne
    }
}
</pre>
  <p>Edellisen esimerkin mukaisella syötteellä ohjelman tulostus on seuraava:</p>
<pre>
*****
*
***
****
**
</pre>
  <p>Eli koska taulukon nollannessa paikassa on luku 5, tulee ensimmäiselle riville 5 tähteä. Seuraavalla 1 tähti jne.
</div>

<div class="tehtava">
  <h3>Tähtitaivas</h3>
  <p>Luodaan ohjelma tähtitaivaan tulostamiseen. Tähtitaivaan tähtien määrä kerrotaan tiheyden avulla. Esimerkiksi jos tähtitaivaan tiheys on <code>0.2</code>, on noin 20% tähtitaivaasta peitettynä tähdillä. Pääset harjoittelemaan siis myös satunnaislukujen käyttöä.</p>
  <p>Käytä tähtien tulostamiseen <code>*</code>-merkkiä. Alla on esimerkki lopullisen <code>Tahtitaivas</code>-luokan käytöstä ja käyttöä vastaavasti tulostuksesta.</p>
  <pre class="sh_java">
Tahtitaivas tahtitaivas = new Tahtitaivas(0.1, 39, 10);
tahtitaivas.tulosta();
System.out.println("Tähtiä: " + tahtitaivas.tahtiaViimeTulostuksessa());
System.out.println("");

tahtitaivas = new Tahtitaivas(0.2, 15, 6);
tahtitaivas.tulosta();
System.out.println("Tähtiä: " + tahtitaivas.tahtiaViimeTulostuksessa());
  </pre>
  <pre>
*     *                  *
*             * *         *      **
*
*       *      *         *  *
*     *                     *
*            * *                   *
*  * *           *          * *  **
*  *
*               *
*                             *
Tähtiä: 36

* * *     *
* *   *
*     *
*  *       *
*       *   * *
* ** **     *
Tähtiä: 22
  </pre>
  <p><strong>Huom!</strong> tehtävissä kannattaa käyttää <code>for</code>-lauseketta. Vaikka edellinen luku puhuukin sisäkkäisistä toistolauseista, tässä tehtävässä "sisempi" toisto piilotetaan metodin sisälle.</p>
  <h4>Tahtitaivas-luokka ja yhden rivin tulostaminen</h4>
  <p>Luo luokka <code>Tahtitaivas</code>, jolla on kolme oliomuuttujaa: tiheys (<code>double</code>), leveys (<code>int</code>), ja korkeus (<code>int</code>). Luo luokalle myös kolme konstruktoria:</p>
  <ul>
    <li><code>public Tahtitaivas(double tiheys)</code> Luo tähtitaivas-olion, jolla on parametrina annettu tiheys, leveys saa arvon <code>20</code>, korkeus saa arvon <code>10</code>.</li>
    <li><code>public Tahtitaivas(int leveys, int korkeus)</code> Luo tähtitaivas-olion, jolla on parametrina annetut leveys ja korkeus, tiheys saa arvon <code>0.1</code>.</li>
    <li><code>public Tahtitaivas(double tiheys, int leveys, int korkeus)</code> Luo tähtitaivas-olion, jolla on parametrina annetut tiheys, leveys ja korkeus.</li>
  </ul>
  <p>Lisää luokalle <code>Tahtitaivas</code> metodi <code>tulostaRivi</code>, joka tulostaa yhden rivin. Rivin leveyden määrää oliomuuttuja <code>leveys</code>. Oliomuuttuja <code>tiheys</code> kertoo todennäköisyyden tähdelle. Arvo jokaisen merkin kohdalla tulostetaanko tähti vai ei <code>Random</code>-luokan <code>nextDouble</code>-metodin avulla.</p>
  <p>Testaa ohjelmaasi, esimerkkinä seuraava kutsu ja esimerkkitulostus.</p>
  <pre class="sh_java">
Tahtitaivas tahtitaivas = new Tahtitaivas(0.1);
tahtitaivas.tulostaRivi();
  </pre>
  <pre>
*  *                  *
  </pre>
  <h4>Tähtitaivaan tulostus</h4>
  <p>Luo <code>Tahtitaivas</code>-luokalle metodi <code>tulosta</code>, joka tulostaa koko tähtitaivaan. Käytä tässä hyödyksesi aiempaa <code>tulostaRivi</code>-metodia.</p>
<pre class="sh_java">
Tahtitaivas tahtitaivas = new Tahtitaivas(8, 4);
tahtitaivas.tulosta();
  </pre>
<pre>
*

*
*
</pre>
  <h4>Tähtien laskeminen</h4>
  <p>Lisää <code>Tahtitaivas</code>-luokalle oliomuuttuja tahtiaViimeTulostuksessa (<code>int</code>) ja metodi <code>tahtiaViimeTulostuksessa()</code>, joka palauttaa viime tulostuksessa tulostuneiden tähtien lukumäärän. Toteuta ohjelmaasi tähtien laskeminen.</p>
<pre class="sh_java">
Tahtitaivas tahtitaivas = new Tahtitaivas(8, 4);
tahtitaivas.tulosta();
System.out.println("Tähtiä: " + tahtitaivas.tahtiaViimeTulostuksessa());
System.out.println("");

tahtitaivas.tulosta();
System.out.println("Tähtiä: " + tahtitaivas.tahtiaViimeTulostuksessa());
</pre>
<pre>


*

Tähtiä: 1

*
*
*

Tähtiä: 3
</pre>
</div>
</div>
<h2>static:illa vai ilman?</h2>
<p>Kun aloimme olioden käytön, materiaalissa oli neuvo jättää sana static pois olioiden metodien määrittelystä. Viikkoon 3 asti taas kaikissa metodeissa esiintyi määre static. Mistä on kysymys?</p>
<p>Seuraavassa esimerkissä on metodi <code>nollaaTaulukko</code> joka toimii nimensä mukaisesti eli asettaa nollan parametrina saamansa taulukon kaikkien lokeroiden arvoksi.</p>
<pre class="sh_java">
public class Ohjelma {

    public static void nollaaTaulukko(int[] taulukko) {
        for ( int i=0; i &lt; taulukko.length; i++ )
            taulukko[i] = 0;
        }
    }

    public static void main(String[] args) {
        int[] luvut = { 1, 2, 3, 4, 5 };

        for ( int luku : luvut ) {
            System.out.print( luku + " " );  // tulostuu 1, 2, 3, 4, 5
        }

        System.out.println();

        nollaaTaulukko(luvut);

        for ( int luku : luvut ) {
            System.out.print( luku + " " );  // tulostuu 0, 0, 0, 0, 0
        }
    }
}
</pre>
<p>Huomaamme, että metodin määrittelyssä on nyt määre <code>static</code>. Syynä on se, että metodi ei liity mihinkään olioon vaan kyseessä on <em>luokkametodi</em>. Luokkametodeja kutsutaan usein myös <i>staattisiksi metodeiksi</i>. Toisin kuin olioiden metodit (joilla ei ole määrettä static), staattiseen metodiin ei liity mitään olioa. Staattinen metodi ei siis voi viitata <code>this</code>-määreellä olioon itseensä toisin kuin oliometodit.</p>
<p>Staattiselle metodille voi toki antaa olion parametrina. Staattinen metodi ei voi käsitellä mitään muita lukuja, merkkijonoja, taulukoita tai oliota kuin niitä, jotka on sille parametrina annettu tai jotka ovat staattisia luokkamuuttujia. Toisin sanoin, staattisen metodin kutsuja antaa metodille aina käsiteltävät arvot ja oliot. </p>
<p>Koska staattinen metodi ei liity mihinkään olioon, ei sitä kutsuta oliometodien tapaan <code>olionNimi.metodinNimi()</code>, vaan ylläolevan esimerkin tapaan käytetään pelkkää staattisen metodin nimeä.</p>
<p>Jos staattisen metodin koodi on eri luokan sisällä kuin sitä kutsuva metodi, tapahtuu kutsu muodossa <code>LuokanNimi.staattisenMetodinNimi()</code>. Edellinen esimerkki alla muutettuna siten, että pääohjelma ja metodi ovat omissa luokissaan (eli eri tiedostoissa):</p>
<pre class="sh_java">
public class Ohjelma {
    public static void main(String[] args) {
        int[] luvut = { 1, 2, 3, 4, 5 };

        for ( int luku : luvut ) {
            System.out.print( luku + " " );  // tulostuu 1, 2, 3, 4, 5
        }

        System.out.println();

        TaulukonKasittely.nollaaTaulukko(luvut);

        for ( int luku : luvut ) {
            System.out.print( luku + " " );  // tulostuu 0, 0, 0, 0, 0
        }
    }
}
</pre>
<pre class="sh_java">
public class TaulukonKasittely {
    public static void nollaaTaulukko(int[] taulukko) {
        for ( int i=0; i &lt; taulukko.length; i++ ) {
            taulukko[i] = 0;
        }
    }
}
</pre>
<p>Toisen luokan sisällä määriteltyä staattista metodia kutsutaan nyt muodossa <code>TaulukonKasittely.nollaaTaulukko(<em>parametri</em>);</code>.</p>
<h3>Milloin staattisia metodeja tulisi käyttää</h3>
<p>Kaikki olion tilaa käsittelevät metodit tulee määritellä normaaleina oliometodeina. Esim. edellisillä viikoilla määrittelemiemme luokkien <code>Henkilo, Paivays, Kello, Joukkue, ...</code> kaikki metodit tulee määritellä normaaleina oliometodeina eli ei static:eina.</p>
<p>Palataan vielä luokkaan <code>Henkilo</code>. Seuraavassa on osa luokan määritelmästä. Kaikkiin oliomuuttujiin viitataan <code>this</code>-määreen avulla sillä korostamme, että metodeissa käsitellään olion "sisällä" olevia oliomuuttujia.</p>
<pre class="sh_java">
public class Henkilo {
    private String nimi;
    private int ika;

    public Henkilo(String nimi) {
        this.ika = 0;
        this.nimi = nimi;
    }

    public boolean taysiIkainen(){
        if ( this.ika &lt; 18 ) {
            return false;
        }

        return true;
    }

    public void vanhene() {
        this.ika++;
    }

    public String getNimi() {
        return this.nimi;
    }
}
</pre>
<p>Koska metodit käsittelevät olioa, ei niitä voi määrittää static:eiksi eli "olioon kuulumattomiksi". Jos näin yritetään tehdä, ei metodi toimi:</p>
<pre class="sh_java">
public class Henkilo {
    //...

    public static void vanhene() {
        this.ika++;
    }
}
</pre>
<p>Seurauksena on virheilmoitus <i>non static variable ika can not be referenced from static context</i>, joka tarkoittaa että staattinen metodi ei pysty käsittelemään oliomuuttujaa.</p>
<p>Eli milloin staattista metodia sitten kannattaa käyttää? Tarkastellaan luvusta 23 tuttua henkilöolioita käsittelevää esimerkkiä:</p>
<pre class="sh_java">
public class Ohjelma {
    public static void main(String[] args) {
        Henkilo pekka = new Henkilo("Pekka");
        Henkilo antti = new Henkilo("Antti");
        Henkilo juhana = new Henkilo("Juhana");

        for ( int i=0; i &lt; 30; i++ ) {
            pekka.vanhene();
            juhana.vanhene();
        }

        antti.vanhene();

        if ( antti.taysiIkainen() ) {
            System.out.println( antti.getNimi() + " on täysi-ikäinen" );
        } else {
            System.out.println( antti.getNimi() + " on alaikäinen" );
        }

        if ( pekka.taysiIkainen() ) {
            System.out.println( pekka.getNimi() + " on täysi-ikäinen" );
        } else {
            System.out.println( pekka.getNimi() + " on alaikäinen " );
        }

        if ( juhana.taysiIkainen() ) {
            System.out.println( juhana.getNimi() + " on täysi-ikäinen" );
        } else {
            System.out.println( juhana.getNimi() + " on alaikäinen " );
        }
    }
}
</pre>
<p>Huomaamme, että henkilöiden täysi-ikäisyyden ilmottamiseen liittyy koodinpätkä joka on copy-pastettu peräkkäin kolme kertaa. Todella rumaa!</p>
<p>Henkilön täysi-ikäisyyden ilmoittaminen on mainio kohde staattiselle metodille. Kirjoitetaan ohjelma uudelleen metodia hyödyntäen:</p>
<pre class="sh_java">
public class Main {

    public static void main(String[] args) {
        Henkilo pekka = new Henkilo("Pekka");
        Henkilo antti = new Henkilo("Antti");
        Henkilo juhana = new Henkilo("Juhana");

        for ( int i=0; i &lt; 30; i++ ) {
            pekka.vanhene();
            juhana.vanhene();
        }

        antti.vanhene();

        ilmoitaTaysiIkaisyys(antti);

        ilmoitaTaysiIkaisyys(pekka);

        ilmoitaTaysiIkaisyys(juhana);
    }

    private static void ilmoitaTaysiIkaisyys(Henkilo henkilo) {
        if ( henkilo.taysiIkainen() ) {
            System.out.println(henkilo.getNimi() + " on täysi-ikäinen");
        } else {
            System.out.println(henkilo.getNimi() + " on alaikäinen");
        }
    }
}
</pre>
<p>Metodi <code>ilmoitaTaysiIkaisyys</code> on määritelty staattiseksi, eli se ei liity mihinkään olioon, <strong>mutta</strong> metodi saa parametrikseen henkilöolion. Metodia ei ole nyt määritelty
  Henkilö-luokan sisälle sillä vaikka se käsittelee parametrinaan saamaan henkilöolioa, se on juuri
  kirjoitetun pääohjelman apumetodi, jonka avulla main on saatu kirjoitettua selkeämmin. </p>
<div class="tehtavat">
  <div class="tehtava">
  <h3>Kirjaston tietojärjestelmä</h3>
  <p>Kumpulan tiedekirjasto tarvitsee uuden järjestelmän kirjojen hallintaan. Tässä tehtävässä toteutetaan <em>prototyyppi</em>, jossa toteutetaan kirjan haku nimen, julkaisijan tai julkaisuvuoden perusteella.</p>
  <p>Rakennetaan järjestelmä osista, ensin toteutetaan oleelliset luokat eli <code>Kirja</code> ja <code>Kirjasto</code>. Luokka <code>Kirja</code> sisältää kirjaan liittyvät tiedot, luokka <code>Kirjasto</code> tarjoaa erilaisia hakutoiminnallisuuksia kirjoihin liittyen.</p>
  <h4>Kirja</h4>
  <p>Luodaan ensiksi luokka Kirja. Kirjalla on oliomuuttujina <code>nimike</code>, eli kirjan nimi, <code>julkaisija</code>, eli kirjan julkaisija, ja <code>julkaisuvuosi</code> eli vuosi jolloin kirja on julkaistu. Kaksi ensimmäistä muuttujaa on merkkijonotyyppisiä, viimeisin on kokonaisluku. Oletamme tässä että kirjalla on aina vain yksi kirjoittaja.</p>
  <p>Toteuta luokka <code>Kirja</code>. Kirjalla tulee olla myös konstruktori <code>public Kirja(String nimike, String julkaisija, int julkaisuvuosi)</code> sekä metodit <code>public String nimike()</code>, <code>public String julkaisija()</code>, <code>public int julkaisuvuosi()</code> ja <code>public String toString()</code>. Arvannet mitä metodien tulee tehdä, alla esimerkki.</p>
  <p>Testaa luokan toimintaa:</p>
  <pre class="sh_java">
Kirja cheese = new Kirja("Cheese Problems Solved", "Woodhead Publishing", 2007);
System.out.println(cheese.nimike());
System.out.println(cheese.julkaisija());
System.out.println(cheese.julkaisuvuosi());

System.out.println(cheese);
</pre>
  <pre>
Cheese Problems Solved
Woodhead Publishing
2007
Cheese Problems Solved, Woodhead Publishing, 2007
  </pre>
  <h4>Kirjasto</h4>
  <p>Kirjaston tehtävä on antaa käyttäjälle mahdollisuus kirjojen lisäämiseen ja niiden hakemiseen. Luo luokka <code>Kirjasto</code>, jolla on konstruktori <code>public Kirjasto()</code> ja metodit <code>public void lisaaKirja(Kirja uusiKirja)</code> ja <code>public void tulostaKirjat()</code></p>
  <pre class="sh_java">
Kirjasto kirjasto = new Kirjasto();

Kirja cheese = new Kirja("Cheese Problems Solved", "Woodhead Publishing", 2007);
kirjasto.lisaaKirja(cheese);

Kirja nhl = new Kirja("NHL Hockey", "Stanley Kupp", 1952);
kirjasto.lisaaKirja(nhl);

kirjasto.lisaaKirja(new Kirja("Battle Axes", "Tom A. Hawk", 1851));

kirjasto.tulostaKirjat();
</pre>
<pre>
Cheese Problems Solved, Woodhead Publishing, 2007
NHL Hockey, Stanley Kupp, 1952
Battle Axes, Tom A. Hawk, 1851
</pre>
  <h4>Hakutoiminnallisuus</h4>
  <p>Kirjastosta tulee pystyä etsimään kirjoja nimikkeiden ja julkaisijoiden perusteella. Lisää kirjastolle metodit <code>public ArrayList&lt;Kirja&gt; haeKirjaNimikkeella(String nimike)</code>, <code>public ArrayList&lt;Kirja&gt; haeKirjaJulkaisijalla(String julkaisija)</code> ja <code>public ArrayList&lt;Kirja&gt; haeKirjaJulkaisuvuodella(int julkaisuvuosi)</code>. Metodit palauttavat listan kirjoista, joissa on haluttu nimike, julkaisija tai julkaisuvuosi.</p>
  <p><b>Huom:</b> joudut siis tehdä metodin jonka paluuarvona on ArrayList. Tämä onnustuu seuraavaa metodirunkoa hyödyntäen:</p>
  <pre class="sh_java">
public class Kirjasto {
    // ...

    public ArrayList&lt;Kirja&gt; haeKirjaNimikkeella(String nimike) {
        ArrayList&lt;Kirja&gt; loydetyt = new ArrayList&lt;Kirja&gt;();

        // käy läpi kaikki kirjat ja lisää ne joilla haetun kaltainen nimike listalle loydetyt

        return loydetyt;
    }
}
</pre>
  <p>Huom! Kun haet teet hakua merkkijonon avulla, älä tee tarkkaa hakua (metodi <code>equals</code>) vaan käytä <code>String</code>-luokan metodia <code>contains</code>. Huomaat todennäköisesti myös että sinulla on ns. copy-paste -koodia <code>Kirjasto</code>-luokan koodissa. Keksitkö tavan päästä siitä eroon?</p>
<pre class="sh_java">
Kirjasto kirjasto = new Kirjasto();

kirjasto.lisaaKirja(new Kirja("Cheese Problems Solved", "Woodhead Publishing", 2007));
kirjasto.lisaaKirja(new Kirja("The Stinky Cheese Man and Other Fairly Stupid Tales", "Penguin Group", 1992));
kirjasto.lisaaKirja(new Kirja("NHL Hockey", "Stanley Kupp", 1952));
kirjasto.lisaaKirja(new Kirja("Battle Axes", "Tom A. Hawk", 1851));

ArrayList&lt;Kirja&gt; hakutulos = kirjasto.haeKirjaNimikkeella("Cheese");
for (Kirja kirja: hakutulos) {
    System.out.println(kirja);
}

System.out.println("---");
for (Kirja kirja: kirjasto.haeKirjaJulkaisijalla("Penguin Group  ")) {
    System.out.println(kirja);
}

System.out.println("---");
for (Kirja kirja: kirjasto.haeKirjaJulkaisuvuodella(1851)) {
    System.out.println(kirja);
}
</pre>
<pre>
Cheese Problems Solved, Woodhead Publishing, 2007
The Stinky Cheese Man and Other Fairly Stupid Tales, Penguin Group, 1992
---
---
Battle Axes, Tom A. Hawk, 1851
</pre>
  <h4>Paranneltu hakutoiminnallisuus</h4>
  <p>Hakutoiminnallisuutemme on jo hyvä, mutta se ei ymmärrä isojen ja pienten kirjainten eroa. Yllä olleessa esimerkissä haku nimikkeellä <code>"cheese"</code> ei olisi tuottanut yhtäkään tulosta. Myös toinen esimerkki, jossa oli ylimääräisiä välilyöntejä, ei näyttänyt haluttua tulosta. Haluamme että nimikkeiden ja julkaisijoiden nimillä haettaessa ei välitetä merkkien koosta, ja että käyttäjä voi syöttää ylimääräisiä välilyöntejä kirjan nimen alkuun tai loppuun (meidän ei tarvitse välittää sanojen välillä olevista tyhjistä!). Toteutetaan pieni apukirjasto <code>StringUtils</code> merkkijonojen vertailuun.</p>
  <p>Luo luokka <code>StringUtils</code>, ja lisää sille staattinen metodi <code>public static boolean sisaltaa(String sana, String haettava)</code>, joka tarkistaa sisältääkö merkkijono <code>sana</code> merkkijonon <code>haettava</code>. Jos jommankumman merkkijonon arvo on <em>null</em>, metodin tulee palauttaa arvo <code>false</code>. Metodin tarjoaman vertailun tulee olla välittämättä merkin koosta.
  <p>Lisää metodille <code>sisaltaa</code> myös toiminnallisuus, joka poistaa merkkijonojen <code>sana</code> ja <code>haettava</code> alusta ja lopusta ylimääräiset välilyönnit. Käytä tähän <code>String</code>-luokan metodia <code>trim</code>, esim. <code>trimmattu = trimmattava.trim()</code></p>
  <p><em>Vinkki!</em> <code>String</code>-luokan metodista <code>toUpperCase()</code> on hyötyä kun haluat verrata ovatko kaksi merkkijonoa samat -- riippumatta niiden alkuperäisestä merkkikoosta.</p>
  <p>Kun olet saanut metodin valmiiksi, käytä sitä <code>Kirjasto</code>-luokassa. Alla esimerkki:</p>
<pre class="sh_java">
if(StringUtils.sisaltaa(kirja.nimike(), haettuNimike)) {
    // kirja löytyi!
}
</pre>
  <pre class="sh_java">
Kirjasto kirjasto = new Kirjasto();

kirjasto.lisaaKirja(new Kirja("Cheese Problems Solved", "Woodhead Publishing", 2007));
kirjasto.lisaaKirja(new Kirja("The Stinky Cheese Man and Other Fairly Stupid Tales", "Penguin Group", 1992));
kirjasto.lisaaKirja(new Kirja("NHL Hockey", "Stanley Kupp", 1952));
kirjasto.lisaaKirja(new Kirja("Battle Axes", "Tom A. Hawk", 1851));

for (Kirja kirja: kirjasto.haeKirjaNimikkeella("CHEESE")) {
    System.out.println(kirja);
}

System.out.println("---");
for (Kirja kirja: kirjasto.haeKirjaJulkaisijalla("PENGUIN  ")) {
    System.out.println(kirja);
}
</pre>
<pre>
Cheese Problems Solved, Woodhead Publishing, 2007
The Stinky Cheese Man and Other Fairly Stupid Tales, Penguin Group, 1992
---
The Stinky Cheese Man and Other Fairly Stupid Tales, Penguin Group, 1992
</pre>
</div>
</div>
<h2>Tehtäviä joissa saat itse keksiä ohjelmalle sopivan rakenteen</h2>
<div class="tehtavat">
  <p class="mooc-pakollinen"></p>
  <div class="tehtava">
  <h3>Arvosanajakauma</h3>
  <p><b>Tehtävä vastaa kolmea yksiosaista tehtävää. </b></p>
  <p><b>HUOM:</b> Ohjelmassa saa käyttää vain yhtä Scanner-olioa, eli vain kertaalleen saa sanoa <code>new Scanner</code>. Jos tarvitset Scanneria monessa kohtaa, voit välittää sen muualle parametrina seuraavaan tyyliin:</p>
  <pre class="sh_java">
public static void main(String[] args) {
    Scanner lukija = new Scanner(System.in);

    // ...

    teeJotain(lukija);
}

public static void teeJotain(Scanner lukija) {
    String rivi = lukija.nextLine();
    // ...
}
</pre>
  <p>Tai jos toinen olio tarvitsee Scanneria, voi sen välittää konstruktoriparametrina ja tallettaa oliomuuttujaan jolloin Scanner on olion kaikkien metodien käytössä.</p>
  <p>Ohjelman syöte on joukko kokonaislukuja, jotka kuvaavat opiskelijoiden kokeesta saamia pistemääriä.
    Käyttäjä syöttää yhden pistemäärän per rivi. Kun syöte on -1, lopettaa ohjelma pistemäärien kyselyn. </p>
  <p>Pisteiden syöttö toimii seuraavasti:</p>
<pre>
Syötä koepisteet, -1 lopettaa:
<font color="red">34</font>
<font color="red">41</font>
<font color="red">53</font>
<font color="red">36</font>
<font color="red">55</font>
<font color="red">27</font>
<font color="red">43</font>
<font color="red">40</font>
<font color="red">-1</font>
</pre>
  <p>Pisteiden syöttämisen jälkeen ohjelma tulostaa kurssin arvosanajakauman ja hyväksymisprosentin seuraavassa muodossa:</p>
<pre>
Arvosanajakauma:
5: **
4:
3: ***
2: *
1: *
0: *
Hyväksymisprosentti: 87.5
</pre>
  <p>Arvosananajakauma muodostetaan seuraavasti:</p>
  <ul>
    <li>Jokainen koepistemäärä muutetaan arvosanaksi samalla kaavalla kuin <a href="http://www.cs.helsinki.fi/group/java/s12/ohpe/materiaali.html#w1e18">tehtävässä 18</a>. Jos syötetty pistemäärä ei ole välillä 0-60, ei sitä huomioida mitenkään.</li>
    <li>Arvosanat tulostetaan tähtinä. Esim jos arvosanaan 5 oikeuttavia koepistemääriä on 2 kappaletta, tulostuu rivi <em>5: **</em>. Jos johonkin arvosanaan oikeuttavia pistemääriä ei ole, ei yhtään tähteä tulostu, esimerkissämme näin oli nelosten  kohdalla, tulostui rivi jossa on ainoastaan <em>4: </em> </li>
  </ul>
  <p>Hyväksyttyjä ovat muut paitsi arvosanan 0 saaneet. Hyväksyttyjä edellä on siis 7 osallistujaa 8:sta. Hyväksymisprosentti lasketaan kaavalla <em>100*hyväksytyt/osallistujat</em>. </p>
</div>
<p class="mooc-pakollinen"></p>
<div class="tehtava">
  <h3>Lintubongarin tietokanta</h3>
  <p><b>HUOM:</b> Ohjelmassa saa käyttää vain yhtä Scanner-olioa, eli vain kertaalleen saa sanoa <code>new Scanner</code>. Jos tarvitset Scanneria monessa kohtaa, voit välittää sen muualle parametrina.</p>
  <p><b>Tehtävä vastaa kolmea yksiosaista tehtävää. </b></p>
  <p>Tässä tehtävässä suunnittelet ja toteutat tietokannan lintubongareille. Tietokanta sisältää lintuja, joista jokaisella on nimi (merkkijono) ja latinankielinen nimi (merkkijono). Tämän lisäksi tietokanta laskee kunkin linnun havaintokertoja.</p>
  <p>Ohjelmasi täytyy toteuttaa seuraavat komennot:</p>
  <ul>
    <li><code>Lisaa</code> - lisää linnun (<b>huom:</b> komennon nimessä ei ä-kirjainta!)</li>
    <li><code>Havainto</code> - lisää havainnon</li>
    <li><code>Tilasto</code> - tulostaa kaikki linnut</li>
    <li><code>Nayta</code> - tulostaa yhden linnun (<b>huom:</b> komennon nimessä ei ä-kirjainta!)</li>
    <li><code>Lopeta</code> - lopettaa ohjelman</li>
  </ul>
  <p>Lisäksi virheelliset syötteet pitää käsitellä. (Ks. <code>Simo</code> alla). Tässä vielä esimerkki ohjelman toiminnasta:</p>
<pre>
? <font color="red">Lisaa</font>
Nimi: <font color="red">Korppi</font>
Latinankielinen nimi: <font color="red">Corvus Corvus</font>
? <font color="red">Lisaa</font>
Nimi: <font color="red">Haukka</font>
Latinankielinen nimi: <font color="red">Dorkus Dorkus</font>
? <font color="red">Havainto</font>
Mikä havaittu? <font color="red">Haukka</font>
? <font color="red">Havainto</font>
Mikä havaittu? <font color="red">Simo</font>
Ei ole lintu!
? <font color="red">Havainto</font>
Mikä havaittu? <font color="red">Haukka</font>
? <font color="red">Tilasto</font>
Haukka (Dorkus Dorkus): 2 havaintoa
Korppi (Corvus Corvus): 0 havaintoa
? <font color="red">Nayta</font>
Mikä? <font color="red">Haukka</font>
Haukka (Dorkus Dorkus): 2 havaintoa
? <font color="red">Lopeta</font>
</pre>
  <p><strong>Huom!</strong> Ohjelmasi rakenne on täysin vapaa. Testaamme vain että <code>Paaohjelma</code> luokan <code>main</code>-metodi toimii kuten tässä on kuvailtu. Yritä miettiä millaisista luokista ja olioista olisi hyötyä ohjelman toteuttamisessa!</p>
</div>
</div>
<h2>Debuggeri ja muuta hyödyllistä</h2>

<!-- CAST63-->

<p>Ohjelmien muuttuessa monimutkaisemmiksi, tulee virheiden löytämisestäkin koko ajan haastavampaa. NetBeansiin integroitu debuggeri voi olla avuksi virheiden löytämisessä. Seuraavalla screencastilla esitellään debuggerin käyttöä. Screencast esittelee myös miten projekteja voidaan luoda, avata ja sulkea sekä miten ohjelmia voidaan suorittaa NetBeansin ulkopuolella. </p>
<a href="http://www.youtube.com/watch?feature=player_embedded&v=2QlbAvDPmk8" height="300" target="_blank"><img src=" https://www.cs.helsinki.fi/group/java/k13/ohpe/img/youtube.jpg"/></a>

<!--
<p><iframe allowfullscreen="" frameborder="0"  height="450" width="700" src="http://www.youtube.com/embed/2QlbAvDPmk8"></iframe></p>
-->

<h2>Taulukon järjestäminen</h2>
<p>Palaamme jälleen taulukkojen pariin.</p>
<h3>Taulukon järjestäminen Javan valmiilla työkaluilla.</h3>
<p>Kuten olemme nähneet, Javassa on valmiina paljon kaikenlaista hyödyllistä. Esimerkiksi ArrayListin käsittelyyn löytyi useita hyödyllisiä apumetodeja luokasta Collections. Taulukoille löytyy vastaavia apuvälineitä luokasta <code>Arrays</code>. Taulukon saa järjestettyä komennolla <code>Arrays.sort(taulukko)</code>.</p>
<p>Huom: Komennon käyttäminen vaatii, että ohjelmatiedoston yläosassa lukee seuraava määrittely:</p>
<pre>
  import java.util.Arrays;
</pre>
<p class="help"><em>Jos unohdat <code>import</code>-rivin, NetBeans tarjoaa apua sen kirjoittamiseen. Kokeile klikata punaisella alleviivatun koodirivin vasempaan laitaan ilmestyvää lampun kuvaa.</em></p>
<p>Seuraava ohjelma luo taulukon ja järjestää taulukossa olevat luvut Arrays.sort -komennon avulla.</p>
<pre class="sh_java">
int[] luvut = {-3, -111, 7, 42};
Arrays.sort(luvut);
for(int luku: luvut) {
    System.out.println(luku);
}
</pre>
<pre>
-111
-3
7
42
</pre>
<h3>Järjestämisalgoritmin toteuttaminen</h3>
<p>Taulukon järjestäminen on helppoa Javan valmiin kaluston avulla. Ohjelmoijan yleissivistykseen kuuluu kuitenkin ainakin yhden järjestämisalgoritmin (eli tavan järjestää taulukko) tuntemus. Tutustutaan yhteen "klassiseen" järjestämisalgoritmiin, valintajärjestämiseen. Tutustuminen tapahtuu harjoitustehtävien avulla.</p>
<div class="tehtavat">
  <div class="tehtava">
  <h3>Järjestäminen</h3>
  <p><b>Huom:</b> tässä tehtävässä on tarkoitus järjestää taulukko itse. Et saa käyttää Arrays.sort()-metodia tai ArrayListejä apunasi!</p>
  <h4 class="req">Pienin</h4>
  <p>Tee metodi <code>pienin</code>, joka palauttaa taulukon pienimmän luvun.</p>
  <p>Metodin runko on seuraava:</p>
  <pre class="sh_java">
public static int pienin(int[] taulukko) {
    // kirjoita koodia tähän
}
</pre>
  <p><b>HUOM:</b> parametrina olevaa taulukkoa ei saa muuttaa!</p>
  <p>Seuraava koodi esittelee metodin toimintaa:</p>
<pre class="sh_java">
int[] luvut = {6, 5, 8, 7, 11};
System.out.println("Pienin: " + pienin(luvut));
</pre>
<pre>
Pienin: 5
</pre>
  <h4 class="req">Pienimmän indeksi</h4>
  <p>Tee metodi <code>pienimmanIndeksi</code>, joka palauttaa taulukon pienimmän luvun indeksin (eli luvun kohdan taulukossa).</p>
  <p>Metodin runko on seuraava:</p>
<pre class="sh_java">
public static int pienimmanIndeksi(int[] taulukko) {
    // kirjoita koodia tähän
}
</pre>
  <p><b>HUOM:</b> parametrina olevaa taulukkoa ei saa muuttaa!</p>
  <p>Seuraava koodi esittelee metodin toimintaa:</p>
<pre class="sh_java">
// indeksit:   0  1  2  3  4
int[] luvut = {6, 5, 8, 7, 11};
System.out.println("Pienimmän indeksi: " + pienimmanIndeksi(luvut));
</pre>
<pre>
Pienimmän indeksi: 1
</pre>
  <p>Taulukon pienin luku on 2, ja sen indeksi eli sijaintipaikka taulukossa on 1. Muistathan, että taulukon numerointi alkaa 0:sta.</p>
  <h4 class="req">Pienimmän indeksi taulukon loppuosassa</h4>
  <p>Tee metodi <code>pienimmanIndeksiAlkaen</code>, joka toimii samalla tavalla kuin edellisen tehtävän metodi mutta ottaa huomioon vain taulukon loppuosan jostain indeksistä alkaen. Metodille annetaan taulukon lisäksi aloitusindeksi, josta lähtien pienintä lukua etsitään.</p>
  <p>Metodin runko on seuraava:</p>
<pre class="sh_java">
public static int pienimmanIndeksiAlkaen(int[] taulukko, int aloitusIndeksi) {
    // kirjoita koodia tähän
}
</pre>
  <p><b>HUOM:</b> parametrina olevaa taulukkoa ei saa muuttaa!</p>
  <p>Seuraava koodi esittelee metodin toimintaa:</p>
<pre class="sh_java">
// indeksit:    0  1  2  3   4
int[] luvut = {-1, 6, 9, 8, 12};
System.out.println(pienimmanIndeksiAlkaen(luvut, 1));
System.out.println(pienimmanIndeksiAlkaen(luvut, 2));
System.out.println(pienimmanIndeksiAlkaen(luvut, 4));
</pre>
<pre>
1
3
4
</pre>
  <p>Esimerkissä ensimmäinen metodikutsu etsii pienimmän luvun indeksin aloittaen indeksistä 1. Indeksistä 1 alkaen pienin luku on 6, ja sen indeksi on 1. Vastaavasti toinen metodikutsu etsii pienimmän luvun indeksiä indeksistä 2 aloittaen. Tällöin pienin luku on 8, ja sen indeksi on 3. Viimeinen kutsu etsii pienimmän luvun indeksiä taulukon viimeisestä indeksistä eli kohdasta 4 aloittaen. Tällöinen muita paikkoja ei ole, joten pienin on paikassa 4.</p>
  <h4 class="req">Lukujen vaihtaminen</h4>
  <p>Tee metodi <code>vaihda</code>, jolle annetaan taulukko ja kaksi sen indeksiä. Metodi vaihtaa indekseissä olevat luvut keskenään.</p>
  <p>Metodin runko on seuraava:</p>
<pre class="sh_java">
public static void vaihda(int[] taulukko, int indeksi1, int indeksi2) {
    // kirjoita koodia tähän
}
</pre>
  <p>Seuraavassa estellään metodin toimintaa. Taulukon tulostamisessa käytetään apuna taulukon merkkijonoksi muotoilevaa Arrays.toString-metodia:</p>
<pre class="sh_java">
int[] luvut = {3, 2, 5, 4, 8};

System.out.println( Arrays.toString(luvut) );

vaihda(luvut, 1, 0);
System.out.println( Arrays.toString(luvut) );

vaihda(luvut, 0, 3);
System.out.println( Arrays.toString(luvut) );
</pre>
<pre>
[3, 2, 5, 4, 8]
[2, 3, 5, 4, 8]
[4, 3, 5, 2, 8]
</pre>
  <h4 class="req">Järjestäminen</h4>
  <p>Nyt koossa on joukko hyödyllisiä metodeja, joiden avulla voimme toteuttaa järjestämisalgoritmin nimeltä vaihtojärjestäminen.</p>
  <p>Vaihtojärjestämisen idea on seuraava:</p>
  <ul>
    <li> Siirretään taulukon pienin luku indeksiin 0.
    <li> Siirretään taulukon toiseksi pienin luku indeksiin 1.
    <li> Siirretään taulukon kolmanneksi pienin luku indeksiin 2.
    <li> Jne.
  </ul>
  <p>Toisin sanoen:</p>
  <ul>
    <li> Tarkastellaan taulukkoa indeksistä 0 alkaen. Vaihdetaan keskenään indeksissä 0 oleva luku sekä taulukon pienin luku indeksistä 0 alkaen.
    <li> Tarkastellaan taulukkoa indeksistä 1 alkaen. Vaihdetaan keskenään indeksissä 1 oleva luku sekä taulukon pienin luku indeksistä 1 alkaen.
    <li> Tarkastellaan taulukkoa indeksistä 2 alkaen. Vaihdetaan keskenään indeksissä 2 oleva luku sekä taulukon pienin luku indeksistä 2 alkaen.
    <li> Jne.
  </ul>
  <p>Toteuta metodi <code>jarjesta</code>, joka perustuu yllä olevaan ideaan. Metodissa on syytä olla silmukka, joka käy läpi taulukon indeksejä. Metodeista <code>pieninIndeksiAlkaen</code> ja <code>vaihda</code> on varmasti hyötyä. Tulosta myös taulukon sisältö ennen järjestämistä ja jokaisen kierroksen jälkeen, jotta voit varmistaa algoritmin toimivan oikein.</p>
  <p>Metodin runko on seuraava:</p>
<pre class="sh_java">
public static void jarjesta(int[] taulukko) {
}
</pre>
<p>Testaa metodin toimintaa ainakin seuraavalla esimerkillä:</p>
<pre class="sh_java">
int[] luvut = {8, 3, 7, 9, 1, 2, 4};
jarjesta(luvut);
</pre>
<p>Ohjelman tulosteen tulisi olla seuraavanlainen. Huomaa että sinun tulee tulostaa taulukon sisältö jokaisen vaihtamisen jälkeen!</p>
<pre>
[8, 3, 7, 9, 1, 2, 4]
[1, 3, 7, 9, 8, 2, 4]
[1, 2, 7, 9, 8, 3, 4]
[1, 2, 3, 9, 8, 7, 4]
[1, 2, 3, 4, 8, 7, 9]
[1, 2, 3, 4, 7, 8, 9]
[1, 2, 3, 4, 7, 8, 9]
</pre>
<p>Huomaat, miten taulukko tulee pikkuhiljaa järjestykseen alkaen alusta ja edeten loppua kohti.</p>
</div>
</div>
<h2>Etsintä</h2>
<p>Järjestämisen lisäksi toinen hyvin tyypillinen ongelma johon ohjelmoija törmää, on tietyn arvon etsiminen taulukosta. Olemme aiemmin jo toteuttaneet metodeja, jotka etsivät arvoja listoista ja taulukoista. Taulukkojen tapauksessa lukuja ja merkkijonoja voi etsiä seuraavasti: </p>
<pre class="sh_java">
public static boolean onkoTaulukossa(int[] taulukko, int etsittava) {
    for ( int luku : taulukko ) {
        if ( luku == etsittava )  {
            return true;
        }
    }

    return false;
}

public static boolean onkoSanaTaulukossa(String[] taulukko, String etsittava) {
    for ( String sana: taulukko ) {
        if ( sana.equals(etsittava) )  {
            return true;
        }
    }

    return false;
}
</pre>
<p>Tämänkaltainen toteutus on paras mihin olemme tähän asti pystyneet. Metodin huono puoli on se, että jos taulukossa on hyvin suuri määrä lukuja, kuluu etsintään paljon aikaa. Metodi käy läpi pahimmassa tapauksessa jokaisen taulukossa olevan alkion. Tämä tarkoittaa sitä, että taulukon, jossa on esimerkiksi 16777216 alkiota, läpikäynti vaatii 16777216 alkion tutkiskelua.</p>
<p>Toisaalta, jos taulukossa olevat luvut ovat <i>suuruusjärjestyksessä</i>, voidaan etsiminen tehdä huomattavasti tehokkaammin soveltamalla tekniikkaa nimeltään <i>binäärihaku</i>. Tutkitaan binäärihaun ideaa seuraavan taulukon kautta:</p>
<pre>
// indeksit   0   1   2   3    4   5    6   7   8   9  10
// luvut     -7  -3   3   7   11  15   17  21  24  28  30
</pre>
<p>Oletetaan että haluamme löytää luvun 17. Hyödynnetään tietoa siitä että taulukon arvot ovat järjestyksessä sen sijaan, että kävisimme taulukon lukuja läpi taulukon alusta lähtien. Tutkitaan taulukon keskimmäistä alkiota. Taulukon puolessa välissä olevan alkion indeksi on isoin indeksi 10 jaettuna kahdella eli 5. Keskimmäinen alkio on merkattu seuraavaan tähdellä:</p>
<pre>
                                   *
// indeksit   0   1   2   3    4   5    6   7   8   9  10
// luvut     -7  -3   3   7   11  15   17  21  24  28  30
</pre>
<p>Puolessa välissä on luku 15, joka ei ollut hakemamme luku. Etsimme lukua 17, joten koska taulukon alkiot ovat suuruusjärjestyksessä, ei etsitty luku voi missään tapauksessa olla luvun 15 vasemmalla puolella. Voimme siis päätellä että kaikki indeksit, jotka ovat pienempiä tai yhtäsuuria kuin 5, eivät missään nimessä sisällä hakemaamme arvoa.</p>
<p>Alue, jolta etsimme haettavaa lukua voidaan nyt rajata lukuihin, jotka sijaitsevat indeksin 5 oikealla puolella, eli indekseihin välillä [6, 10] (6, 7, 8, 9, 10). Seuraavassa on merkitty harmaalla se osa taulukkoa jossa etsitty ei voi olla:</p>
<pre>
// indeksit   <font color="lightgrey"> 0   1   2   3   4    5</font>    6   7   8   9  10
// luvut      <font color="lightgrey">-7  -3   3   7  11   15</font>   17  21  24  28  30
</pre>
<p>Tutkitaan seuraavaksi jäljellä olevan etsintäalueen, eli indeksien 6-10 keskimmäistä indeksiä. Keskimmäinen indeksi löytyy ottamalla etsintäalueen pienimmän ja suurimman indeksin summa ja jakamalla se kahdella, eli (6+10)/2 = 16/2 = 8. Indeksi 8 on merkitty alle tähdellä.</p>
<pre>
                                                 *
// indeksit   <font color="lightgrey"> 0   1   2   3   4    5</font>    6   7   8   9  10
// luvut      <font color="lightgrey">-7  -3   3   7  11   15</font>   17  21  24  28  30
</pre>
<p>Indeksissä 8 oleva luku on 24, joka ei ollut hakemamme luku. Koska luvut taulukossa ovat suuruusjärjestyksessä, ei etsittävä luku voi missään nimessä olla luvun 24 oikealla puolella. Voimme siis päätellä että kaikki indeksit, jotka ovat suurempia tai yhtäsuuria kuin 8, eivät missään nimessä sisällä hakemaamme arvoa. Etsintäalue rajautuu taas, harmaat alueet on käsitelty:</p>
<pre>
// indeksit   <font color="lightgrey"> 0   1   2   3   4    5</font>    6   7  <font color="lightgrey"> 8   9  10</font>
// luvut      <font color="lightgrey">-7  -3   3   7  11   15</font>   17  21  <font color="lightgrey">24  28  30</font>
</pre>
<p>Etsintä jatkuu. Tutkitaan jäljellä olevan etsintäalueen, eli indeksien 6-7, keskimmäistä indeksiä. Keskimmäinen indeksi löytyy taas ottamalla etsintäalueen pienimmän ja suurimman indeksin summa ja jakamalla se kahdella, eli (6+7)/2 = 6,5, joka pyöristyy alaspäin luvuksi 6. Kohta on merkitty alle tähdellä.</p>
<pre>
                                         *
// indeksit   <font color="lightgrey"> 0   1   2   3   4    5</font>    6   7  <font color="lightgrey"> 8   9  10</font>
// luvut      <font color="lightgrey">-7  -3   3   7  11   15</font>   17  21  <font color="lightgrey">24  28  30</font>
</pre>
<p>Indeksissä 6 on luku 17, joka on sama kuin hakemamme luku. Voimme lopettaa haun ja ilmoittaa että etsitty luku on taulukossa. Jos luku ei olisi ollut taulukossa -- esimerkiksi jos haettava luku olisi ollut 16, etsintäalue olisi jäänyt lopulta tyhjäksi.</p>
<pre>
                                         *
// indeksit   <font color="lightgrey"> 0   1   2   3   4    5</font>    <font color="red">6</font>   7  <font color="lightgrey"> 8   9  10</font>
// luvut      <font color="lightgrey">-7  -3   3   7  11   15</font>   <font color="red">17</font>  21  <font color="lightgrey">24  28  30</font>
</pre>
<p>Jotta binäärihaun idea tulee sinulle tutuksi, simuloi kynällä ja paperilla miten binäärihaku toimii kun taulukkona on alla oleva taulukko ja haet ensin lukua 33, sitten lukua 1.</p>
<pre>
// indeksit   0   1   2   3   4   5   6   7   8   9  10  11  12  13
// luvut     -5  -2   3   5   8  11  14  20  22  26  29  33  38  41
</pre>
<p>Binäärihaun avulla haemme alkiota puolittamalla aina tutkittavan alueen kahteen osaan. Tämä mahdollistaa hyvin tehokkaan hakemisen. Esimerkiksi taulukko, jossa on 16 alkiota, voidaan jakaa kahteen osaan korkeintaan 4 kertaa, eli 16 -> 8 -> 4 -> 2 -> 1. Toisaalta, taulukko, jossa on 16777216 alkiota, voidaan jakaa kahteen osaan korkeintaan 24 kertaa. Tämä tarkoittaa sitä, että binäärihaun avulla 16777216-alkioisessa taulukossa tarvitsee tarkastella korkeintaan 24 alkiota haetun alkion löytymiseksi.</p>
<p><em>Binäärihaun tehokkuutta voi tutkia logaritmien avulla. Kaksikantainen logaritmi (<code>log<sub>2</sub></code>) luvusta 16777216 on 24 -- voimme siis laskea kaksikantaisen logaritmin avulla kuinka monta kertaa jonkun luvun voi puolittaa. Vastaavasti luvun 4294967296 kaksikantainen logaritmi, (<code>log<sub>2</sub> 4294967296</code>) on 32. Tämä tarkoittaa että 4294967296 eri arvoa sisältävästä järjestyksessä olevasta taulukosta hakeminen vaatisi korkeintaan 32 eri alkion tarkastamista. Tehokkuus on oleellinen osa tietojenkäsittelytiedettä. Esimerkiksi tietojenkäsittelytieteen ensimmäisen vuoden kurssi Tietorakenteet keskittyy tehokkaiden tietorakenteiden toteuttamiseen.</em></p>
<div class="tehtavat">
  <div class="tehtava">
  <h3 class="req">Arvauspeli</h3>
  <p>Tehdään tässä tehtävässä tekoäly, joka arvaa pelaajan ajatteleman luvun. Tekoäly olettaa, että luku on välillä <em>alaraja</em>...<em>yläraja</em>.  Pelin käynnistäjä antaa nämä rajat pelin toteuttavalle metodille parametrina. Tekoäly kysyy käyttäjältä kysymyksiä muotoa "Onko lukusi suurempi kuin X?" ja päättelee oikean luvun käyttäjän vastausten perusteella.</p>
  <p>Tekoäly pitää kirjaa hakualueesta muuttujien alaraja ja yläraja avulla. Tekoäly kysyy aina, onko käyttäjän luku suurempi kuin näiden lukujen keskiarvo, jolloin vastauksen perusteella hakualue aina puolittuu. Lopulta alaraja ja yläraja ovat samat, ja käyttäjän ajattelema luku on paljastunut.</p>
  <p> Seuraavassa esimerkissä käyttäjä valitsee luvun 44: </p>
  <pre>
Ajattele jotain lukua väliltä 1...100.
Lupaan pystyä arvaamaan ajattelemasi luvun 7 kysymyksellä.

Esitän sinulle seuraavaksi sarjan kysymyksiä. Vastaa niihin rehellisesti.

Onko lukusi suurempi kuin 50? (k/e)
<font color="red">e</font>
Onko lukusi suurempi kuin 25? (k/e)
<font color="red">k</font>
Onko lukusi suurempi kuin 38? (k/e)
<font color="red">k</font>
Onko lukusi suurempi kuin 44? (k/e)
<font color="red">e</font>
Onko lukusi suurempi kuin 41? (k/e)
<font color="red">k</font>
Onko lukusi suurempi kuin 43? (k/e)
<font color="red">k</font>
Ajattelemasi luku on 44.
</pre>
<p>Yllä olevassa esimerkissä mahdollinen lukualue
on aluksi 1...100.
Kun käyttäjä kertoo, että luku ei ole yli 50,
mahdollinen lukualue on 1...50.
    Kun käyttäjä kertoo, että luku on yli 25,
    mahdollinen lukualue on 26...50.
    Samanlainen päättely jatkuu,
    kunnes saavutaan lukuun 44.</p>
  <p>Puolitus- eli binäärihaun mukaisesti tässä puolitetaan mahdollinen hakualue jokaisella kysymyksellä, jolloin kysymyksiä tarvitaan vähän. Jopa lukuvälillä 1..1000000 pitäisi kulua korkeintaan 20 kysymystä.</p>
  <p>Pelin toteuttavan luokan <code>Arvauspeli</code> runko on seuraavanlainen:</p>
  <pre class="sh_java">
public class Arvauspeli {

    private Scanner lukija;

    public Arvauspeli() {
    this.lukija = new Scanner(System.in);
    }

    public void pelaa(int alaraja, int ylaraja) {
        tulostaOhjeet(ylaraja, alaraja);

        // Kirjoita pelin koodi tänne
    }

    // tee metodit onkoSuurempiKuin ja keskiarvo tänne

    public void tulostaOhjeet(int ylaraja, int alaraja) {
        int kysymyksiaKorkeintaan = kuinkaMontaKertaaVoiJakaaKahteen(ylaraja - alaraja);

        System.out.println("Ajattele jotain lukua väliltä " + alaraja + "..." + ylaraja + ".");

        System.out.println("Lupaan pystyä arvaamaan ajattelemasi luvun " + kysymyksiaKorkeintaan + " kysymyksellä.");
        System.out.println("");
        System.out.println("Esitän sinulle seuraavaksi sarjan kysymyksiä. Vastaa niihin rehellisesti.");
        System.out.println("");
    }

    // apumetodi
    public int kuinkaMontaKertaaVoiJakaaKahteen(int luku) {
        // luodaan kaksikantainen logaritmi annetusta luvusta, logaritmeista
        // löytyy lisää tietoa mm. osoitteessa

        // http://www02.oph.fi/etalukio/pitka_matematiikka/kurssi8/maa8_teoria7.html

        // Alla vaihdamme kantalukua alkuperäisestä kaksikantaisiin logaritmeihin!
        return (int) (Math.log(luku) / Math.log(2)) + 1;
    }
}
</pre>
<p>Peli käynnistetään seuraavasti:</p>
<pre class="sh_java">
// luodaan peli-olio
Arvauspeli peli = new Arvauspeli();

// pelataan pari kierrosta
peli.pelaa(1,10);  // arvattava luku nyt välillä 1-10
peli.pelaa(10,99);  // arvattava luku nyt välillä 10-99
</pre>
  <p>Toteutetaan tämä tehtävä askeleittain.</p>
  <h4>Onko suurempi kuin</h4>
  <p>Toteuta luokalle <code>Arvauspeli</code> metodi <code>public boolean onkoSuurempiKuin(int luku)</code>, joka esittää käyttäjälle kysymyksen:</p>
<pre>
"Onko lukusi suurempi kuin <em>annettu luku</em>? (k/e)"
</pre>
  <p>Metodi palauttaa arvon <code>true</code> jos käyttäjä vastaa "k", muulloin <code>false</code>.</p>
  <p><b>Huom:</b> metodin tulee lukea käyttäjän syöte luokan Arvauspeli oliomuuttujassa <code>this.lukija</code> olevaa lukijaa hyväksikäyttäen. Metodissa ei saa luoda uutta lukijaa!</p>
  <p>Testaa metodisi toimintaa</p>
<pre class="sh_java">
Arvauspeli peli = new Arvauspeli();

System.out.println(peli.onkoSuurempiKuin(32));
System.out.println(peli.onkoSuurempiKuin(99));
</pre>
<pre>
Onko lukusi suurempi kuin 32? (k/e)
<font color="red">k</font>
true
Onko lukusi suurempi kuin 99? (k/e)
<font color="red">e</font>
false
</pre>
  <h4>Keskiarvo</h4>
  <p>Toteuta luokalle <code>Arvauspeli</code> metodi <code>public int keskiarvo(int ekaLuku, int tokaLuku)</code>, joka laskee annettujen lukujen keskiarvon. Huomaa että Java pyöristää liukuluvut luvut automaattisesti alaspäin, tämä on meidän tapauksessamme täysin toivottavaa.</p>
<pre class="sh_java">
Arvauspeli peli = new Arvauspeli();

System.out.println(peli.keskiarvo(3, 4));
System.out.println(peli.keskiarvo(6, 12));
</pre>
  <pre>
  3
  9
</pre>
  <h4>Arvauslogiikka</h4>
  <p>Kirjoita varsinainen arvauslogiikka luokan <code>Arvauspeli</code> metodin <code>public void pelaa(int alaraja, int ylaraja)</code> runkoon. Tarvitset ainakin toistolauseen, sekä kyselyn jossa kysyt onko käyttäjän ajattelema luku suurempi kuin ala- ja ylärajan keskiarvo.
    Käytä edellisten kohtien metodeja kyselyyn ja keskiarvon selvittämiseen.
    Muokkaa toistolauseessa ala- tai ylärajaa käyttäjän vastauksesta riippuen.</p>
  <p>Jatka toistolausekkeen toistoa kunnes alaraja ja yläraja ovat samat! Voit testata peliä myös pienemmillä ala- ja ylärajan arvoilla:</p>
<pre>
Ajattele jotain lukua väliltä 1...4.
Lupaan pystyä arvaamaan ajattelemasi luvun 2 kysymyksellä.

Esitän sinulle seuraavaksi sarjan kysymyksiä. Vastaa niihin rehellisesti.

Onko lukusi suurempi kuin 2? (k/e)
<font color="red">k</font>
Onko lukusi suurempi kuin 3? (k/e)
<font color="red">k</font>
Ajattelemasi luku on 4.
</pre>
</div>
<div class="tehtava">
  <h3>Binäärihaun toteutus</h3>
  <p>Testiautomaatista tulevassa rungossa on pohja binäärihaun toteutukselle. Luokka <code>BinaariHaku</code> sisältää metodin <code>public static boolean hae(int[] taulukko, int etsittavaLuku)</code>, jonka tehtävänä on selvittää binäärihakua käyttäen, onko parametrina annettu luku parametrina annetussa järjestyksessä olevassa taulukossa.</p>
  <p>Metodi <code>hae</code> ei kuitenkaan toimi vielä. Viimeistele metodin toteutus oikeaksi binäärihauksi.</p>
  <p>Ohjelman testausta varten on erillinen pääohjelma luokassa <code>Main</code>, jonka runko on seuraava:</p>
<pre class="sh_java">

import java.util.Arrays;
import java.util.Scanner;

public class Main {
    public static void main(String[] args) {
        // Tässä voit testata binäärihakua
        int[] taulukko = { -3, 2, 3, 4, 7, 8, 12 };
        Scanner lukija = new Scanner(System.in);

        System.out.print("Taulukon luvut: " + Arrays.toString(taulukko));
        System.out.println();

        System.out.print("Anna haettava luku: ");
        String etsittavaLuku = lukija.nextLine();
        System.out.println();

        boolean tulos = BinaariHaku.hae(taulukko, Integer.parseInt(etsittavaLuku));

        // Tulosta tässä binäärihaun tulos
    }
}
</pre>
  <p>Ohjelman suoritus näyttää seuraavalta:</p>
  <pre>
Taulukon luvut: [-3, 2, 3, 4, 7, 8, 12]

Anna haettava luku: <font color="red">8</font>

Luku 8 on taulukossa
</pre>
<pre>
Taulukon luvut: [-3, 2, 3, 4, 7, 8, 12]

Anna haettava luku: <font color="red">99</font>

Luku 99 ei ole taulukossa
</pre>
</div>
</div>
<h2>Taulukoista ja olioista</h2>
<p>Jos tarvetta on, taulukkoon voi luonnollisesti laittaa minkä tahansa tyyppisen olion.
  Seuraavassa esimerkki taulukosta johon talletetaan <em>Henkilo</em>-olioita:</p>
<pre class="sh_java">
public static void main(String[] args) {
    Henkilo[] henkilot = new Henkilo[3];

    henkilot[0] = new Henkilo("Pekka");
    henkilot[1] = new Henkilo("Antti");
    henkilot[2] = new Henkilo("Juhana");

    for ( int i=0; i &lt; 30; i++ ) {
        henkilot[0].vanhene();
        henkilot[1].vanhene();
        henkilot[2].vanhene();
    }

    for ( Henkilo henkilo : henkilot ) {
        ilmoitaTaysiIkaisyys(henkilo);
    }
}
</pre>
<p>Alussa luodaan taulukko johon mahtuu 3 henkilöolioa. Laitetaan Pekka lokeroon 0, Antti lokeroon 1 ja Juhana lokeroon 2. Vanhennetaan kaikkia 30 vuotta ja tarkastetaan kaikkien täysi-ikäisyys edellisen luvun metodia hyödyntäen.</p>
<p>Sama esimerkki ArrayListien avulla:</p>
<pre class="sh_java">
public static void main(String[] args) {
    ArrayList&lt;Henkilo&gt; henkilot = new ArrayList&lt;Henkilo&gt;();

    henkilot.add( new Henkilo("Pekka") );
    henkilot.add( new Henkilo("Antti") );
    henkilot.add( new Henkilo("Juhana") );

    for ( int i=0; i &lt; 30; i++ ) {
        for ( Henkilo henkilo : henkilot ) {
            henkilo.vanhene();
        }

        // tai henkilot.get(0).vanhene();
        //     henkilot.get(1).vanhene();
        //     ...
    }

    for ( Henkilo henkilo : henkilot ) {
        ilmoitaTaysiIkaisyys(henkilo);
    }
}
</pre>
<p>Useimmissa sovellustilanteissa taulukon sijaan kannattaa käyttää ArrayListiä. Voi kuitenkin olla joitain tilanteita joissa taulukko riittää ja on hieman yksinkertaisempi käyttää.</p>
<p>Viikko koostuu aina seitsemästä päivästä. Viikko-olio olisikin mielekästä koostaa tasan seitsemästä päiväoliosta. Koska päiva-olioita on aina täsmälleen 7, sopii taulukko tilanteeseen hyvin:</p>
<pre class="sh_java">
public class Paiva {
      private String nimi;
      // ...
}

public class Viikko {
    private Paiva[] paivat;

    public Viikko(){
        paivat = new Paiva[7];
        paivat[0] = new Paiva("Maanantai");
        paivat[1] = new Paiva("Tiistai");
        // ...
    }
}
</pre>
  <h2 class="ahy">Kurssipalaute</h2>
  <h2 class="amooc">Palaute</h2>
  <div class="tehtavat">
    <div class="tehtava">
    <h3 class="ahy">Kurssipalaute</h3>
    <h3 class="amooc">Palaute</h3>
    <div>
      <p>Vaikka olemme saaneet paljon arvokasta palautetta eri tehtävistä TMC:n kautta, toivomme että annatte palautetta kattavammin kaikista tähänastisita tehtävistä, materiaalista yms.</p>
    </div>
  <p>Jotta saat merkatuksi tämän tehtävän, aja tehtävän TMC-testit ja lähetä tehtävä palvelimelle. </p>
</div>
</div>
</div>
</section>
<!-- BEGIN MOOC SNIP -->
<!-- BEGIN SNIP -->
<div class="tyhja"></div>
<div class="viikkoraja">Hylätyt</div>
<section class="hylatty" id="hylatty">
  <h2>Ongelman ratkaiseminen paloittain</h2>
  <p>Käydään vielä kurssin lopuksi läpi esimerkki jossa tehdään ohjelma seuraavaan tilanteeseen jossa käyttäjältä kysellään sanoja, kunnes käyttäjä antaa saman sanan uudestaan. Tehdään oletus, että käyttäjä antaa korkeintaan 1000 sanaa.</p>
  <pre>
      Anna sana: <span class="red">porkkana</span>
      Anna sana: <span class="red">selleri</span>
      Anna sana: <span class="red">nauris</span>
      Anna sana: <span class="red">lanttu</span>
      Anna sana: <span class="red">selleri</span>
      Annoit saman sanan uudestaan!
    </pre>
  <p>Osin ongelmien syy saattoi olla, että oli vaikea päättää miten lähestyä tehtävää, eli miten jäsentää ongelmaa ja mistä aloittaa.</p>
  <p>Ongelma koostuu oikeastaan kahdesta "aliongelmasta". Ensimmäinen on sanojen toistuva lukeminen käyttäjältä kunnes tietty ehto toteutuu. Tämä voitaisiin hahmotella seuraavaan tapaan ohjelmarungoksi:</p>
  <pre class="sh_java">
      public static void main(String[] args) {
      while ( true ) {
      String sana = lukija.nextLine();

      if ( "pitää lopettaa" ) {
      break;
    }
  }

  System.out.println("Annoit saman sanan uudestaan");
}
</pre>
  <p>Sanojen kysely pitää lopettaa siinä vaiheessa kun on syötetty jokin jo aiemmin syötetty sana. Päätetään tehdä metodi, joka huomaa että sana on jo syötetty. Vielä ei tiedetä miten metodi kannattaisi tehdä, joten tehdään siitä vasta runko: </p>
  <pre class="sh_java">
  public static void main(String[] args) {
  while ( true ) {
  String sana = lukija.nextLine();

  if ( onJoSyotetty( sana ) ) {
  break;
}
}

System.out.println("Annoit saman sanan uudestaan");
}

public static boolean onJoSyotetty(String sana) {
// tänne jotain
}
</pre>
  <p>Ohjelmaa on hyvä testata koko ajan, joten tehdään metodista kokeiluversio:</p>
  <pre class="sh_java">
  public static boolean onJoSyotetty(String sana) {
  if ( sana.equals("loppu") ) {
  return true;
}

return false;
}
</pre>
  <p>Eli toisto jatkuu nyt niin kauan kunnes syötteenä on sana loppu:</p>
  <pre>
  Anna sana: <span class="red">porkkana</span>
  Anna sana: <span class="red">selleri</span>
  Anna sana: <span class="red">nauris</span>
  Anna sana: <span class="red">lanttu</span>
  Anna sana: <span class="red">loppu</span>
  Annoit saman sanan uudestaan!
</pre>
  <p>Ohjelma ei siis toimi vielä kokonaisuudessaan, mutta ensimmäinen osaongelma eli ohjelman pysäyttäminen kunnes tietty ehto toteutuu on saatu toimimaan.</p>
  <p>Toinen osaongelma on aiemmin syötettyjen sanojen muistaminen. Taulukko sopii tietysti mainiosti tähän tarkoitukseen. Tarvitaan myös muuttuja joka muistaa kuinka monta sanaa on syötetty:</p>
  <pre class="sh_java">
  public static void main(String[] args) {
  String[] aiemmatSanat = new String[1000];
  int sanojaSyotetty = 0;

  // ...
}
</pre>
  <p>Kun uusi sana syötetään, on se lisättävä syötettyjen sanojen joukkoon. Tämä tapahtuu lisäämällä main:in while-silmukkaan taulukkoa ja sanojen laskuria päivittävät rivit:</p>
  <pre class="sh_java">
  while ( true ) {
  String sana = lukija.nextLine();

  if ( onJoSyotetty( sana, aiemmatSanat, sanojaSyotetty ) ) {
  break;
}

// lisätään uusi sana aiempien sanojen taulukkoon
aiemmatSanat[sanojaSyotetty] = sana;
sanojaSyotetty++;
}
</pre>
  <p>Jälleen kannattaa testata, että ohjelma toimii edelleen. Voi olla hyödyksi esim. lisätä ohjelman loppuun testitulostus, joka varmistaa että syötetyt sanat todella menivät taulukkoon:</p>
  <pre class="sh_java">
  while ( true ) {
  // ...

  // lisätään uusi sana aiempien sanojen taulukkoon
  aiemmatSanat[sanojaSyotetty] = sana;
  sanojaSyotetty++;
}

// testitulostus joka varmistaa että kaikki toimii edelleen
for ( int i=0; i &lt; sanojaSyotetty; i++ ) {
System.out.println( aiemmatSanat[sanojaSyotetty] );
}
</pre>
  <p>Muokataan vielä äsken tekemämme metodi <code>onJoSyotetty</code> tutkimaan onko kysytty sana jo syötettyjen joukossa, eli taulukon käytössä olevassa alkuosassa:</p>
  <pre class="sh_java">
  public static boolean onJoSyotetty(String sana, String[] aiemmatSanat, int sanojaSyotetty) {
  for ( int i=0; i &lt; sanojaSyotetty; i++ ) {
  if ( sana.equals( aiemmatSanat[i] ) )
  return true;
}

return false;
}

public static void main(String[] args) {
String[] aiemmatSanat = new String[1000];
int sanojaSyotetty = 0;

while ( true ) {
String sana = lukija.nextLine();

if ( onJoSyotetty( sana, aiemmatSanat, sanojaSyotetty ) )
break;

aiemmatSanat[sanojaSyotetty] = sana;
sanojaSyotetty++;
}

System.out.println("Annoit saman sanan uudestaan");
}
</pre>
  <p>Nyt koodi on valmis ja alkaa olla kohtuullisen luettava. Emme kuitenkaan ole koodiin täysin tyytyväisiä. Valitettavasti emme vielä osaa tarpeeksi Javaa tehdäksemme "lopullista" siistiä versiota. Ensi viikolla kuitenkin otamme ratkaisevan askeleen jolla saamme koodin siistiksi.</p>
  <big><strong>Eli ohjelmoidessasi, seuraa aina näitä neuvoja:</strong></big>
  <ul>
    <li> Etene pieni askel kerrallaan
      <ul>
        <li> Yritä pilkkoa ongelma osaongelmiin ja <strong>ratkaise vain yksi osaongelma kerrallaan</strong> </li>
        <li> Testaa aina että ohjelma on etenemässä oikeaan suuntaan eli että osaongelman ratkaisu meni oikein</li>
      </ul>
    </li>
    <li> Kirjoita mahdollisimman "siistiä" koodia
      <ul>
        <li> sisennä koodi </li>
        <li> käytä kuvaavia muuttujien ja metodien nimiä</li>
        <li> älä tee liian pitkiä metodeja, edes mainia</li>
        <li> tee yhdessä metodissa vaan yksi asia</li>
        <li> <strong>poista koodistasi kaikki copy-paste</strong></li>
        <li> korvaa koodisi "huonot" ja epäsiistit osat siistillä koodilla</li>
      </ul>
    </li>
  </ul>
  <p>Hyvät ja kokeneet ohjelmoijat noudattavat näitä käytänteitä sen takia että ohjelmointi olisi helpompaa, ja että ohjelmien lukeminen, ylläpitäminen ja muokkaaminen olisi helpompaa.</p>
  <h2>Koodissa on käsite! Tehdään siitä olio!</h2>
  <p>Rakensimme äsken askel askeleelta ratkaisun seuraavaan tehtävään:</a>
  <p>Tee ohjelma, joka kysyy käyttäjältä sanoja,
    kunnes käyttäjä antaa saman sanan uudestaan.
    Voit olettaa, että käyttäjä antaa korkeintaan 1000 sanaa.</p>
  <pre>
          Anna sana: <span class="red">porkkana</span>
          Anna sana: <span class="red">selleri</span>
          Anna sana: <span class="red">nauris</span>
          Anna sana: <span class="red">lanttu</span>
          Anna sana: <span class="red">selleri</span>
          Annoit saman sanan uudestaan!
        </pre>
  <p>Päädyimme ratkaisuun</p>
  <pre class="sh_java">
          public static boolean onJoSyotetty(String sana, String[] aiemmatSanat, int sanojaSyotetty) {
          for ( int i=0; i &lt; sanojaSyotetty; i++ ) {
          if ( sana.equals( aiemmatSanat[i] ) )
          return true;
        }

        return false;
      }

      public static void main(String[] args) {
      String[] aiemmatSanat = new String[1000];
      int sanojaSyotetty = 0;

      while ( true ) {
      String sana = lukija.nextLine();

      if ( onJoSyotetty( sana, aiemmatSanat, sanojaSyotetty ) )
      break;

      aiemmatSanat[sanojaSyotetty] = sana;
      sanojaSyotetty++;
    }

    System.out.println("Annoit saman sanan uudestaan");
  }
</pre>
  <p>Totesimme, että vaikka ratkaisu alkaa olla ymmärrettävyydeltään ihan kohtuullinen, jokin siinä edelleen jäi vaivaamaan.</p>
  <p>Pääohjelman käyttämät apumuuttujat, eli taulukko <code>aiemmatSanat</code> ja kokonaisluku <code>sanojaSyotetty</code> ovat todella ikäviä "matalan tason" detaljeja pääohjelman kannalta. Pääohjelman kannaltahan on oleellista, että muistetaan niiden <i>sanojen joukko</i> jotka on nähty jo aiemmin. Sanojen joukko, tämähän on selkeä erillinen "käsite", tai abstraktio. Tälläiset selkeät käsitteet ovat potentiaalisia olioita ja huomattuaan koodissaan "käsitteen" viisas ohjelmoija eristää sen luokaksi.</p>
  <p>Eli päätämme tehdä luokan <code>Sanajoukko</code>. Haluaisimme, että pääohjelma näyttää seuraavalta:</p>
  <pre class="sh_java">
  public static void main(String[] args) {
  Sanajoukko aiemmatSanat = new Sanajoukko();

  while (true) {
  String sana = lukija.nextLine();

  if ( aiemmatSanat.sisaltaa(sana) ) {
  break;
}

aiemmatSanat.lisaa(sana);
}

System.out.println("Annoit saman sanan uudestaan");
}
</pre>
  <p>Pääohjelman, eli sanajoukon käyttäjän kannalta Sanajoukko olisi hyvä jos sillä olisi metodit <code>boolean sisaltaa(String sana)</code> jolla tarkastetaan sisältyykö annettu sana jo sanajoukkoon ja <code>void lisaa(String sana)</code> jolla annettu sana lisätään joukkoon.</p>
  <p>Huomaamme, että näin kirjoitettuna pääohjelman luettavuus on huomattavasti parempi kuin taulukkoa käyttäen. Pääohjelma on lähes suomen kieltä!</p>
  <p>Luokan <code>Sanajoukko</code> runko näyttää seuraavanlaiselta:</p>
  <pre class="sh_java">
  public class Sanajoukko {
  // sopivia oliomuuttujia

  public Sanajoukko() {
  // ...
}

public boolean sisaltaa(String sana) {
// ...
}

public void lisaa(String sana) {
// ...
}
}
</pre>
  <p>Voimme toteuttaa sanajoukon siirtämällä aiemman ratkaisumme taulukon sanajoukon oliomuuttujaksi:</p>
  <pre class="sh_java">
  public class Sanajoukko {
  private String[] joukonSanat;
  private int sanojaSyotetty;

  public Sanajoukko() {
  joukonSanat = new String[1000];
  sanojaSyotetty = 0;
}

// ...
}
</pre>
  <p>Oliomuuttujien alustus tapahtuu tuttuun tapaan konstruktorissa.</p>
  <p>Uuden sanan lisääminen on helppoa. Koska <code>sanojaSyotetty</code> muistaa monta sanaa taulukossa jo on, ja taulukon indeksit alkavat nollasta, tulee uusi sana juuri tähän paikkaan. Muuttujan arvo pitää muistaa vielä kasvattaa:</p>
  <pre class="sh_java">
  public class Sanajoukko {
  private String[] joukonSanat;
  private int sanojaSyotetty;

  public Sanajoukko() {
  joukonSanat = new String[1000];
  sanojaSyotetty = 0;
}

public void lisaa(String sana) {
joukonSanat[ sanojaSyotetty ] = sana;
sanojaSyotetty++;
}

// ...
}
</pre>
  <p>Ja vielä metodi, jolla tarkistetaan onko sana jo joukossa. Eli käydään sanat muistavan taulukon alkuosaa läpi syötettyjen sanojen verran ja palautetaan true jos etsitty sana löytyy:</p>
  <pre class="sh_java">
  public class Sanajoukko {
  private String[] joukonSanat;
  private int sanojaSyotetty;

  public Sanajoukko() {
  joukonSanat = new String[1000];
  sanojaSyotetty = 0;
}

public boolean sisaltaa(String sana) {
for ( int i=0; i &lt; sanojaSyotetty; i++ ) {
if ( joukonSanat[i].equals(sana) )
return true;
}

return true;
}

public void lisaa(String sana) {
joukonSanat[ sanojaSyotetty ] = sana;
sanojaSyotetty++;
}
}
</pre>
  <p>Ratkaisu on nyt varsin elegantti. Erillinen käsite on saatu erotettua ja pääohjelma näyttää siistiltä. Kaikki "likaiset yksityiskohdat" (taulukko ja lukumäärä sanoista) on saatu siivottua eli kapseloitua olion sisälle.</p>
  <p>Yhtäkkiä mieleemme palaa toissa viikolla esitelty ArrayList. Sanojen muistaminenhan voidaan toteuttaa helposti ArrayList:illa! Päätämme korvata luokan <code>Sanajoukko</code> sisällä olevan taulukon listalla:</p>
  <pre class="sh_java">
  import java.util.ArrayList;

  public class Sanajoukko {
  private ArrayList&lt;String&gt; joukonSanat;

  public Sanajoukko() {
  joukonSanat = new ArrayList&lt;String&gt; ();
}

public boolean sisaltaa(String sana) {
return joukonSanat.contains(sana);
}

public void lisaa(String sana) {
joukonSanat.add(sana);
}
</pre>
  <p>Näin päädytään ratkaisuun jossa <code>Sanajoukko</code> on ainoastaan ArrayList:in "wräpperi". Onko tässä järkeä? Kenties. Voimme nimittäin halutessamme tehdä Sanajoukolle muitakin muutoksia. Ennen pitkään saatamme esim. huomata, että sanajoukko pitää tallettaa tiedostoon. Jos tekisimme nämä muutokset Sanajoukon koodiin, ei pääohjelmaa tarvitsisi muuttaa mitenkään.</p>
  <p>Voi olla, että jatkossa ohjelmaa halutaan laajentaa siten, että <code>Sanajoukko</code>-luokan olisi osattava uusia asiota. Jos esim. pääohjelmassa haluttaisiin tietää kuinka moni syötetyistä sanoista oli palindromi, voidaan sanajoukkoa laajentaa metodilla <code>palindromeja</code>: </p>
  <pre class="sh_java">
  public static void main(String[] args) {
  Sanajoukko aiemmatSanat = new Sanajoukko();

  while (true) {
  String sana = lukija.nextLine();

  if ( aiemmatSanat.sisaltaa(sana) ) {
  break;
}

aiemmatSanat.lisaa(sana);
}

System.out.println("Annoit saman sanan uudestaan");
System.out.println("Sanoistasi " + aiemmatSanat.palindromeja() + "oli palindromeja");
}
</pre>
  <p>Pääohjelma säilyy siistinä, viimeisellä rivillä kutsutaan uutta hyvin nimettyä metodia, palindromien laskeminen jää <code>Sanajoukko</code>-olion huoleksi. Metodin toteutus voisi olla seuraavanlainen:</p>
  <pre class="sh_java">
  public class Sanajoukko {
  private ArrayList&lt;String&gt;  joukonSanat;

  // ...

  public int palindromeja() {
  int palindromit = 0;

  for ( String sana : joukonSanat ) {
  if ( onPalindromi(sana) )
  palindromit++;
}

return palindromit;
}

private boolean onPalindromi(String sana){
int loppu = sana.length()-1;
for ( int i=0; i %lt; sana.length()/2; i++ ){
if ( sana.charAt(i) != sana.charAt(loppu-i) )
return false;
}

return true;
}
</pre>
  <p>Eli metodi <code>palindromeja</code> käy läpi kaikki joukon sanat ja apumetodin <code>onPalindromi</code> avulla laskee paindromien määrän. </p>
  <p>Koska apumetodi <code>onPalindromi</code> on tarkoitettu ainoastaan olion sisäiseen käyttöön, on sen <i>näkyvyysmääreeksi</i> määritelty <code>private</code>. Olion käyttäjän siis ei ole mahdollista kutsua metodia, metodia voi kutsua ainoastaan olion sisältä.</p>
  <p>Jos sanojen talletukseen olisi käytetty suoraan ArrayList:iä, olisi palindromien laskeminen vaatinut pääohjelman koodiin suurempia muutoksia kuin Sanajoukko-luokan käyttö. Joskus on toki tilanteita, joissa kannattaa käyttää suoraan valmista kalustoa eikä oman luokan määrittelylle ole tarvetta. Kuitenkin jos koodin luettavuus alkaa kärsimään, on selkeistä käsitteistä syytä tehdä omat luokkansa. Kuten näimme tämä parhaassa tapauksessa mahdollistaa ohjelman laajennettavuutta ja muokattavuutta.</p>
  </div>

  <!--
<hr />
<strong>Viikko 6 loppuu</strong>
<hr />
-->

  <h2>Tehtävien hautausmaa</h2>
  <p><big>Loppuivatko tehtävät kesken?
    Ei hätää: saatavilla on lisätehtäväsarja <a href="sokkelotehtava.html">Ohpesokkelo</a>.
    Siinä tehdään graafinen labyrinttipeli!</big></p>
  </div>
  <div id="tehtavat" id="viikko7">
    <NEXTWEEK></NEXTWEEK>
    <h3 class="req">Arvauspeli</h3>
    <p>Tee yksinkertainen arvauspeli.
      Pelin toiminta alkaa sillä,
      että käyttäjältä kysytään arvattavat luvut: </p>
    <pre>
    Kuinka monta lukua? <font color="red">3</font>
    Anna luvut:
    <font color="red">5</font>
    <font color="red">2</font>
    <font color="red">11</font>
    Kiitos. Siirrytään arvausvaiheeseen.
  </pre>
    <p> Kun luvut on syötetty, tulostetaan 40 rivinvaihtoa
      kutsumalla komentoa System.out.println("") 40 kertaa.</p>
    <p> Tämän jälkeen käyttäjälle
      (joka on kenties eri ihminen kun lukujen syöttäjä)
      annetaan 3 arvausta.
      Arvausten jälkeen ilmoitetaan,
      kuinka monta arvauksista oli oikein.</p>
    <pre>
        Arvaa mitä lukuja taulukossa on.
        Saat kolme arvausta.
        <font color="red">4</font>
        <font color="red">99</font>
        <font color="red">2</font>
        Kiitos arvauksista. 1 oikein.
      </pre>
    <p><b>Tee peli käyttäen kahden edellisen tehtävän metodeja</b>. Pääohjelma muotoutuu seuraavaan tapaan:</p>
    <pre class="sh_java">
        public static void main(String[] args) {
        int [] luvut = kysyLuvut();
        // tulosta tyhjää

        int oikeatArvaukset = 0;
        // kolme arvausta
        for ( int i=0; i<3; i++ ) {
        // lue arvaus
        // tarkasta metodin onkoLukuTaulukossa avulla menikö arvaus oikein ja päivitä statistiikka
      }
      // tulosta oikeiden vastausten määrä
    }
  </pre>
    <h3 class="req">Arvauspeli versio 2.0</h3>
    <p>Laajennetaan edellistä tehtävää niin,
      että pelaajalla on rajaton määrä arvauksia.
      Kun käyttäjä antaa syötteenä -99, loppuu peli ja
      käyttäjälle ilmoitetaan arvausten lukumäärä ja
      oikeiden arvausten lukumäärä. Peli etenee seuraavasti:</p>
    <pre>
      Arvaa mitä lukuja taulukossa on.
      Kun kyllästyt, syötä -99.
      <font color="red">4</font>
      <font color="red">7</font>
      <font color="red">2</font>
      <font color="red">100</font>
      <font color="red">11</font>
      <font color="red">-99</font>
      Arvauksia oli 5, joista oikein 2.
    </pre>
    <h3>Arvauspeli versio 3.0</h3>
    <p>Laajennetaan edellistä tehtävää siten,
      että ohjelma kysyy pelin jälkeen,
      haluaako käyttäjä pelata uudestaan.
      Lopuksi ohjelma ilmoittaa,
      kuinka monta peliä pelattiin yhteensä.</p>
    <pre>
        Arvaa mitä lukuja taulukossa on. Kun kyllästyt, syötä -99.
        <font color="red">4</font>
        <font color="red">7</font>
        <font color="red">2</font>
        <font color="red">100</font>
        <font color="red">11</font>
        <font color="red">-99</font>
        Arvauksia oli 5, joista oikein 2.

        Uusi peli (k/e)? <font color="red">k</font>

        Arvaa mitä lukuja taulukossa on. Kun kyllästyt, syötä -99.
        <font color="red">-1</font>
        <font color="red">5</font>
        <font color="red">2</font>
        <font color="red">-99</font>
        Arvauksia oli 3, joista oikein 0.

        Uusi peli (k/e)? <font color="red">e</font>

        Pelaajia tänään 2.
      </pre>
    <h3>Kivi, paperi, sakset</h3>
    <p>Tässä tehtäväsarjassa tehdään tekoäly kivi, paperi, sakset -peliin.</p>
    <h4 class="req">Tekoälyn runko</h4>
    <p>Tee luokka <code>KPSTekoaly</code>,
      josta tulee tekoäly kivi, paperi, sakset -peliin.
      Luokkaan tulee metodi <code>teeSiirto</code>,
      joka palauttaa tekoälyn tekemän siirron.
      Merkkijonot <code>"k"</code>, <code>"p"</code> ja <code>"s"</code> vastaavat siirtoja kivi, paperi ja sakset.</p>
    <p>Tee tekoälystä ensin sellainen,
      että sen siirto on aina kivi.</p>
    <p>Luokan runko on seuraava:</p>
    <pre class="sh_java">
            import java.util.*;
            public class KPSTekoaly {
            public String teeSiirto() {
            // kirjoita koodia tähän
          }
        }
      </pre>
    <p>Pääluokka näyttää seuraavalta:</p>
    <pre class="sh_java">
        import java.util.Scanner;
        public class Main {
        public static void main(String[] args) {
        static Scanner lukija = new Scanner(System.in);

        KPSTekoaly tekoaly = new KPSTekoaly();
        System.out.print("Kuinka monta kierrosta? ");
        int kierrokset = Integer.parseInt(lukija.nextLine());
        for (int i = 0; i < kierrokset; i++) {
        System.out.print("Anna siirto (k, p tai s): ");
        String pelaajanSiirto = lukija.nextLine();
        String tekoalynSiirto = tekoaly.teeSiirto();
        System.out.println("Pelaajan siirto: " + pelaajanSiirto);
        System.out.println("Tekoälyn siirto: " + tekoalynSiirto);
      }
    }
  }
</pre>
    <p>Peli voi edetä esimerkiksi seuraavasti:</p>
    <pre>
  Kuinka monta kierrosta? <font color="red">3</font>
  Anna siirto (k, p tai s): <font color="red">s</font>
  Pelaajan siirto: s
  Tekoälyn siirto: k
  Anna siirto (k, p tai s): <font color="red">p</font>
  Pelaajan siirto: p
  Tekoälyn siirto: k
  Anna siirto (k, p tai s): <font color="red">k</font>
  Pelaajan siirto: k
  Tekoälyn siirto: k
</pre>
    <h4 class="req">Voittajan tarkistus</h4>
    <p>Lisää projektiin vielä yksi luokka <code>KPSTuomari</code>,
      jonka runko on seuraava:</p>
    <pre class="sh_java">
    public class KPSTuomari {
    public void maaritaVoittaja(String pelaajanSiirto, String tekoalynSiirto) {
    // kirjoita koodia tähän
  }
}
</pre>
    <p>Metodin <code>maaritaVoittaja</code> tarkoituksena
      on selvittää pelaajan ja tekoälyn siirtojen perusteella,
      kumpi on voittaja vai tuliko tasapeli.
      Toteuta metodi niin, että se tulostaa tiedon voittajasta.</p>
    <p>Kivi, paperi, sakset -pelissä
      kivi voittaa sakset,
      sakset voittavat paperin
      ja paperi voittaa kiven.</p>
    <p>Pääluokka on nyt seuraava:</p>
    <pre class="sh_java">
      import java.util.Scanner;

      public class Main {
      private static Scanner lukija = new Scanner(System.in);

      public static void main(String[] args) {
      KPSTekoaly tekoaly = new KPSTekoaly();
      KPSTuomari tuomari = new KPSTuomari();
      System.out.print("Kuinka monta kierrosta? ");
      int kierrokset = Integer.parseInt(lukija.nextLine());
      for (int i = 0; i < kierrokset; i++) {
      System.out.print("Anna siirto (k, p tai s): ");
      String pelaajanSiirto = lukija.nextLine();
      String tekoalynSiirto = tekoaly.teeSiirto();
      System.out.println("Tekoälyn siirto: " + tekoalynSiirto);
      tuomari.maaritaVoittaja(pelaajanSiirto, tekoalynSiirto);
    }
  }
}
</pre>
    <p>Peli voi edetä esimerkiksi seuraavasti:</p>
    <pre>
  Kuinka monta kierrosta? <font color="red">3</font>
  Anna siirto (k, p tai s): <font color="red">s</font>
  Tekoälyn siirto: k
  Tekoäly voitti!
  Anna siirto (k, p tai s): <font color="red">p</font>
  Tekoälyn siirto: k
  Pelaaja voitti!
  Anna siirto (k, p tai s): <font color="red">k</font>
  Tekoälyn siirto: k
  Tuli tasapeli!
</pre>
    <h4 class="req">Satunnainen tekoäly</h4>
    <p>Nyt on aika tehdä tekoälystä parempi,
      koska ei ole järkevää, että tekoäly valitsee aina kiven.</p>
    <p>Tee tekoälystä <i>satunnainen</i>:
      se valitsee yhtä todennäköisesti kiven, saksen ja paperin.</p>
    <h4 class="req">Pisteenlasku</h4>
    <p>Laajenna tuomariluokkaa niin,
      että se pitää kirjaa pelaajan ja tekoälyn voitoista.
      Lisää luokkaan myös metodi <code>tulostaTilasto</code>,
      joka tulostaa tilaston voitoista.
      Lisää tämän metodin kutsu pääohjelman loppuun.</p>
    <pre>
        Kuinka monta kierrosta? <font color="red">5</font>
        Anna siirto (k, p tai s): <font color="red">s</font>
        Tekoälyn siirto: s
        Tuli tasapeli!
        Anna siirto (k, p tai s): <font color="red">p</font>
        Tekoälyn siirto: s
        Tekoäly voitti!
        Anna siirto (k, p tai s): <font color="red">k</font>
        Tekoälyn siirto: k
        Tuli tasapeli!
        Anna siirto (k, p tai s): <font color="red">s</font>
        Tekoälyn siirto: p
        Pelaaja voitti!
        Anna siirto (k, p tai s): <font color="red">s</font>
        Tekoälyn siirto: k
        Tekoäly voitti!

        Tilasto:
        Pelaaja: 1 voittoa
        Tekoäly: 2 voittoa
      </pre>
    <h4>Muistava tekoäly</h4>
    <p>Lisää tekoälyyn <i>muisti</i>:
      tekoäly ottaa siirtonsa valinnassa huomioon,
      mitä käyttäjä on valinnut aiemmin eri tilanteissa.
      Päätä itse, millä tavoin tarkalleen tekoäly
      hyödyntää muistia.</p>
    <p>Lisää tekoälyyn metodi <code>kirjaaSiirto</code>,
      jota kutsutaan käyttäjän siirron jälkeen.
      Sen avulla tekoäly saa tietoonsa,
      mitä siirtoja käyttäjä on tehnyt.</p>
    <p>Pääluokkaan tehdään seuraava muutos:</p>
    <pre class="sh_java">
            ...
            String pelaajanSiirto = lukija.nextLine();
            String tekoalynSiirto = tekoaly.teeSiirto();
            tekoaly.kirjaaSiirto(pelaajanSiirto);
            System.out.println("Tekoälyn siirto: " + tekoalynSiirto);
            ...
          </pre>
    <p>Jos tekoäly käyttää muistiaan hyvin,
      se voi sopeutua esimerkiksi tilanteeseen,
      jossa käyttäjä valitsee aina saman siirron:</p>
    <pre>
              Kuinka monta kierrosta? <font color="red">5</font>
              Anna siirto (k, p tai s): <font color="red">s</font>
              Tekoälyn siirto: p
              Pelaaja voitti!
              Anna siirto (k, p tai s): <font color="red">s</font>
              Tekoälyn siirto: k
              Tekoäly voitti!
              Anna siirto (k, p tai s): <font color="red">s</font>
              Tekoälyn siirto: k
              Tekoäly voitti!
              Anna siirto (k, p tai s): <font color="red">s</font>
              Tekoälyn siirto: k
              Tekoäly voitti!
              Anna siirto (k, p tai s): <font color="red">s</font>
              Tekoälyn siirto: k
              Tekoäly voitti!

              Tilasto
              Pelaaja: 1 voittoa
              Tekoäly: 4 voittoa
            </pre>
  </div>
  <h2>Taulukoista ja olioista</h2>
  <h3>Oliot taulukossa</h3>
  <p>Tutkitaan vielä olioiden lisäämistä taulukkoon:</p>
  <pre class="sh_java">
            public static void main(String[] args) {
            Henkilo[] henkilot = new Henkilo[3];

            henkilot[0] = new Henkilo("Pekka");
            henkilot[1] = new Henkilo("Antti");
            henkilot[2] = new Henkilo("Juhana");

            for ( int i=0; i &lt; 30; i++ ) {
            henkilot[0].vanhene();
            henkilot[1].vanhene();
            henkilot[2].vanhene();
          }

          for ( Henkilo henkilo : henkilot )
          ilmoitaTaysiIkaisyys(henkilo);
        }
      </pre>
  <p>Alussa luodaan taulukko johon mahtuu 3 henkilöolioa. Laitetaan Pekka lokeroon 0, Antti lokeroon 1 ja Juhana lokeroon 2. Vanhennetaan kaikkia 30 vuotta ja tarkastetaan kaikkien täysi-ikäisyys edellisen luvun metodia hyödyntäen.</p>
  <p>Sama esimerkki ArrayListien avulla:</p>
  <pre class="sh_java">
        public static void main(String[] args) {
        ArrayList&lt;Henkilo&gt; henkilot = new ArrayList&lt;Henkilo&gt;();

        henkilot.add( new Henkilo("Pekka") );
        henkilot.add( new Henkilo("Antti") );
        henkilot.add( new Henkilo("Juhana") );

        for ( int i=0; i &lt; 30; i++ ) {
        for ( Henkilo henkilo : henkilot ) {
        henkilo.vanhene();
      }

      // tai henkilot.get(0).vanhene();
      //     henkilot.get(1).vanhene();
      //     ...
    }

    for ( Henkilo henkilo : henkilot ) {
    ilmoitaTaysiIkaisyys(henkilo);
  }
}
</pre>
  <p>Usein tahdotaan myös tehdä olioista loogisesti riippumattomista apuri-metodeista staattisia. Tästä sopiva esimerkki olisi luvun 24 <code>Sanajoukko</code>-esimerkissä esiintynyt <code>onPalindromi</code>-metodi. Kuten koodista nähdään, ei metodissa viitata lainkaan oliomuuttujiin.</p>
  <pre class="sh_java">
  public class Sanajoukko {
  /* Muu luokan määrittely */

  private static boolean onPalindromi(String sana){
  int loppu = sana.length()-1;
  for ( int i=0; i &lt; sana.length()/2; i++ ){
  if ( sana.charAt(i) != sana.charAt(loppu-i) )
  return false;
}

return true;
}
}
</pre>
  <div class="tehtavat">
    <h3>Teksturi</h3>
    <p><b>HUOM: tehtävä on osoittautunut melko haastavaksi ollakseen viikon alkupään tehtävä. Jos et heti ymmärrä mitä tehtävässä ajetaan takaa, hyppää tehtävän yli ja palaa tähän siinä vaiheessa kun olet tehnyt viikon muut tehtävät.</b></p>
    <p>Tehtäväpohja sisältää Kurt Koodarin tekemän
      tekstinkäsittelyohjelman. Ohjelma on kuitenkin koodattu yhteen
      metodiin! Tehtävänäsi on <em>refaktoroida</em> eli siistiä Kurtin
      ohjelma edellisen tehtävän mallin mukaan.</p>
    <h4>Komennot pois mainista</h4>
    <p>Luo jokaiselle komennolle (paitsi lopeta) oma metodin.
      Komentoa vastaava metodi saa parametrinaan lukijan (jotta se voi
      kysyä käyttäjältä asioita) ja listan rivejä (jotta se voi muokata
      niitä). Toteuta siis metodit:</p>
    <ul>
      <li><code>public static void tulosta(Scanner lukija, ArrayList&lt;String&gt; rivit)</code></li>
      <li><code>public static void reset(Scanner lukija, ArrayList&lt;String&gt; rivit)</code></li>
      <li><code>public static void poista(Scanner lukija, ArrayList&lt;String&gt; rivit)</code></li>
      <li><code>public static void lisaa(Scanner lukija, ArrayList&lt;String&gt; rivit)</code></li>
      <li><code>public static void laske(Scanner lukija, ArrayList&lt;String&gt; rivit)</code></li>
    </ul>
    <p>Tämän jälkeen muuta main-metodi käyttämään lisäämiäsi metodeja
      komentojen toteuttamiseen. Uusi main-metodi siis vain kysyy
      komennon nimen ja sen jälkeen kutsuu oikeaa metodia ylläolevalta
      listalta. Ohjelman toiminnan pitää pysyä samanlaisena siistimisestä huolimatta!</p>
    <h4>Rivinumeron lukeminen</h4>
    <p>Edellisen askeleen jälkeen koodissa on kuitenkin vielä toistoa
      jäljellä: rivinumeroitten lukeminen. Lisää siis ohjelmaan
      metodi <code>public static int kysyRivinumero(String kysymys,
      Scanner lukija)</code>. Tämä metodi tulostaa kysymyksen ja lukee
      rivinumeron. Palautusarvo on -1 jos käyttäjä syötti tyhjän
      rivin.</p>
    <p><strong>vihje:</strong> voit ottaa toteutuksesi pohjaksi seuraavan metodirungon:</p>
    <pre class="sh_java">
            public static int kysyRivinumero(String kysymys, Scanner lukija) {
            System.out.println(kysymys);
            String rivi = // lue käytäjältä merkkijono

            // jos merkkijono oli tyhjä, palautetaan -1;
            if (rivi.isEmpty()) {
            return -1;
          }

          // muuten muuta rivi kokonaisluvuksi Integer.parseInt:illä ja palauta se
          return ...
        }
      </pre>
    <h4>Kutsu <code>kysyRivinumero</code>-metodia metodista <code>poista</code></h4>
    <p>Metodi <code>poista</code> lukee käyttäjältä rivinumeron. Muuta
      siis <code>poista</code>-metodi käyttämään edellisessä askeleessa
      toteuttamaasi <code>kysyRivinumero</code>-metodia</p>
    <h4>Kutsu <code>kysyRivinumero</code>-metodia metodista <code>lisaa</code></h4>
    <p>Myös metodi <code>lisaa</code> lukee käyttäjältä rivinumeron.
      Käytä rivinumeron lukemiseen <code>kysyRivinumero</code>-metodia</p>
    <h3>Pienin yhteinen jaettava</h3>
    <p>Tässä tehtävässä lasketaan kahden luvun pienin yhteinen jaettava näiden lukujen suurimman yhteisen tekijän avulla.</p>
    <p><a href="http://fi.wikipedia.org/wiki/Pienin_yhteinen_jaettava">Pienin yhteinen jaettava</a> on pienin kokonaisluku, joka on tasan jaollinen kyseessä olevilla luvuilla. Se voidaan laskea helposti, jos tiedetään kyseessä olevien lukujen suurin yhteinen tekijä. <a href="http://fi.wikipedia.org/wiki/Suurin_yhteinen_tekij%C3%A4">Suurin yhteinen tekijä</a> taas tarkoittaa suurinta sellaista lukua, joka jakaa kyseessä olevat luvut niin, että lopputulos on kokonaisluku (eli lukujen jakojäännös on nolla).</p>
    <p>Esimerkiksi lukujen 32 ja 6 suurin yhteinen tekijä on 2, koska 32 / 2 = 16 ja 6 / 2 = 3, eikä löydy suurempaa lukua kuin 2, jolla molemmat luvut, 32 ja 6, voitaisiin jakaa siten, että tuloksena olisi kokonaisluku.</p>
    <p>Lukujen 32 ja 6 pienin yhteinen jaettava on 96, koska 96 / 32 = 3 ja 96 / 6 = 16, eikä löydy pienempää lukua kuin 96, joka voitaisiin jakaa molemilla luvuilla, 32 ja 6, siten, että tuloksena olisi kokonaisluku.</p>
    <h4>Suurimman yhteisen tekijän laskeminen</h4>
    <p>Luo luokkaan <code>PieninYhteinenJaettava</code> metodi <code>public static int suurinYhteinenTekija(int luku1, int luku2)</code>, joka laskee parametreina annettujen lukujen suurimman yhteisen tekijän ja palauttaa vastaukseksi saadun luvun.</p>
    <p>Eräs tapa laskea suurin yhteinen tekijä on <a href="http://fi.wikipedia.org/wiki/Eukleideen_algoritmi">Eukleideen algoritmi</a>, joka on yksinkertainen toteuttaa ohjelmakoodissa.</p>
    <p>Eukleideen algoritmi toimii seuraavasti, kun lukuina ovat <code>a</code> ja <code>b</code> (muuttujaa <code>c</code> käytetään vain apuna):</p>
    <ol>
      <li>Jos <code>b</code> on <code>0</code>, niin algoritmi päättyy ja <code>a</code> on suurin yhteinen tekijä.</li>
      <li><code>c = a</code></li>
      <li><code>a = b</code></li>
      <li><code>b = c % b</code> (<code>%</code>-operaatio tarkoittaa jakojäännöstä eli moduloa)</li>
      <li>Palaa kohtaan 1.</li>
    </ol>
    <p>Esimerkiksi lukujen 32 ja 20 suurin yhteinen tekijä löytyy seuraavasti:</p>
    <ul>
      <li><code>a = 32, b = 20</code></li>
      <li><code>b != 0</code> eli algoritmi jatkuu.</li>
      <li><code>c = 32</code></li>
      <li><code>a = 20</code></li>
      <li><code>b = 12</code></li>
      <li><code>b != 0</code> eli algoritmi jatkuu.</li>
      <li><code>c = 20</code></li>
      <li><code>a = 12</code></li>
      <li><code>b = 8</code></li>
      <li><code>b != 0</code> eli algoritmi jatkuu.</li>
      <li><code>c = 12</code></li>
      <li><code>a = 8</code></li>
      <li><code>b = 4</code></li>
      <li><code>b != 0</code> eli algoritmi jatkuu.</li>
      <li><code>c = 8</code></li>
      <li><code>a = 4</code></li>
      <li><code>b = 0</code></li>
      <li><code>b = 0</code> eli suurin yhteinen tekijä on <code>4</code>.</li>
    </ul>
    <p><b>Vinkki:</b> Tarvitset siis silmukkaa algoritmin toteuttamisessa.</p>
    <h4>Pienimmän yhteisen jaettavan laskeminen suurimman yhteisen tekijän avulla</h4>
    <p>Luo luokkaan <code>PieninYhteinenJaettava</code> metodi <code>public static int pieninYhteinenJaettava(int luku1, int luku2)</code>, joka laskee parametreina annettujen lukujen pienimmän yhteisen tekijän käyttämällä apuna lukujen suurinta yhteistä tekijää.</p>
    <p>Pienin yhteinen jaettava voidaan laskea helposti seuraavalla kaavalla luvuille <code>a</code> ja <code>b</code>, kun <code>syt</code> laskee lukujen suurimman yhteisen tekijän:</p>
    <pre>(a * b) / syt(a, b)</pre>
    <p>Esimerkiksi:</p>
    <pre>
            a = 32
            b = 6

            syt(32, 6) = 2

            (32 * 6) / syt(32, 6) = 192 / 2 = 96
          </pre>
    <p><b>Huom:</b> Metodin <code>pieninYhteinenJaettava</code> on siis kutsuttava edellisessä kohdassa tehtyä metodia <code>suurinYhteinenTekija</code>.</p>
  </div>
  <div class="tehtavat">
    <h3>Pankki</h3>
    <p>Tehtäväpohjan mukana tulee kaksi luokkaa, <code>Pankki</code> ja <code>Tili</code>, sekä pääohjelmaluokka <code>Ohjelma</code>. Luokalla <code>Tili</code> on:</p>
    <ul>
      <li>Olion luova metodi <code>public Tili(String tilinNimi)</code> luo annetun nimisen tilin.</li>
      <li>Metodi <code>public double nosta(double paljonko)</code> yrittää nostaa tililtä annetun summan. Palauttaa nostetun rahamäärän, joka voi olla annettua pienempi kuin pyydetty jos tilillä olevat rahat eivät riitä.</li>
      <li>Metodi <code>public void pane(double paljonko)</code> lisää tilille annetun summan.</li>
      <li>Metodi <code>public String tilinNimi()</code> palauttaa tilin nimen.</li>
      <li>Metodi <code>public double tilinSaldo()</code> palauttaa tilin saldon.</li>
    </ul>
    <p>Luokalla pankki on:</p>
    <ul>
      <li>Olion luova metodi <code>Pankki(String pankinNimi)</code> luo annetun nimisen pankin.</li>
      <li>Metodi <code>void lisaaTili(Tili tili)</code> lisää pankkiin annetun tilin. On virhe yrittää lisätä saman niminen tili kaksi kertaa.</li>
      <li>Metodi <code>Tili haeTili(String nimi)</code> hakee annetun nimisen tilin pankista. On virhe yrittää hakea tiliä jota ei ole ensin lisätty pankkiin.</li>
      <li>Metodi <code>void tilisiirto(String mista, String minne, double paljonko)</code> suorittaa siirron pankin sisällä annetun nimisten
        tilien välillä.</li>
      <li>Metodi <code>double pankinSaldo()</code> palauttaa pankissa olevien tilien saldojen summan.</li>
    </ul>
    <p><em>Tehtäväsi on</em> luoda pääluokkaan nimeltä <code>Ohjelma</code> ohjelma joka</p>
    <ol>
      <li>luo kaksi Pankki-oliota, nimiltään MegaPankki, ja HassuPankki<br/>
        <strong>muistutus:</strong> olio siis luodaan seuraavasti <code>Pankki megaPankki = new Pankki("MegaPankki")</code></li>
      <li>luo tilin nimeltään Pekka, tallettaa siihen 100, ja lisää tilin MegaPankkiin</li>
      <li>luo tilin nimeltään Simo, tallettaa siihen 20, ja lisää sen MegaPankkiin.</li>
      <li>luo tilin nimeltään Korianteri, tallettaa siihen 5, ja lisää sen Hassupankkiin</li>
      <li>luo tilin nimeltään Terminaattori, tallettaa siihen 7, ja lisää sen HassuPankkiin.</li>
      <li>siirt&auml;&auml; Pekan tililt&auml; 50 Simon tilille<br/>
        <strong>muistutus:</strong> k&auml;yt&auml; Pankki-luokan tilisiirto-metodia.</li>
      <li>siirt&auml;&auml; Korianterin tililt&auml; 0.5 Terminaattorin tilille<br/>
      <li>tulostaa pankkien saldot allaolevassa muodossa (summat alla ovat vääriä):
        <pre>
                        MegaPankki: 45.0
                        HassuPankki: 70.0
                      </pre>
      </li>
    </ol>
    <p><em>Huom!</em> suorita ohjelmassasi vain kuvaillut toimenpiteet.</p>
  </div>
  <h3>ArrayList metodin paluuarvona</h3>
  <p>ArrayList voi toimia myös metodin paluuarvona. Seuraavassa esimerkkinä metodi joka luo listan, lisää sille parametrinaan saamansa kolme kokonaislukua ja palauttaa lopuksi listan. Huomaa miten pääohjelma tallettaa metodin palauttaman listan muuttujaan jonka tyyppi on sama kuin metodin palauttamaan listan tyyppi:</p>
  <pre class="sh_java">
                    public class Main {

                    public static ArrayList&lt;Integer&gt; laitaLuvutListalle(int luku1, int luku2, int luku3){
                    ArrayList&lt;Integer&gt; lista = new ArrayList&lt;Integer&gt;();

                    lista.add(luku1);
                    lista.add(luku2);
                    lista.add(luku3);

                    return lista;
                  }

                  public static void main(String[] args) {
                  ArrayList&lt;Integer&gt; luvut = laitaLuvutListalle(3, 5, 2);

                  for (int luku : luvut) {
                  System.out.println( luku );
                }
              }
            }
          </pre>
  <div class="tehtavat">
    <h3 class="req">Merkkijonojen pituudet</h3>
    <p>Tee metodi <code>pituudet</code>,
      joka palauttaa <code>ArrayList</code>issä saamiensa
      merkkijonojen pituudet, ja palauttaa
      ne <code>ArrayList</code>inä samassa järjestyksessä.</p>
    <pre class="sh_java">
                public static ArrayList&lt;Integer&gt; pituudet(ArrayList&lt;String&gt; lista) {
                // kirjoita koodia tähän
              }

              public static void main(String[] args) {
              ArrayList&lt;String&gt; lista = new ArrayList&lt;String&gt;();
              lista.add("Hei");
              lista.add("Moi");
              lista.add("Benvenuto!");
              lista.add("badger badger badger badger");
              ArrayList&lt;Integer&gt; pituudet = pituudet(lista);

              System.out.println("Pituudet: " + pituudet);
            }
          </pre>
    <p>Ohjelman tulostus:</p>
    <pre>
            Pituudet: [3, 3, 10, 27]
          </pre>
  </div>
  <h3>Wikipedia</h3>
  <p>Tehtäväpohjan mukana tulee luokka <code>Wikipedia</code>, josta luotu olio yhdistää internetin yli (englanninkieliseen) wikipediaan ja kyselee sieltä tietoja. Luokalla on metodi <code>ArrayList&lt;String&gt; getLinks(String title)</code> joka hakee kaikkien niiden sivujen nimet, joille annetulta sivulta on linkki. Esimerkiksi seuraava ohjelmanpätkä:</p>
  <pre class="sh_java">
          Wikipedia wiki = new Wikipedia();
          ArrayList&lt;String&gt; linkit = wiki.getLinks("Helsinki");

          Collections.sort(linkit);
          Collections.reverse(linkit);

          System.out.println("1: " + linkit.get(0));
          System.out.println("2: " + linkit.get(1));
          System.out.println("3: " + linkit.get(2));
        </pre>
  <p>Tulostaa (tällä hetkellä, wikipedia muuttuu jatkuvasti):</p>
  <pre>
          1: Pasila
          2: Parliament of Finland
          3: Parliament House, Helsinki
        </pre>
  <p><em>Toteuta ohjelma</em>, joka ensin kysyy käyttäjältä wikipediasivun nimen ja tämän jälkeen hakee kyseisen sivun linkit ja tulostaa niiden määrän. Tämän jälkeen käyttäjä voi suorittaa kyselyitä linkkilistaan. Ohjelma päättyy kun käyttäjä syöttää tyhjän rivin. Esimerkki:</p>
  <pre>
          Anna wikipediasivun nimi:
          <font color="red">Helsinki</font>
          Sivulta Helsinki on 130 linkkiä.
          Linkkikysely:
          <font color="red">Pasila</font>
          Sivulta Helsinki on linkki sivulle Pasila
          Linkkikysely:
          <font color="red">Barack Obama</font>
          Sivulta Helsinki ei ole linkkiä sivulle Barack Obama
          Linkkikysely:

        </pre>
  <div class="tehtavat">
    <h3>Hienoja laatikoita</h3>
    <p>Toteuta neljä <code>tulostaLaatikko</code>-metodia:</p>
    <ul>
      <li><code>public static void tulostaLaatikko(String teksti, char merkki)</code> tulostaa annetun tekstin ympäröitynä annetulla merkillä. Esimerkiksi <code>tulostaLaatikko("festivål",'%')</code> tulostaa:
        <pre>
                %%%%%%%%%%%%
                % festivål %
                %%%%%%%%%%%%
              </pre>
      </li>
      <li><code>public static void tulostaLaatikko(String teksti)</code> tulostaa annetun tekstin ympäröitynä merkillä <code>#</code>. Siis <code>tulostaLaatikko("uliuliuliuli")</code> tulostaa:
        <pre>
                ################
                # uliuliuliuli #
                ################
              </pre>
      </li>
      <li><code>public static void tulostaLaatikko(char merkki)</code> tulostaa tekstin <code>Hello world!</code> ympäröitynä annetulla merkillä. Siis <code>tulostaLaatikko('K')</code> tulostaa:
        <pre>
                KKKKKKKKKKKKKKKK
                K Hello world! K
                KKKKKKKKKKKKKKKK
              </pre>
      </li>
      <li><code>public static void tulostaLaatikko()</code> tulostaa tekstin <code>Hello world!</code> ympäröitynä merkillä <code>#</code>.</li>
    </ul>
    <p><b>HUOM:</b> Toteuta kolme viimeistä metodia niin, että ne vain kutsuvat metodia <code>tulostaLaatikko(String teksti, char merkki)</code> oikeilla arvoilla.</p>
    <p><strong>Muistutus!</strong> Javassa yksittäistä merkkiä merkitään näin: <code>'K'</code>. Huomaa ero yhden pituiseen merkkijonoon <code>"K"</code>!</p>
    <p><strong>Muistutus!</strong> Tässä tehtävässä tehdään jälleen <strong><code>static</code></strong>-metodeja, kuten esim. viikolla 3. Sanan <code>static</code> tarkka merkitys kerrotaan ensi viikolla, lyhyesti sanottuna kyse on metodeista, jotka eivät liity mihinkään olioon vaan saavat kaiken käsittelemänsä tiedon parametrina.</p>
    <h3 class="req">Onko sana taulukossa?</h3>
    <p>Tee metodi <code>public static boolean onkoSanaTaulukossa(String[] taulukko)</code>, joka palauttaa totuusarvon sen mukaan onko käyttäjän antama sana taulukossa. Kirjoita lisäksi <code>main</code>-metodiin ohjelma, joka testaa <code>onkoSanaTaulukossa</code>-metodia allaolevan esimerkkitulostuksen mukaisesti kertoen onko sana taulukossa vai ei.</p>
    <p>Ohjelman runko on seuraava:</p>
    <pre class="sh_java">
            import java.util.Scanner;

            public class Main {
            public static void main(String[] args) {
            // Tässä voit testata metodia
            String[] taulukko = {"apina", "banaani", "cembalo"};

            Scanner lukija = new Scanner(System.in);
            // Kirjoita tähän koodi, joka kysyy sanan ja kertoo oliko sana taulukossa vai ei
            // Muista käyttää metodia onkoSanaTaulukossa()!
          }

          public static boolean onkoSanaTaulukossa(String[] taulukko, String sana) {
          // Tarkista täällä onko sana taulukossa ja palauta tulos
          return false;
        }
      }
    </pre>
    <p>Esimerkkitulostuksia:</p>
    <pre>
      Anna sana: <font color="red">apina</font>
      Sana on taulukossa.
    </pre>
    <pre>
      Anna sana: <font color="red">siili</font>
      Sanaa ei ole taulukossa.
    </pre>
    <p>Muista, mitä erityistä merkkijonojen vertailussa on!</p>
    <h3>Taulukon pienin luku</h3>
    <p>Tee metodi <code>public static int etsiTaulukonPieninLuku(int[] taulukko)</code>, joka palauttaa taulukon pienimmän luvun.</p>
    <p>Ohjelman runko on seuraava:</p>
    <pre class="sh_java">
      public class Main {
      public static void main(String[] args) {
      // Tässä voit testata metodia
      int[] taulukko = {5, 1, 3, 4, 2};
      System.out.println(etsiTaulukonPieninLuku(taulukko));
    }

    public static int etsiTaulukonPieninLuku(int[] taulukko) {
    // Kirjoita pienimmän luvun etsivä koodi tänne
    return 0;
  }
}
</pre>
    <p>Ohjelman tulostus on seuraava:</p>
    <pre>
  1
</pre>
    <h3>Arrays.sort</h3>
    <p>Tee ohjelma, joka kysyy käyttäjältä lukujen määrän ja joukon lukuja. Tämän jälkeen ohjelma tulostaa luvut järjestyksessä. Ohjelman tulee toimia seuraavasti:</p>
    <pre>
  Kuinka monta lukua? <font color="red">4</font>
  Anna luvut:
  <font color="red">5</font>
  <font color="red">2</font>
  <font color="red">8</font>
  <font color="red">1</font>
  Luvut järjestyksessä:
  1
  2
  5
  8
</pre>
  </div>
  <div class="tehtavat">
    <h3>Korttipakka</h3>
    <p>Tässä tehtävässä luodaan korttipakka, jonka kehitystä  jatketaan seuraavilla viikoilla. Tehtävässä luodaan luokka <code>Kortti</code>, josta luodaan jokaista eri pelikorttia varten luodaan oma ilmentymä. Tehtävässä luodaan myös luokat <code>Korttipakka</code> ja <code>Kasi</code> jotka sisältävät <code>Kortti</code>-olioita. Korttipakasta taas voidaan nostaa kortteja joko yksitellen tai kädellinen.</p>
    <p>Tehtävässä toteutetaan ohjelma kolmessa askeleessa. Luokat ja toteutettavien metodien rungot ovat mukana tehtäväpohjassa.</p>
    <h4 class="req">Kortti-luokan toteuttaminen </h4>
    <p>Kortti-olio tallentaa arvonsa nollasta alkavilla luvuilla - arvo on vähintään nolla (ässä) ja enintään 12 (kuningas). Kortin maa on 0 (risti), 1 (ruutu), 2 (hertta) tai 3 (pata). Sinun ei tarvitse vielä tässä tehtävässä varmistaa, että kortteja luodaan vain näille arvoalueille sopivilla arvoilla.</p>
    <p>Toteuta seuraavat metodit:</p>
    <ul>
      <li> konstruktori <code>Kortti(int arvo, int maa)</code> luo uuden olion ja samalla asettaa parametrina annetun arvon kortin arvoksi ja parametrina annetun maan kortin maaksi.</li>
      <li> metodi <code>getArvo</code> palauttaa kortin arvon</li>
      <li> metodi <code>getMaa</code> palauttaa kortin maan</li>
      <li> metodi <code>toString</code> palauttaa kortin merkkijonoesityksen (katso esimerkki alta)</li>
    </ul>
    <p>Tulostuksen helpottamiseksi Kortti-luokalla on myös valmiiksi toteutetut ArrayListit <code>maidenNimet</code> maita ja <code>arvojenNimet</code> kortin arvoja varten. <code>maidenNimet.get(maa)</code> on maan selkokielinen merkkijonoesitys ("Risti", "Ruutu" jne...). <code>arvojenNimet.get(arvo)</code> on arvon korttipakkaan sopiva lyhenne (A, J, Q, K normaalien lukumerkintöjen lisäksi).
    <p><code>toString</code>-metodin esimerkkitulostuksia:
    <pre>Risti 4
        Pata K
        Pata 5
        Hertta Q
        Risti 6
        Risti A
        Hertta 9
        Ruutu 8
        Ruutu 7
        Ruutu J
      </pre>
    </p>
    <h4 class="req">Kasi-luokan toteuttaminen</h4>
    <p>Kasi-olio esittää korttikättä, eli kokoelmaa korteista, jotka ovat peräisin samasta korttipakasta. Käsi voi olla myös tyhjä, jolloin siinä ei ole kortteja.</p>
    <p>Toteuta seuraavat luokan <code>Kasi</code> metodit</p>
    <ul>
      <li>konstruktori <code>public Kasi(ArrayList&lt;Kortti&gt; kortit)</code> luo uuden Käsi-olion, joka sisältää konstruktorin parametrina saadun listan korteista.</li>
      <li>metodi <code>suurinKortti</code> palauttaa viitteen arvolta suurimpaan korttiin. Huomaa, että samanarvoisista korteista suurempi määräytyy maan perusteella (suurimmasta pienimpään: pata, hertta, ruutu, risti). Arvojärjestyksessä pienin kortti on ässä (arvoltaan 0) ja suurin on kuningas (arvoltaan 12).</li>
      <li>metodi <code>pieninKortti</code> palauttaa viitteen arvolta pienimpään korttiin. Huomaa, että myös kortin maa vaikuttaa kortin arvoon ja maalle valmiiksi määriteltyä numeroarvoa voi käyttää maiden vertailuun.</li>
      <li>metodi <code>arvojenSumma</code> palauttaa Kasi-olion sisältämien Korttien kokonaisarvon. Toteuta metodi niin, että se laskee jokaisen kortin arvon yhdellä suuremmaksi kuin mitä se Kortti-olion mielestä on -- näin summa saadaan vastaamaan pelikorttien todellisia arvoja nollasta alkavien arvojen sijaan.</li>
      <li>metodi <code>getKortit</code> palauttaa käden sisältämät kortit ArrayListissä.</li>
    </ul>
    <h4 class="req">Korttipakka-luokan toteuttaminen</h4>
    <p>Korttipakka-olio esittää tavallista korttipakkaa, joka koostuu 52 kortista. Täysi korttipakka sisältää jokaisen neljän maan (pata, risti, ruutu ja hertta) kaikki 13 korttia ässästä kuninkaaseen. Kortin poistamista korttipakasta kutsutaan <i>nostamiseksi</i>.</p>
    <p>Toteuta seuraavat luokan <code>Korttipakka</code> metodit</p>
    <ul>
      <li>konstruktori <code>Korttipakka</code> luo ja lisää kaikki 52 korttia korttipakkaan. Korttipakkaan tulee päätyä kaikki maa- ja arvoyhdistelmät. Kun luot Kortteja pakkaan, voit antaa <code>maa</code>-parametriksi <code>Kortti.MAA_RISTI</code>, <code>Kortti.MAA_RUUTU</code>, <code>Kortti.MAA_HERTTA</code> tai <code>Kortti.MAA_PATA</code>. </li>
      <li>metodi <code>nostaPaallimmainenKortti</code> poistaa pakassa ensimmäisenä olevan kortin ja palauttaa viitteen siihen. Metodi palauttaa <code>null</code>-viitteen, jos kortteja ei enää ole.</li>
      <li>metodi <code>nostaKasi(int korttienMaara)</code> nostaa pakasta parametrina annetun määrän verran kortteja, luo niistä uuden Kasi-olion ja palauttaa sen. Metodi palauttaa vajaan käden, jos kortteja ei ole tarpeeksi, tai tyhjän käden, jos pakassa ei ole jäljellä kortteja lainkaan.</li>
      <li>metodi <code>korttienMaara</code> palauttaa korttipakan sisältämien korttien määrän. </li>
      <li>metodi <code>getKortit</code> palauttaa korttipakan sisältämät kortit ArrayListissä. </li>
      <li>metodi <code>sekoita</code> sekoittaa korttipakan kortit. (vinkki: <code>Collections</code>-luokasta löytyy tähän näppärä metodi) </li>
    </ul>
    <p><b>Huom:</b> Korttipakasta kortteja nostavat metodit voivat aiheuttaa helposti poikkeustilanteita, jos kortit loppuvat kesken. Tee metodien toteutukset huolellisesti, ettei näin pääse käymään.</p>
  </div>
  <div class="tehtavat">
    <h3>Hotelli</h3>
    <p>Tämä tehtävä toteutetaan kolmessa osassa. </p>
    <h4 class="req">Vieras-luokan toteuttaminen</h4>
    <p>Toteuta seuraavat metodit luokkaan <code>Vieras</code> </p>
    <ul>
      <li>Konstruktori <code>Vieras(String nimi, int vierasID)</code> joka asettaa parametrinä saamansa Stringin olion 'muistiin', samoin kuin saamansa vierasID:n.</li>
      <li>metodi <code>getNimi()</code> palauttaa vieraan nimen</li>
      <li>metodi <code>getVierasID()</code> palauttaa vieraan vierasID:n</li>
      <li>metodi <code>toString()</code> palauttaa vieraan nimen ja vierasID:n. Kts. alla oleva esimerkki tuloste</li>
    </ul>
    <p><code>Vieras</code>-luokan esimerkki toString metodin tulosteita</p>
    <pre>
        Pekka: 14
        Timo: 15
        Jaakko: 16
      </pre>
    <h4 class="req">Huone-luokan toteuttaminen</h4>
    <p>Toteuta seuraavat metodit luokkaan <code>Huone</code></p>
    <ul>
      <li>konstruktori <code>Huone()</code> joka oletuksena asettaa huoneen kapasiteetiksi 2</li>
      <li>konstruktori <code>Huone(int kapasiteetti)</code> joka asettaa huoneen kapasiteetiksi parametrinä saadun kapasiteetin</li>
      <li>metodi <code>lisaaVieras(Vieras vieras)</code> asettaa vieraat luokan oliomuuttujana olevaan <code>Vieras</code> taulukkoon ja huolehtii siitä, että huoneeseen ei lisätä enempää ihmisiä kun mitä huoneeseen mahtuu. Lisäksi Vierasta ei lisätä Huoneeseen jos Vieras on jo siellä. Metodi palauttaa <code>true</code> mikäli lisääminen onnistui, muulloin <code>false</code>. </li>
      <li>metodi <code>huoneenKoko()</code> joka palauttaa huoneen kapasiteetin</li>
      <li>metodi <code>vieraitaNyt()</code> joka palauttaa huoneessa olevien henkilöiden määrän</li>
      <li>metodi <code>annaVieras(int VierasID)</code> joka palauttaa viitteen <code>Vieras</code>-luokan olioon, jonka <code>vierasID</code> on sama kuin parametrina saatu vierasID. Jos vierasta ei löydy palautetaan <code>null</code>. Huomaa että tätä metodia käytettäessä tulee huomioida, että on mahdollista, että metodi palauttaa <code>null</code> olioviitteen sijaan</li>
      <li>metodi <code>toString()</code> palauttaa huoneessa olevat henkilöt, kts alla oleva esimerkkituloste</li>
    </ul>
    <p>Huone luokan <code>toString()</code> metodin esimerkkitulostuksia, alla viiden huoneen tulostukset, joista viimeinen on tyhjä:</p>
    <pre>
        Aino: 2, Timo: 3
        Timo: 4, Snorri: 5
        Markku: 6, Noris: 7
        Timo: 124, Saku: 114, Teppo: 29
        Huone tyhjä
      </pre>
    <h4 class="req">Hotelli-luokan toteutus</h4>
    <p>toteuta seuraavat metodit luokkaan <code>Hotelli</code></p>
    <ul>
      <li>konstruktori <code>Hotelli()</code> joka alustaa huoneiden säilömisessä käytetyn <code>ArrayList&lt;Huone&gt;</code> </li>
      <li>metodi <code>lisaaHuoneita(int maara)</code> joka lisää <code>maara</code>:n verran oletuskokoisia huoneita hotelliin ja ne lisätään hotellin <code>huoneet</code> ArrayListiin. Käytä tässä luokan <code>Huone</code> parametritonta konstruktoria </li>
      <li> metodi <code>lisaaHuoneita(int maara, int koko)</code> joka lisää <code>maara</code>:n verran <code>koko</code>:n kokoisia huoneita hotelliin, ja ne lisätään hotellin <code>huoneet</code> ArrayListiin</li>
      <li> metodi <code>luoUusiVieras(String nimi)</code> luo uuden vieraan ja asettaa sille nimeksi parametrinä saadun nimen, sekä uniikin vierasID:n. Hotelli siis pitää kirjaa vierasID:istä ja osaa aina antaa uuden uniikin vierasID:n. Hotellin ensimmäinen vieras saa ID:n 1 seuraava ID:n 2, jne...</li>
      <li> metodi <code>hotellissaVieraita()</code> joka palauttaa hotellisa olevien vieraiden kokonaismäärän</li>
      <li> metodi <code>annaSopivaHuone(int koko)</code> joka palauttaa sopivan huoneen, joka on koko parametrin kokoinen ja on tyhjä. Mikäli sopivaa tyhjää huonetta ei löydy, palautetaan <code>null</code></li>
      <li> metodi <code>etsiVieras(int vierasID)</code> joka käy läpi huonelistan ja tarkistaa jokaiselta huoneelta, onko kyseisellä <code>vierasID</code>llä olevaa henkilöä. Mikäli henkilöä ei löydy palautetaan null. (Varaudu tähän).</li>
      <li> metodi <code>toString()</code> joka palauttaa siistityn tulostuksen, josta käy ilmi kaikkien hotellivieraiden nimet ja vierasIDt. Hyödynnä tässä <code>Huone</code> ja <code>Vieras</code> -luokkien toString metodeja. Esimerkkitulostus löytyy alempaa.</li>
    </ul>
    <p>Hotellilla on valmiiksi toteutettuna metodi <code>getHuoneet()</code> joka palauttaa viitteen <code>huoneet</code>-ArrayListiin. </p>
    <p><code>Hotelli</code>-luokan toString metodin esimerkkitulostus:</p>
    <pre>
        kalle: 1, Simo: 2
        kalle: 3, Timo: 4
        kalle: 5, Snorri: 6
        kalle: 7, Noris: 8
        kalle: 9, Malloc: 10
        kalle: 11, Rase: 12
        kalle: 13, Dogo: 14
        Huone tyhjä
        Huone tyhjä
        Huone tyhjä
        Huone tyhjä
        Huone tyhjä
        Huone tyhjä
        Huone tyhjä
        Huone tyhjä
      </pre>
  </div>s
</section>

<!-- END MOOC SNIP -->
<!-- END SNIP -->

</body>
</html>
